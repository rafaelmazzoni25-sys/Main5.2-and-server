<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Guia de Aprendizagem Unreal Engine 5+</title>
    <link rel="stylesheet" href="style.css" />
</head>
<body>
    <header class="hero" role="banner">
        <h1>Jornada Completa na Unreal Engine 5+</h1>
        <p>Aprenda do zero ao domínio profundo com um guia organizado para mentes curiosas e neurodivergentes.</p>
        <button id="resume-button" type="button" class="primary">Continuar de onde parei</button>
        <nav class="quick-links" aria-label="Atalhos rápidos">
            <a href="#fundamentos">Fundamentos</a>
            <a href="#blueprints">Blueprints</a>
            <a href="#renderizacao">Renderização</a>
            <a href="#blueprint-pro">Blueprints Avançados</a>
            <a href="#sistemas-progressao">Progressão &amp; Economia</a>
            <a href="#sistemas-mundo">Mundo &amp; IA</a>
            <a href="#sistemas-combate">Combate &amp; Animação</a>
            <a href="#guia-itens">Guia de Itens</a>
            <a href="#muonline-migracao">Projeto Especial</a>
        </nav>
    </header>

    <main id="conteudo" role="main">
        <nav class="toc" aria-label="Mapa da jornada">
            <h2>Mapa da Jornada</h2>
            <ol id="toc-list"></ol>
        </nav>

        <section class="intro focus-block" data-section-id="intro">
            <h2>Como usar este guia</h2>
            <p>Este material foi pensado para lhe dar clareza em quatro dimensões: <strong>O quê</strong>, <strong>Por quê</strong>, <strong>Quando</strong> e <strong>Onde</strong>.</p>
            <ul>
                <li><strong>O quê?</strong> Conceito objetivo do tema.</li>
                <li><strong>Por quê?</strong> Benefício prático ou teórico de dominar o tópico.</li>
                <li><strong>Quando?</strong> Momento ideal de aplicar no fluxo de um projeto.</li>
                <li><strong>Onde?</strong> Localização na interface da Unreal ou arquivos relevantes.</li>
            </ul>
            <p>Use os botões de foco para reduzir distrações e as listas de verificação para acompanhar o progresso. Marque cada item concluído para que o site memorize seu avanço.</p>
        </section>

        <section class="module" data-section-id="fundamentos">
            <header>
                <h2>Módulo 1: Fundamentos da Unreal Engine</h2>
                <p class="tag">Nível: Iniciante</p>
            </header>
            <article class="lesson">
                <h3>Instalação e configuração inicial</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Instalar a Unreal Engine via Epic Games Launcher e configurar os requisitos mínimos.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Uma instalação correta garante acesso às versões atualizadas, templates e recursos oficiais.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Antes de iniciar qualquer curso ou projeto prático.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Epic Games Launcher &gt; Unreal Engine &gt; Biblioteca &gt; Instalar.</dd>
                    </div>
                </dl>
                <ul class="checklist" aria-label="Tarefas de instalação">
                    <li><input type="checkbox" data-task-id="fundamentos-instalacao-download" /> Baixar o Epic Games Launcher.</li>
                    <li><input type="checkbox" data-task-id="fundamentos-instalacao-requisitos" /> Conferir drivers de GPU e espaço em disco.</li>
                    <li><input type="checkbox" data-task-id="fundamentos-instalacao-primeiro-projeto" /> Criar um projeto de teste usando o template <em>Third Person</em>.</li>
                </ul>
            </article>
            <article class="lesson">
                <h3>Explorando a interface</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Conhecer o Editor viewport, Outliner, Content Browser e Details Panel.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Compreender a organização da interface reduz a sobrecarga cognitiva durante o desenvolvimento.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Após abrir seu primeiro projeto e antes de criar qualquer asset.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Editor principal da Unreal: painéis ancorados e menus de janela.</dd>
                    </div>
                </dl>
                <div class="focus-tools">
                    <button type="button" class="focus-toggle" data-target="fundamentos-interface-mapa">Mostrar mapa mental</button>
                    <div id="fundamentos-interface-mapa" class="focus-panel" hidden>
                        <p><strong>Mapa mental rápido:</strong></p>
                        <ul>
                            <li>Viewport → manipular objetos 3D.</li>
                            <li>Outliner → hierarquia de atores.</li>
                            <li>Content Browser → assets e pastas.</li>
                            <li>Details Panel → parâmetros do ator selecionado.</li>
                        </ul>
                    </div>
                </div>
            </article>
        </section>

        <section class="module" data-section-id="blueprints">
            <header>
                <h2>Módulo 2: Blueprints Visuais</h2>
                <p class="tag">Nível: Intermediário</p>
            </header>
            <article class="lesson">
                <h3>Programação visual com Blueprints</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Sistema de scripts visuais baseado em nós que controla lógica de jogo sem código C++.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Permite prototipar rapidamente e visualizar fluxos de execução, ideal para manter o foco.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Ao criar interações, lógica de personagens ou sistemas de UI.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>No Blueprint Editor (tecla <kbd>Ctrl</kbd> + <kbd>B</kbd> com um asset selecionado).</dd>
                    </div>
                </dl>
                <ul class="checklist" aria-label="Tarefas de Blueprints básicos">
                    <li><input type="checkbox" data-task-id="blueprints-variaveis" /> Criar variáveis básicas (boolean, float, vector).</li>
                    <li><input type="checkbox" data-task-id="blueprints-event-graph" /> Construir um fluxo simples no Event Graph.</li>
                    <li><input type="checkbox" data-task-id="blueprints-debug" /> Utilizar <em>Print String</em> para depurar um evento.</li>
                </ul>
            </article>
            <article class="lesson">
                <h3>Padrões avançados</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Uso de Game Instance, Interfaces e Componentes para modularidade.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Organiza projetos grandes e permite reaproveitamento sem retrabalho.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Ao escalar um projeto ou compartilhar lógica entre múltiplos atores.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Blueprint Class Editor &gt; Class Settings / Components.</dd>
                    </div>
                </dl>
                <div class="focus-tools">
                    <button type="button" class="focus-toggle" data-target="blueprints-avancado-dicas" data-open-label="Ocultar dicas" data-close-label="Dicas de retenção">Dicas de retenção</button>
                    <div id="blueprints-avancado-dicas" class="focus-panel" hidden>
                        <p>Quebre o estudo em blocos de 25 minutos e, após cada bloco, revise mentalmente os nós utilizados em ordem lógica.</p>
                    </div>
                </div>
            </article>
        </section>

        <section class="module beginner-roadmap" data-section-id="trilha-zero-remake">
            <header>
                <h2>Trilha do Zero até o Remake</h2>
                <p class="tag">Iniciante absoluto</p>
            </header>

            <article class="lesson step-guide">
                <h3>Fase 1 – Entender as peças antes de recriar</h3>
                <p>Objetivo: transformar arquivos C++ em conceitos visuais fáceis de lembrar antes de abrir qualquer Blueprint.</p>
                <ol class="step-list">
                    <li>
                        <strong>Leia com calma o que cada função faz.</strong>
                        Foque em trechos curtos como <code>LoadImages</code> e <code>SetButtonInfo</code> que apenas carregam imagens e posicionam botões na tela do HUD. Observe que o código só repete caminhos de arquivo e coordenadas, nada “mágico”.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L59-L160】
                    </li>
                    <li>
                        <strong>Desenhe o fluxo em papel ou bloco.</strong>
                        Marque a ordem que o <code>Render</code> segue: desenhar moldura, atualizar barras e, por último, os botões. Isso vira um fluxograma simples que você poderá copiar para o <em>Event Graph</em> depois.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L180-L197】
                    </li>
                    <li>
                        <strong>Mapeie as estruturas de dados.</strong>
                        No inventário, destaque que primeiro cria-se o grid 8×8, depois cada item do pacote vira uma estrutura completa com nível, sockets e efeitos especiais para pets. Liste esses campos em português em uma folha para saber que variáveis criar nos Blueprints.【F:Source Main 5.2/source/NewUIMyInventory.cpp†L65-L147】
                    </li>
                    <li>
                        <strong>Traduza termos desconhecidos.</strong>
                        Pesquise palavras como “socket” ou “tooltip” e escreva o significado ao lado da função correspondente. Isso evita travar quando ler nomes como <code>CreateEquippingEffect</code> ou <code>SendRequestPetInfo</code> nas próximas fases.【F:Source Main 5.2/source/NewUIMyInventory.cpp†L133-L185】
                </ol>
                <ul class="checklist" aria-label="Checklist da fase 1">
                    <li><input type="checkbox" data-task-id="fase1-anotar-funcoes" /> Fiz anotações em português sobre cada função que aparece no HUD e inventário.</li>
                    <li><input type="checkbox" data-task-id="fase1-fluxograma" /> Montei um fluxograma simples da ordem de desenho do HUD.</li>
                    <li><input type="checkbox" data-task-id="fase1-glossario" /> Criei um mini glossário com os termos técnicos que encontrei.</li>
                </ul>
            </article>

            <article class="lesson step-guide">
                <h3>Fase 2 – Montar o cliente em Blueprints</h3>
                <p>Objetivo: repetir no editor o que você entendeu no papel, sem tocar em código C++.</p>
                <ol class="step-list">
                    <li>
                        <strong>Construa o HUD com Widgets.</strong>
                        Crie o <code>WBP_MainHUD</code>, adicione imagens seguindo a mesma ordem da função <code>Render</code> e configure os cinco botões com o espaçamento indicado por <code>x_Add</code> (= 30). Use o <em>Details Panel</em> para definir tooltips iguais aos originais.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L117-L160】【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L180-L197】
                    </li>
                    <li>
                        <strong>Crie DataTables para itens.</strong>
                        Cada linha deve conter tipo, nível, sockets e campos especiais. Esses dados são os mesmos copiados para o slot quando <code>EquipItem</code> é chamado, então garanta que o seu <code>StructBP_Item</code> tenha essas entradas.【F:Source Main 5.2/source/NewUIMyInventory.cpp†L115-L147】</li>
                    <li>
                        <strong>Implemente eventos de equipar e remover.</strong>
                        Use <em>Event Dispatchers</em> para simular <code>CreateEquippingEffect</code>, <code>SendRequestPetInfo</code> e <code>UnequipItem</code>. Separe um dispatcher só para pets para que a lógica fique clara ao revisar.【F:Source Main 5.2/source/NewUIMyInventory.cpp†L125-L185】
                    </li>
                    <li>
                        <strong>Teste como jogador.</strong>
                        Execute o projeto, clique nos botões e valide se os tooltips aparecem, se as barras atualizam na ordem planejada e se pets disparam efeitos corretos. Ajuste o Blueprint até ficar igual ao fluxo anotado na fase 1.</li>
                </ol>
                <ul class="checklist" aria-label="Checklist da fase 2">
                    <li><input type="checkbox" data-task-id="fase2-hud" /> HUD criado e funcionando com tooltips.</li>
                    <li><input type="checkbox" data-task-id="fase2-datatable" /> DataTable de itens preenchida com campos do inventário.</li>
                    <li><input type="checkbox" data-task-id="fase2-eventos" /> Eventos de equipar/remover replicando efeitos e pets.</li>
                </ul>
            </article>

            <article class="lesson step-guide">
                <h3>Fase 3 – Substituir os servidores passo a passo</h3>
                <p>Objetivo: montar subsistemas Blueprint que fazem o mesmo trabalho do ConnectServer e do GameServer originais.</p>
                <ol class="step-list">
                    <li>
                        <strong>Comece pelo ConnectServer.</strong>
                        Recrie o <code>switch</code> dos pacotes em um <em>GameInstance Subsystem</em> e garanta que há um mapa “cabeçalho → função”. Essa estrutura vem direto do <code>ConnectServerProtocolCore</code>.【F:Source MuServer Update 15/ConnectServer/ConnectServer/ConnectServerProtocol.cpp†L10-L27】
                    </li>
                    <li>
                        <strong>Prepare mensagens de resposta.</strong>
                        Ao tratar <code>CCServerInfoRecv</code> e <code>CCServerListRecv</code>, preencha structs com IP, porta e contagem de mundos antes de enviar aos clientes. Em Blueprint, isso vira um <code>Struct BP_ServerInfo</code> e um <code>Array</code> replicado.【F:Source MuServer Update 15/ConnectServer/ConnectServer/ConnectServerProtocol.cpp†L34-L87】
                    </li>
                    <li>
                        <strong>Monte o roteador do GameServer.</strong>
                        Copie os cabeçalhos usados no <code>ProtocolCore</code> e crie um <em>Switch on Byte</em> para cada caso importante (chat, ataque, teleporte, trade, loja pessoal). Anote qual interface cada pacote usa para dividir a lógica em gráficos separados.【F:Source MuServer Update 15/GameServer/GameServer/Protocol.cpp†L75-L195】
                    </li>
                    <li>
                        <strong>Defina estados e limites do jogador.</strong>
                        Transforme as <code>enum</code> e constantes de <code>User.h</code> em <code>Enums</code> e <code>Structs</code> Blueprint. Assim você sabe quando um usuário está conectado, quais interfaces ele pode abrir e os limites de dinheiro ou inventário sem revisar o C++ toda hora.【F:Source MuServer Update 15/GameServer/GameServer/User.h†L14-L170】
                </ol>
                <ul class="checklist" aria-label="Checklist da fase 3">
                    <li><input type="checkbox" data-task-id="fase3-connect" /> Subsystem do ConnectServer configurado com mapa de pacotes.</li>
                    <li><input type="checkbox" data-task-id="fase3-respostas" /> Estruturas de resposta replicadas para IP/Porta e lista de mundos.</li>
                    <li><input type="checkbox" data-task-id="fase3-protocol" /> Switch principal do GameServer criado com casos mais usados.</li>
                    <li><input type="checkbox" data-task-id="fase3-userstate" /> Enums e Structs de estados e limites configurados.</li>
                </ul>
            </article>
        </section>

        <section class="module" data-section-id="renderizacao">
            <header>
                <h2>Módulo 3: Gráficos e Renderização</h2>
                <p class="tag">Nível: Intermediário-Avançado</p>
            </header>
            <article class="lesson">
                <h3>Lumen e Nanite</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Tecnologias de iluminação global e geometria virtual da UE5.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Entender os novos pipelines otimiza desempenho e qualidade visual.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Ao montar cenas realistas ou migrar projetos de versões anteriores.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Project Settings &gt; Rendering e detalhes dos Static Meshes.</dd>
                    </div>
                </dl>
                <ul class="checklist" aria-label="Tarefas de renderização">
                    <li><input type="checkbox" data-task-id="renderizacao-lumen-ativar" /> Ativar Lumen e observar o impacto na cena.</li>
                    <li><input type="checkbox" data-task-id="renderizacao-nanite" /> Habilitar Nanite em um mesh pesado.</li>
                    <li><input type="checkbox" data-task-id="renderizacao-perfil" /> Usar <em>Stat GPU</em> para monitorar desempenho.</li>
                </ul>
            </article>
            <article class="lesson">
                <h3>Materiais e pós-processamento</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Criação de materiais PBR, uso de Material Functions e volumes de pós-processamento.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Controlar a estética da cena e comunicar emoções de forma consistente.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Após definir o layout da cena e antes de realizar capturas finais.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Material Editor e Post Process Volume no viewport.</dd>
                    </div>
                </dl>
                <div class="focus-tools">
                    <button type="button" class="focus-toggle" data-target="renderizacao-padroes" data-open-label="Ocultar referência" data-close-label="Referência visual">Referência visual</button>
                    <div id="renderizacao-padroes" class="focus-panel" hidden>
                        <p>Crie uma pasta <em>References</em> com capturas inspiradoras para comparar antes/depois.</p>
                    </div>
                </div>
            </article>
        </section>

        <section class="module" data-section-id="blueprint-pro">
            <header>
                <h2>Módulo 4: Blueprints Avançados e Automação</h2>
                <p class="tag">Nível: Avançado</p>
            </header>
            <article class="lesson">
                <h3>Organizando um projeto Blueprint-first</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Blueprint Function Libraries, Macro Libraries e Blueprint Interfaces para modularizar lógica.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Permite substituir classes C++ legadas por grafos visuais reutilizáveis e fáceis de manter.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Ao planejar sistemas compartilhados (UI Manager, controladores de rede, inventário).</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Editor &gt; Add &gt; Blueprint Script &gt; Blueprint Function Library / Interface.</dd>
                    </div>
                </dl>
                <ul class="checklist" aria-label="Tarefas Blueprints avançados">
                    <li><input type="checkbox" data-task-id="bp-lib-ui" /> Criar uma <em>Blueprint Function Library</em> para carregar e registrar widgets do HUD.</li>
                    <li><input type="checkbox" data-task-id="bp-interface-net" /> Definir uma <em>Blueprint Interface</em> para mensagens de rede (login, personagem, inventário).</li>
                    <li><input type="checkbox" data-task-id="bp-macro-focus" /> Organizar Macro Libraries com rotinas repetitivas (por exemplo, animações de highlight de botões).</li>
                </ul>
            </article>
            <article class="lesson">
                <h3>Diagnóstico e performance com Blueprints</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Blueprint Debugger, <em>Execution Trace</em> e ferramentas de profiler visual.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Ajuda a identificar nós lentos, loops infinitos e replicação excessiva sem alternar para código nativo.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Sempre que um gráfico crescer ou quando portar fluxos complexos do Source Main 5.2 / MuServer.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Janela Blueprint Debugger, Painel <em>Session Frontend</em> &gt; Profiler, comandos <code>stat blueprint</code>.</dd>
                    </div>
                </dl>
            </article>
        </section>

        <section class="module" data-section-id="sistemas-progressao">
            <header>
                <h2>Coleção de Receitas MMORPG – Parte 1: Progressão e Economia</h2>
                <p class="tag">Nível: Avançado</p>
            </header>
            <div class="lesson-grid two-columns">
                <article class="lesson">
                    <h3>Sistema de XP, Level e Reset</h3>
                    <dl>
                        <div>
                            <dt>O quê?</dt>
                            <dd>Blueprints e DataTables que reproduzem níveis, resets e multiplicadores herdados do servidor original.</dd>
                        </div>
                        <div>
                            <dt>Por quê?</dt>
                            <dd>Garante progressão previsível, sincronizada com recompensas e limites utilizados pelo MuServer.</dd>
                        </div>
                        <div>
                            <dt>Quando?</dt>
                            <dd>Após ter o loop básico de combate funcionando e antes de liberar sistemas de ranking ou reset.</dd>
                        </div>
                        <div>
                            <dt>Onde?</dt>
                            <dd>Blueprint GameInstance / ExperienceSubsystem + DataTable “DT_ExperienceCurves”.</dd>
                        </div>
                    </dl>
                    <div class="highlight-callout">
                        <strong>Referência do legado:</strong> Ajuste os multiplicadores e resets seguindo o pipeline de cálculo de experiência mostrado em <code>ObjectManager.cpp</code> e na tabela carregada por <code>ExperienceTable.cpp</code>.【F:Source MuServer Update 15/GameServer/GameServer/ObjectManager.cpp†L1310-L1344】【F:Source MuServer Update 15/GameServer/GameServer/ExperienceTable.cpp†L60-L119】
                    </div>
                    <ol class="step-list">
                        <li>
                            <strong>Estruture a fonte de dados.</strong>
                            Importe o arquivo <code>ExperienceTable.txt</code> para uma DataTable Blueprint e exponha campos para nível, reset e taxas especiais para mapas/contas VIP.
                        </li>
                        <li>
                            <strong>Propague eventos de ganho de XP.</strong>
                            No <code>BP_ExperienceSubsystem</code>, crie um evento <em>OnExperienceGained</em> que recebe dano causado e classe do monstro, calcula multiplicadores e atualiza <em>Attributes</em> do personagem.
                        </li>
                        <li>
                            <strong>Implemente resets e recompensas.</strong>
                            Use um <em>SaveGame</em> ou <em>HTTP Blueprint</em> para registrar resets, resetando nível e atribuindo pontos extras, assim como o servidor faz antes de reaplicar bônus.
                        </li>
                    </ol>
                    <ul class="checklist" aria-label="Checklist de progressão">
                        <li><input type="checkbox" data-task-id="progressao-xp-datatable" /> DataTable de XP importada e validada com valores de reset.</li>
                        <li><input type="checkbox" data-task-id="progressao-xp-event" /> Evento <em>OnExperienceGained</em> disparando para combate solo e em grupo.</li>
                        <li><input type="checkbox" data-task-id="progressao-reset" /> Fluxo de reset registrando recompensas e reaplicando atributos no player state.</li>
                    </ul>
                </article>
                <article class="lesson">
                    <h3>Economia, Shops e Cash Shop</h3>
                    <dl>
                        <div>
                            <dt>O quê?</dt>
                            <dd>Interfaces UMG e subsistemas que replicam lojas NPC, lojinhas pessoais e Cash Shop.</dd>
                        </div>
                        <div>
                            <dt>Por quê?</dt>
                            <dd>Controla entrada e saída de moedas (Zen, WCoin, Goblin Point), mantendo o mesmo equilíbrio do servidor legado.</dd>
                        </div>
                        <div>
                            <dt>Quando?</dt>
                            <dd>Depois de estabilizar inventário e moeda base, antes de ativar eventos sazonais.</dd>
                        </div>
                        <div>
                            <dt>Onde?</dt>
                            <dd>Blueprints <code>BP_ShopManager</code>, <code>BP_CashShopService</code> e Widgets de loja.</dd>
                        </div>
                    </dl>
                    <div class="highlight-callout">
                        <strong>Referência do legado:</strong> Observe como o servidor monta as tabelas de itens em <code>Shop.cpp</code> e pacotes premium em <code>CashShop.cpp</code> para replicar filtros, categorias e moedas específicas no Blueprint.【F:Source MuServer Update 15/GameServer/GameServer/Shop.cpp†L40-L110】【F:Source MuServer Update 15/GameServer/GameServer/CashShop.cpp†L52-L112】
                    </div>
                    <ol class="step-list">
                        <li>
                            <strong>Defina catálogos como DataAssets.</strong>
                            Crie <em>Primary Data Assets</em> por categoria (Armas, Consumíveis, Pacotes) e exponha preço, moeda e requisitos de classe.
                        </li>
                        <li>
                            <strong>Sincronize com o servidor.</strong>
                            Faça um <em>GameInstance Subsystem</em> cuidar das requisições REST/TCP para carregar saldo e compras, emitindo delegates para atualizar UI.
                        </li>
                        <li>
                            <strong>Implemente lojas pessoais.</strong>
                            Monte um <em>Actor Component</em> que registra slots colocados à venda pelo jogador e usa <em>Gameplay Tags</em> para controlar permissões de compra.</li>
                    </ol>
                    <ul class="checklist" aria-label="Checklist de economia">
                        <li><input type="checkbox" data-task-id="economia-dataassets" /> DataAssets de loja preenchidos com preços e filtros.</li>
                        <li><input type="checkbox" data-task-id="economia-sincronizacao" /> Subsystem comunicando saldo do Cash Shop e Zen com o backend.</li>
                        <li><input type="checkbox" data-task-id="economia-loja-pessoal" /> Loja pessoal replicada com permissões e log de transações.</li>
                    </ul>
                </article>
                <article class="lesson">
                    <h3>Sistema de Jewels e melhorias</h3>
                    <dl>
                        <div>
                            <dt>O quê?</dt>
                            <dd>Recipes Blueprint para misturar, consumir e aplicar Jewels na forja (Chaos Machine).</dd>
                        </div>
                        <div>
                            <dt>Por quê?</dt>
                            <dd>Permite upgrades, sockets e bundles como no cliente original, reforçando progressão de item.</dd>
                        </div>
                        <div>
                            <dt>Quando?</dt>
                            <dd>Após validar inventário, antes de liberar eventos que dropam bundles (Blood Castle, Devil Square).</dd>
                        </div>
                        <div>
                            <dt>Onde?</dt>
                            <dd>Blueprint <code>BP_ChaosMachine</code> + Widgets contextuais do Crafting.</dd>
                        </div>
                    </dl>
                    <div class="highlight-callout">
                        <strong>Referência do legado:</strong> Use as validações de quantidade, trava de Chaos e cálculo de custo registradas em <code>JewelMix.cpp</code> ao portar para Blueprint.【F:Source MuServer Update 15/GameServer/GameServer/JewelMix.cpp†L58-L139】
                    </div>
                    <ol class="step-list">
                        <li>
                            <strong>Mapeie combinações válidas.</strong>
                            Crie uma DataTable “DT_JewelRecipes” com tipo, nível e custos Zen dos mixes.
                        </li>
                        <li>
                            <strong>Construa o fluxo da Chaos Machine.</strong>
                            Utilize um <em>Widget Switcher</em> para alternar entre abas (Misturar, Desfazer, Bundle) e um <em>State Machine</em> para travar o inventário durante o mix.
                        </li>
                        <li>
                            <strong>Conecte ao backend.</strong>
                            Registre eventos <em>Server</em>/<em>Client</em> no <code>BP_ChaosMachine</code> para enviar pedidos de mix e aplicar resultados replicados para todos os jogadores próximos.
                        </li>
                    </ol>
                    <ul class="checklist" aria-label="Checklist de jewels">
                        <li><input type="checkbox" data-task-id="jewel-recipes" /> Tabela de receitas criada com validação de estoque.</li>
                        <li><input type="checkbox" data-task-id="jewel-chaos-flow" /> Blueprint da Chaos Machine bloqueando slots durante o processo.</li>
                        <li><input type="checkbox" data-task-id="jewel-replicacao" /> Eventos de mix replicando resultado e broadcast de mensagens.</li>
                    </ul>
                </article>
            </div>
        </section>

        <section class="module" data-section-id="sistemas-mundo">
            <header>
                <h2>Coleção de Receitas MMORPG – Parte 2: Mundo Persistente</h2>
                <p class="tag">Nível: Avançado</p>
            </header>
            <div class="lesson-grid two-columns">
                <article class="lesson">
                    <h3>Geração de Terreno e Biomas</h3>
                    <dl>
                        <div>
                            <dt>O quê?</dt>
                            <dd>Pipeline para importar heightmaps, texturas e atributos de colisão semelhantes ao cliente legado.</dd>
                        </div>
                        <div>
                            <dt>Por quê?</dt>
                            <dd>Reproduz a navegação e a leitura visual clássica (desertos, florestas, calabouços) com fidelidade.</dd>
                        </div>
                        <div>
                            <dt>Quando?</dt>
                            <dd>Antes de posicionar mobs ou portais, logo após definir a topologia do mundo.</dd>
                        </div>
                        <div>
                            <dt>Onde?</dt>
                            <dd>Landscape Mode + Blueprint <code>BP_TerrainComposer</code>.</dd>
                        </div>
                    </dl>
                    <div class="highlight-callout">
                        <strong>Referência do legado:</strong> Observe a decodificação de atributos, camadas e frustums em <code>ZzzLodTerrain.cpp</code> para espelhar colisões e blending de texturas no Landscape UE5.【F:Source Main 5.2/source/ZzzLodTerrain.cpp†L60-L158】
                    </div>
                    <ol class="step-list">
                        <li>
                            <strong>Importe heightmaps criptografados.</strong>
                            Crie um utilitário Blueprint/C++ que leia arquivos originais, aplique <em>BuxConvert</em> e gere arquivos <code>.r16</code> para o Landscape.
                        </li>
                        <li>
                            <strong>Configure camadas dinâmicas.</strong>
                            Use <em>Runtime Virtual Texture</em> para misturar materiais (grama, areia, gelo) com base em curvas de inclinação.</li>
                        <li>
                            <strong>Gere colisões e volumes.</strong>
                            Sincronize <em>LandscapeLayerInfo</em> com volumes de bloqueio iguais aos atributos <code>TerrainWall</code> do cliente.
                        </li>
                    </ol>
                    <ul class="checklist" aria-label="Checklist de terreno">
                        <li><input type="checkbox" data-task-id="terreno-heightmap" /> Heightmaps e máscaras importados para Landscape.</li>
                        <li><input type="checkbox" data-task-id="terreno-material" /> Materiais com RVT configurados para múltiplos biomas.</li>
                        <li><input type="checkbox" data-task-id="terreno-colisao" /> Volumes de colisão espelhando atributos do cliente.</li>
                    </ul>
                </article>
                <article class="lesson">
                    <h3>Portais, Gates e Mudança de Mapas</h3>
                    <dl>
                        <div>
                            <dt>O quê?</dt>
                            <dd>Sistema de portais e comandos de teleporte sincronizados entre mapas, incluindo checagens de acesso.</dd>
                        </div>
                        <div>
                            <dt>Por quê?</dt>
                            <dd>Garante transições seguras entre mundos, eventos instanciados e arenas.</dd>
                        </div>
                        <div>
                            <dt>Quando?</dt>
                            <dd>Após definir terreno e antes de popular com NPCs ou mobs.</dd>
                        </div>
                        <div>
                            <dt>Onde?</dt>
                            <dd>DataAsset <code>DA_GateNetwork</code> + <code>BP_GateController</code>.</dd>
                        </div>
                    </dl>
                    <div class="highlight-callout">
                        <strong>Referência do legado:</strong> Reproduza o cadastro de servidores/mapas e as validações de teleporte documentadas em <code>MapServerManager.cpp</code> e <code>Move.cpp</code>.【F:Source MuServer Update 15/GameServer/GameServer/MapServerManager.cpp†L70-L139】【F:Source MuServer Update 15/GameServer/GameServer/Move.cpp†L205-L318】
                    </div>
                    <ol class="step-list">
                        <li>
                            <strong>Cadastre o grafo de mapas.</strong>
                            Monte um DataAsset com destinos, custo em Zen e restrições (Gens, PK, evento ativo).
                        </li>
                        <li>
                            <strong>Implemente validações.</strong>
                            No <code>BP_GateController</code>, converta verificações em branches Blueprint antes de disparar <em>Server Travel</em> ou <em>ClientTravel</em>.
                        </li>
                        <li>
                            <strong>Atualize estados pós-teleporte.</strong>
                            Garanta que <em>Player State</em> e <em>HUD</em> reinicializem buffs, objetivos e âncoras ao chegar ao mapa alvo.
                        </li>
                    </ol>
                    <ul class="checklist" aria-label="Checklist de gates">
                        <li><input type="checkbox" data-task-id="gate-grafo" /> DataAsset com rede de portais e requisitos preenchidos.</li>
                        <li><input type="checkbox" data-task-id="gate-validacao" /> Blueprint verificando permissões antes da viagem.</li>
                        <li><input type="checkbox" data-task-id="gate-estado" /> Atualização de estados/HUD após troca de mapa.</li>
                    </ul>
                </article>
                <article class="lesson">
                    <h3>IA de Mobs e patrulhamento</h3>
                    <dl>
                        <div>
                            <dt>O quê?</dt>
                            <dd>Behaviour Trees que replicam rotinas, emoções e alvos do AI legado.</dd>
                        </div>
                        <div>
                            <dt>Por quê?</dt>
                            <dd>Permite agressividade, perseguição e efeitos de status coerentes com o gameplay clássico.</dd>
                        </div>
                        <div>
                            <dt>Quando?</dt>
                            <dd>Após preparar terreno e gates, antes de balancear drops.</dd>
                        </div>
                        <div>
                            <dt>Onde?</dt>
                            <dd>Behaviour Tree + <code>BP_MonsterController</code>.</dd>
                        </div>
                    </dl>
                    <div class="highlight-callout">
                        <strong>Referência do legado:</strong> Converta emoções, patrulhas e ataques reativos descritos em <code>MonsterAI.cpp</code> em <em>State Machines</em> e tasks Blueprint.【F:Source MuServer Update 15/GameServer/GameServer/MonsterAI.cpp†L120-L220】
                    </div>
                    <ol class="step-list">
                        <li>
                            <strong>Modele estados principais.</strong>
                            Configure nós (Patrulha, Perseguição, Ataque, Retirada) usando <em>Blackboard Keys</em> equivalentes às emoções do C++.</li>
                        <li>
                            <strong>Calcule caminhos.</strong>
                            Sincronize <code>PathCur</code>/<code>PathCount</code> com <em>EQSTestingPawn</em> ou malhas de navegação dinâmicas.</li>
                        <li>
                            <strong>Integre efeitos.</strong>
                            Encapsule chamadas ao <em>Effect Manager</em> para aplicar veneno, empurrões e buffs temporários.
                        </li>
                    </ol>
                    <ul class="checklist" aria-label="Checklist de IA">
                        <li><input type="checkbox" data-task-id="ia-estados" /> Behaviour Tree com estados equivalentes às emoções do legado.</li>
                        <li><input type="checkbox" data-task-id="ia-caminho" /> Sistema de patrulha usando splines ou EQS para hotspots.</li>
                        <li><input type="checkbox" data-task-id="ia-efeitos" /> Aplicação de efeitos replicados via <code>BP_EffectManager</code>.</li>
                    </ul>
                </article>
                <article class="lesson">
                    <h3>Drops e eventos dinâmicos</h3>
                    <dl>
                        <div>
                            <dt>O quê?</dt>
                            <dd>Sistema de loot que respeita taxas por mapa, nível e evento.</dd>
                        </div>
                        <div>
                            <dt>Por quê?</dt>
                            <dd>Controla progressão de itens raros e mantém raridade de Jewels e excelentes.</dd>
                        </div>
                        <div>
                            <dt>Quando?</dt>
                            <dd>Após definir IA e balancear economia.</dd>
                        </div>
                        <div>
                            <dt>Onde?</dt>
                            <dd>Componentes <code>BP_LootTable</code> anexados a mobs e bosses.</dd>
                        </div>
                    </dl>
                    <div class="highlight-callout">
                        <strong>Referência do legado:</strong> Respeite filtros de mapa, nível e opções extras conforme <code>ItemDrop.cpp</code> aplica ao sortear itens e opções.【F:Source MuServer Update 15/GameServer/GameServer/ItemDrop.cpp†L120-L209】
                    </div>
                    <ol class="step-list">
                        <li>
                            <strong>Cadastre tabelas de loot.</strong>
                            Crie DataTables com pesos por evento/mapa e configure <em>Curve Tables</em> para probabilidades.</li>
                        <li>
                            <strong>Implemente seleção ponderada.</strong>
                            Utilize <code>Select Weighted</code> em Blueprint para simular o <code>RandomManager</code> do legado.
                        </li>
                        <li>
                            <strong>Replicação e feedback.</strong>
                            Gere atores de item com <em>Multicast</em> e sincronize o tempo de desaparecimento conforme raridade.
                        </li>
                    </ol>
                    <ul class="checklist" aria-label="Checklist de drops">
                        <li><input type="checkbox" data-task-id="drop-tabelas" /> Tabelas de loot configuradas com pesos por mapa.</li>
                        <li><input type="checkbox" data-task-id="drop-blueprint" /> Função Blueprint que seleciona recompensas ponderadas.</li>
                        <li><input type="checkbox" data-task-id="drop-replicacao" /> Broadcast de drops e timers replicados para todos os jogadores.</li>
                    </ul>
                </article>
            </div>
        </section>

        <section class="module" data-section-id="sistemas-combate">
            <header>
                <h2>Coleção de Receitas MMORPG – Parte 3: Combate, Skills e Animações</h2>
                <p class="tag">Nível: Avançado</p>
            </header>
            <div class="lesson-grid two-columns">
                <article class="lesson">
                    <h3>Loop de ataque do personagem</h3>
                    <dl>
                        <div>
                            <dt>O quê?</dt>
                            <dd>Blueprints para processar ataques básicos, consumo de projéteis e atualização de atributos.</dd>
                        </div>
                        <div>
                            <dt>Por quê?</dt>
                            <dd>Reproduz travas de alvo, gasto de flechas e resets de regeneração vistos no cliente original.</dd>
                        </div>
                        <div>
                            <dt>Quando?</dt>
                            <dd>Após configurar armas, antes de balancear skills.</dd>
                        </div>
                        <div>
                            <dt>Onde?</dt>
                            <dd><code>BP_CombatComponent</code> anexado ao personagem.</dd>
                        </div>
                    </dl>
                    <div class="highlight-callout">
                        <strong>Referência do legado:</strong> Inspire-se nas validações de alvo, gasto de flechas e timers de regeneração descritos em <code>Attack.cpp</code>.【F:Source MuServer Update 15/GameServer/GameServer/Attack.cpp†L180-L279】
                    </div>
                    <ol class="step-list">
                        <li>
                            <strong>Cheque alvos elegíveis.</strong>
                            Use <em>Gameplay Tags</em> e <em>Trace Channels</em> para impedir ataques contra summons aliados.</li>
                        <li>
                            <strong>Atualize timers.</strong>
                            Reinicie contadores de regeneração (HP/MP/SD) ao confirmar golpes, imitando o comportamento legado.
                        </li>
                        <li>
                            <strong>Sincronize com efeitos de impacto.</strong>
                            Dispare <em>Anim Notifies</em> para spawnar partículas e aplicar dano via <em>Server RPC</em> com rollback seguro.
                        </li>
                    </ol>
                    <ul class="checklist" aria-label="Checklist de ataque">
                        <li><input type="checkbox" data-task-id="combate-validacao" /> Função de validação de alvo evitando aliados e summons.</li>
                        <li><input type="checkbox" data-task-id="combate-timers" /> Timers de regeneração reiniciados ao atacar/ser atingido.</li>
                        <li><input type="checkbox" data-task-id="combate-notifies" /> Anim Notifies conectados a danos e partículas.</li>
                    </ul>
                </article>
                <article class="lesson">
                    <h3>Skills, árvores e atributos</h3>
                    <dl>
                        <div>
                            <dt>O quê?</dt>
                            <dd>Sistema de habilidades ativo/passivo com suporte a master level.</dd>
                        </div>
                        <div>
                            <dt>Por quê?</dt>
                            <dd>Permite combos, buffs e summons idênticos aos livros originais.</dd>
                        </div>
                        <div>
                            <dt>Quando?</dt>
                            <dd>Depois do ataque básico e antes de desbloquear eventos PvP.</dd>
                        </div>
                        <div>
                            <dt>Onde?</dt>
                            <dd><code>Gameplay Ability System</code> ou Blueprint equivalente.</dd>
                        </div>
                    </dl>
                    <div class="highlight-callout">
                        <strong>Referência do legado:</strong> Utilize os mapeamentos de livros e efeitos descritos em <code>SkillManager.cpp</code> para montar DataTables de habilidades e curvas de poder.【F:Source MuServer Update 15/GameServer/GameServer/SkillManager.cpp†L200-L320】
                    </div>
                    <ol class="step-list">
                        <li>
                            <strong>Mapeie habilidades.</strong>
                            Cadastre cada livro/skill em DataTable com IDs e requisitos de classe/master level.</li>
                        <li>
                            <strong>Implemente GAS ou Equivalent.</strong>
                            Configure <em>Gameplay Abilities</em> com custos de mana/bp e cooldowns sincronizados com o servidor.</li>
                        <li>
                            <strong>Construa a árvore master.</strong>
                            Use <em>Ability Trees</em> ou grafos de nós para desbloquear skills progressivas conforme resets/master level.
                        </li>
                    </ol>
                    <ul class="checklist" aria-label="Checklist de skills">
                        <li><input type="checkbox" data-task-id="skill-tabela" /> DataTable de skills preenchida com requisitos.</li>
                        <li><input type="checkbox" data-task-id="skill-abilities" /> Abilities configuradas com custos e cooldown replicado.</li>
                        <li><input type="checkbox" data-task-id="skill-arvore" /> Árvore de master level navegável e salva no backend.</li>
                    </ul>
                </article>
                <article class="lesson">
                    <h3>Ofensiva dos mobs</h3>
                    <dl>
                        <div>
                            <dt>O quê?</dt>
                            <dd>Rotinas de ataque corpo a corpo e ranged para criaturas, incluindo penalidades e bônus.</dd>
                        </div>
                        <div>
                            <dt>Por quê?</dt>
                            <dd>Balanceia dano, status negativos e respostas a eventos como Crywolf ou Castle Siege.</dd>
                        </div>
                        <div>
                            <dt>Quando?</dt>
                            <dd>Depois de configurar IA básica e antes de calibrar drops raros.</dd>
                        </div>
                        <div>
                            <dt>Onde?</dt>
                            <dd>Tasks do Behaviour Tree + <code>BP_MonsterCombatComponent</code>.</dd>
                        </div>
                    </dl>
                    <div class="highlight-callout">
                        <strong>Referência do legado:</strong> Copie regras de penalidades e bônus usados nos cálculos de dano e experiência do servidor para manter consistência com eventos globais.【F:Source MuServer Update 15/GameServer/GameServer/ObjectManager.cpp†L1310-L1354】
                    </div>
                    <ol class="step-list">
                        <li>
                            <strong>Sincronize penalidades globais.</strong>
                            Leia estados (Crywolf, Castle Siege) do servidor e ajuste dano/XP antes de aplicar ao jogador.</li>
                        <li>
                            <strong>Implemente ataques especiais.</strong>
                            Use <em>Montages</em> e <em>Anim Notifies</em> para disparar venenos, empurrões ou buffs temporários.</li>
                        <li>
                            <strong>Feedback visual.</strong>
                            Adicione partículas e decalques atrelados aos mesmos notifies para reforçar leitura do combate.</li>
                    </ol>
                    <ul class="checklist" aria-label="Checklist ofensiva de mobs">
                        <li><input type="checkbox" data-task-id="mob-penalidades" /> Penalidades globais integradas ao cálculo de dano.</li>
                        <li><input type="checkbox" data-task-id="mob-especiais" /> Ataques especiais configurados com montages e efeitos.</li>
                        <li><input type="checkbox" data-task-id="mob-feedback" /> Feedback visual replicado para todos os clientes.</li>
                    </ul>
                </article>
                <article class="lesson">
                    <h3>Animações, efeitos e mudança visual</h3>
                    <dl>
                        <div>
                            <dt>O quê?</dt>
                            <dd>Pipeline para sincronizar animações de personagens e mobs, incluindo troca visual ao equipar itens.</dd>
                        </div>
                        <div>
                            <dt>Por quê?</dt>
                            <dd>Mantém feedback imediato ao equipar itens, aplicar buffs ou receber debuffs.</dd>
                        </div>
                        <div>
                            <dt>Quando?</dt>
                            <dd>Após finalizar combate e skills.</dd>
                        </div>
                        <div>
                            <dt>Onde?</dt>
                            <dd>Animation Blueprints + <code>BP_EquipmentVisualizer</code>.</dd>
                        </div>
                    </dl>
                    <div class="highlight-callout">
                        <strong>Referência do legado:</strong> Aproveite o gerenciamento de ossos e busca por sockets em <code>BoneManager.cpp</code> e relacione com efeitos carregados via <code>EffectManager.cpp</code> para equipar itens e aplicar buffs.【F:Source Main 5.2/source/BoneManager.cpp†L120-L158】【F:Source MuServer Update 15/GameServer/GameServer/EffectManager.cpp†L80-L154】
                    </div>
                    <ol class="step-list">
                        <li>
                            <strong>Mapeie sockets e bones.</strong>
                            Crie tabelas de mapeamento (Bone → Item Slot) e use <em>Anim Notifies</em> para anexar meshes extras.</li>
                        <li>
                            <strong>Atualize malhas dinamicamente.</strong>
                            Use <em>Modular Character</em> ou <em>Gameplay Tags</em> para alternar peças ao equipar/unequipar.
                        </li>
                        <li>
                            <strong>Sincronize efeitos visuais.</strong>
                            Vincule buffs/debuffs a um <code>BP_EffectManager</code> que instancia partículas e materiais dinâmicos.</li>
                    </ol>
                    <ul class="checklist" aria-label="Checklist de animações">
                        <li><input type="checkbox" data-task-id="anim-sockets" /> Mapa de sockets configurado para personagens e mobs.</li>
                        <li><input type="checkbox" data-task-id="anim-modular" /> Troca de peças/skins funcionando ao equipar item.</li>
                        <li><input type="checkbox" data-task-id="anim-efeitos" /> Buffs e efeitos aplicados por um gerenciador comum.</li>
                    </ul>
                </article>
            </div>
        </section>

        <section class="module reference-module" data-section-id="guia-itens">
            <header>
                <h2>Guia Integrado do Sistema de Itens</h2>
                <p class="tag">Referência Detalhada</p>
            </header>
            <article class="lesson">
                <h3>Resumo rápido</h3>
                <p>O guia completo de itens foi incorporado ao diretório <code>ProjetoUnrealEngine/guides/</code>. Ele explica inventário, drag &amp; drop, pets, efeitos visuais e mudança de aparência ao equipar itens.</p>
                <div class="highlight-callout">
                    <strong>Dica:</strong> Use este resumo para alinhar-se rapidamente e abra o guia completo para fluxos passo a passo, capturas e listas de verificação adicionais.
                </div>
                <ul class="module-list" aria-label="Tópicos cobertos no guia de itens">
                    <li>Inventário e HUD replicados, inclusive troca visual de slots.</li>
                    <li>Equipamento, pets e efeitos especiais por raridade.</li>
                    <li>Sistema de Armazenamento (Vault), Cash Shop e integração com drops.</li>
                </ul>
                <div class="reference-links">
                    <a class="guide-button" href="guides/unreal_item_system_guide.html" target="_blank" rel="noopener">Abrir guia completo</a>
                </div>
            </article>
        </section>
        <section class="module" data-section-id="fluxo-trabalho">
            <header>
                <h2>Módulo 5: Fluxo de Trabalho e Rotina de Estudo</h2>
                <p class="tag">Nível: Metacognição</p>
            </header>
            <article class="lesson">
                <h3>Organização para TDAH</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Estratégias de foco, blocos temporais e revisão espaçada.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Auxilia no armazenamento de longo prazo e evita frustração.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Todos os dias de estudo, antes de iniciar tarefas técnicas.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Agenda digital, aplicativos de Pomodoro ou planilhas.</dd>
                    </div>
                </dl>
                <div class="focus-tools">
                    <button type="button" class="focus-toggle" data-target="fluxo-roteiro-diario" data-open-label="Ocultar roteiro" data-close-label="Roteiro diário sugerido">Roteiro diário sugerido</button>
                    <div id="fluxo-roteiro-diario" class="focus-panel" hidden>
                        <ol>
                            <li>5 min — Revisão dos objetivos e das tarefas marcadas.</li>
                            <li>25 min — Estudo focado em um tópico do módulo atual.</li>
                            <li>5 min — Pausa ativa ou respiração.</li>
                            <li>10 min — Resumo em voz alta ou escrita do que aprendeu.</li>
                        </ol>
                    </div>
                </div>
            </article>
            <article class="lesson">
                <h3>Próximos passos e comunidade</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Participar de comunidades, eventos oficiais e documentar projetos.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Networking acelera feedback e oportunidades profissionais.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Após concluir cada módulo, compartilhe uma pequena demo ou devlog.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Fóruns da Unreal, Discords dedicados, itch.io, ArtStation.</dd>
                    </div>
                </dl>
            </article>
        </section>

        <section class="module special-project" data-section-id="muonline-migracao">
            <header>
                <h2>Projeto Especial: Replicando Mu Online na UE5</h2>
                <p class="tag">Estudo de Caso</p>
            </header>
            <article class="lesson">
                <h3>Mapeando o cliente original (Source Main 5.2)</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Analisar a UI e os sistemas de jogo legados, como o <code>CNewUIMainFrameWindow</code> que carrega bitmaps e organiza botões do HUD clássico.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Identificar quais elementos precisam virar Widgets/Blueprints na UE5, mantendo feedback visual e fluxos originais.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Antes de recriar telas ou importar assets: faça um inventário do que será reimplementado e o que pode ser modernizado.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd><code>Source Main 5.2/source</code>, com destaque para arquivos de UI e gerenciamento de personagens.</dd>
                    </div>
                </dl>
                <div class="focus-tools">
                    <button type="button" class="focus-toggle" data-target="muonline-main-sistemas" data-open-label="Ocultar sistemas" data-close-label="Ver sistemas críticos">Ver sistemas críticos</button>
                    <div id="muonline-main-sistemas" class="focus-panel" hidden>
                        <ul>
                            <li><strong>Interface principal:</strong> <code>NewUIMainFrameWindow.cpp</code> importa bitmaps da pasta <code>Interface\</code> e registra botões no gerenciador de UI.</li>
                            <li><strong>Classes e atributos:</strong> <code>CharacterManager.cpp</code> traduz códigos do servidor para classes jogáveis e textos exibidos.</li>
                        </ul>
                    </div>
                </div>
                <ul class="checklist" aria-label="Primeiros passos do cliente legado">
                    <li><input type="checkbox" data-task-id="muonline-cliente-mapas-ui" /> Documentar cada HUD/Janela necessária para recriar em UMG (menus, inventário, chat, eventos).</li>
                    <li><input type="checkbox" data-task-id="muonline-cliente-assets" /> Criar planilha de assets 2D/3D a serem substituídos ou atualizados, incluindo referência a texturas <code>Interface\*.jpg</code>.</li>
                    <li><input type="checkbox" data-task-id="muonline-cliente-fluxos" /> Descrever fluxos críticos (login, seleção de personagem, combates) para orientar Blueprints de estados.</li>
                </ul>
            </article>
            <article class="lesson">
                <h3>Mapeando os servidores (Source MuServer Update 15)</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Entender os serviços Win32 responsáveis por login, dados e lógica (GameServer, ConnectServer, DataServer, etc.).</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Definir como portar protocolos de rede e lógica de progressão para subsistemas e serviços na UE5 ou back-end moderno.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Após mapear o cliente, para alinhar contratos cliente-servidor e priorizar funcionalidades multiplayer.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd><code>Source MuServer Update 15/</code>, especialmente <code>GameServer/GameServer</code> e <code>ConnectServer/ConnectServer</code>.</dd>
                    </div>
                </dl>
                <div class="focus-tools">
                    <button type="button" class="focus-toggle" data-target="muonline-server-pipeline" data-open-label="Ocultar pipeline" data-close-label="Pipeline legado">Pipeline legado</button>
                    <div id="muonline-server-pipeline" class="focus-panel" hidden>
                        <ul>
                            <li><strong>GameServer:</strong> inicializa conexões com Join/Data Server, popula tabelas de experiência e monstros.</li>
                            <li><strong>ConnectServer:</strong> lê configurações <code>.ini</code>, levanta sockets TCP/UDP e gerencia lista de mundos.</li>
                        </ul>
                    </div>
                </div>
                <ul class="checklist" aria-label="Primeiros passos dos servidores legados">
                    <li><input type="checkbox" data-task-id="muonline-servidor-diagrama" /> Diagramar a arquitetura cliente ⇄ ConnectServer ⇄ GameServer ⇄ DataServer.</li>
                    <li><input type="checkbox" data-task-id="muonline-servidor-protocolos" /> Levantar mensagens e estruturas de rede críticas (login, seleção de personagem, eventos).</li>
                    <li><input type="checkbox" data-task-id="muonline-servidor-modernizacao" /> Definir se a lógica ficará em Blueprints dedicados dentro da UE5 (GameInstance/Subsystems) ou se usará serviços externos acessados via nós HTTP/TCP.</li>
                </ul>
            </article>
            <article class="lesson">
                <h3>Primeiros passos para a réplica na UE5</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Criar um projeto modular na UE5 que isola UI (UMG), gameplay em Blueprints e integração de rede visual.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Permite iterar substituindo sistemas legados sem perder o foco e mantendo paridade funcional com o original.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Depois que o escopo do cliente e servidor estiver documentado, antes de implementar features complexas.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Use um projeto UE5 baseado em <em>Third Person</em> ou <em>Top Down</em>, estruturando pastas <code>Content/UI</code>, <code>Content/Game</code> e <code>Source/</code>.</dd>
                    </div>
                </dl>
                <ul class="checklist" aria-label="Kick-off do projeto UE5">
                    <li><input type="checkbox" data-task-id="muonline-ue5-projeto" /> Criar projeto UE5 com módulos separados para UI e lógica (ex.: <code>MuClient</code> e <code>MuCore</code>).</li>
                    <li><input type="checkbox" data-task-id="muonline-ue5-widget" /> Prototipar um Widget UMG do HUD principal para validar escalas e fontes.</li>
                    <li><input type="checkbox" data-task-id="muonline-ue5-rede" /> Testar comunicação básica com servidor (HTTP/Socket) simulando fluxo de login.</li>
                </ul>
            </article>
            <article class="lesson">
                <h3>Recriando o lado servidor dentro da Unreal</h3>
                <dl>
                    <div>
                        <dt>O quê?</dt>
                        <dd>Estruturar um servidor dedicado UE5 (ou serviço externo) que reproduza os papéis do GameServer, ConnectServer e DataServer originais.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Permite validar protocolos, persistência e regras de progressão sem depender do código Win32 legado, facilitando testes rápidos com o cliente UE5.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Após ter o projeto base organizado e os contratos de mensagens mapeados, antes de migrar eventos complexos ou temporadas.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Blueprints em <code>Content/Blueprints/Server</code>, <code>GameInstance</code> e <code>GameMode</code> dedicados, além de plugins Blueprint-friendly para dados e rede.</dd>
                    </div>
                </dl>
                <div class="focus-tools">
                    <button type="button" class="focus-toggle" data-target="muonline-ue5-servidor-tarefas" data-open-label="Ocultar passos" data-close-label="Passos de migração">Passos de migração</button>
                    <div id="muonline-ue5-servidor-tarefas" class="focus-panel" hidden>
                        <ul>
                            <li><strong>Target dedicado:</strong> Ative <em>Run Dedicated Server</em> no <strong>Editor Preferences &gt; Level Editor &gt; Play</strong> e configure <em>Packaging &gt; Build Target: Dedicated Server</em> para builds Blueprint-only.</li>
                            <li><strong>Protocolos:</strong> Converta <code>Protocol.h</code> legados em <code>DataAssets</code>/<code>DataTables</code> e <code>USTRUCT</code> expostos a Blueprints para alimentar nós <em>Switch on Enum</em>.</li>
                            <li><strong>Persistência:</strong> Utilize <code>GameInstanceSubsystem</code> Blueprint ou plugins (VaRest, EOS) para abstrair chamadas ao banco (REST, gRPC ou sockets).</li>
                        </ul>
                    </div>
                </div>
                <ul class="checklist" aria-label="Serviço servidor UE5">
                    <li><input type="checkbox" data-task-id="muonline-ue5-servidor-target" /> Ajustar o <code>.uproject</code> para builds dedicadas via <em>Project Settings &gt; Packaging</em> e validar o modo servidor com <em>Play As Client/Server</em>.</li>
                    <li><input type="checkbox" data-task-id="muonline-ue5-servidor-handlers" /> Implementar handlers de login e seleção de personagem usando Blueprints (GameInstance, GameMode e PlayerController dedicados).</li>
                    <li><input type="checkbox" data-task-id="muonline-ue5-servidor-persistencia" /> Conectar o servidor Blueprint a dados (REST, arquivo local, DataTable) espelhando contas, personagens e inventário.</li>
                    <li><input type="checkbox" data-task-id="muonline-ue5-servidor-testes" /> Simular múltiplos clientes usando <em>PIE</em> ou builds headless para validar sessões, latência e desconexões.</li>
                </ul>
            </article>
        </section>

        <section class="module recipe-book" data-section-id="muonline-receitas">
            <header>
                <h2>Receitas de Bolo: Remake Cliente &amp; Servidor</h2>
                <p class="tag">Passo a passo prático</p>
                <p>Use estas receitas como scripts rápidos para iniciar implementações críticas. Cada uma segue o formato <strong>O quê</strong>, <strong>Por quê</strong>, <strong>Quando</strong>, <strong>Onde</strong> e detalha ingredientes, modo de preparo e verificações finais.</p>
            </header>

            <article class="recipe">
                <h3>Receita do Cliente UE5 — HUD e Fluxo de Login</h3>
                <dl class="recipe-brief">
                    <div>
                        <dt>O quê?</dt>
                        <dd>Recriar a interface principal do Mu Online (HUD, login, seleção de personagem) usando UMG e Blueprints.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Garantir familiaridade para veteranos e estabelecer base para testes com o servidor UE5.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Após mapear telas legadas no roadmap e antes de portar combates ou eventos dinâmicos.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd>Projeto UE5 &gt; <code>Content/UI</code>, <code>Content/HUD</code> e <code>Content/Blueprints/Flow</code>.</dd>
                    </div>
                </dl>

                <div class="recipe-section">
                    <h4>Ingredientes (Pré-requisitos)</h4>
                    <ul>
                        <li>Levantamento das classes UIs originais em <code>source/NewUIMainFrameWindow.cpp</code> e <code>source/NewUISystem.cpp</code> (ex.: <code>SEASON3B::CNewUIMainFrameWindow::Create</code> e registro via <code>CNewUIManager::AddUIObj</code>). </li>
                        <li>Referência dos botões, barras e binds definidos em <code>SEASON3B::CNewUIMainFrameWindow::Render*</code> e <code>BtnProcess()</code> no Source Main 5.2.</li>
                        <li>Eventos de chat, party e inventário localizados em <code>source/NewUIChatInputBox.cpp</code>, <code>NewUIPartyInfoWindow.cpp</code> e <code>NewUIMyInventory.cpp</code>.</li>
                        <li>Fluxo de login/lista de personagens observado no servidor em <code>GameServer/GameServer/Protocol.cpp</code> (<code>CGConnectAccountRecv</code>, <code>CGCharacterListRecv</code>) para alinhar mensagens.</li>
                    </ul>
                </div>

                <div class="recipe-section">
                    <h4>Modo de preparo</h4>
                    <ol class="recipe-steps">
                        <li>
                            <h5>Pré-aqueça com o inventário do legado</h5>
                            <p>Analise <code>SEASON3B::CNewUIMainFrameWindow::LoadImages</code> e <code>RenderFrame</code> para listar texturas, barras e hotkeys utilizados. No UE5, crie uma tabela de dados (DataTable) listando esses mesmos elementos para alimentar widgets UMG e um <code>BP_MuAssetRegistry</code>.</p>
                        </li>
                        <li>
                            <h5>Prepare os widgets espelhando o manager legado</h5>
                            <p>Para cada chamada <code>m_pNewUIMng-&gt;AddUIObj(...)</code> encontrada em arquivos como <code>NewUIMainFrameWindow.cpp</code>, <code>NewUIChatInputBox.cpp</code> e <code>NewUIPartyInfoWindow.cpp</code>, crie um widget UMG equivalente (por exemplo <code>WBP_MainHUD</code>, <code>WBP_ChatInput</code>, <code>WBP_PartyPanel</code>). Use um Blueprint <code>BP_MuUIManager</code> para registrar e carregar dinamicamente esses widgets, replicando as prioridades (<em>LayerDepth</em>) vistas nos métodos <code>GetLayerDepth()</code>.</p>
                        </li>
                        <li>
                            <h5>Tempere com interações e atalhos</h5>
                            <p>Recrie nos Blueprints os comportamentos de <code>UpdateMouseEvent</code>, <code>UpdateKeyEvent</code> e <code>BtnProcess()</code> (ex.: clique nos botões de inventário e atalhos numéricos) usando <em>Input Mapping Contexts</em> e <code>Enhanced Input</code>. Cada função deve despachar eventos equivalentes às chamadas C++ (por exemplo abrir <code>WBP_Inventory</code> quando o botão definido em <code>RenderButtons()</code> é acionado).</p>
                        </li>
                        <li>
                            <h5>Finalize alinhando a troca de mensagens</h5>
                            <p>Monte em Blueprints um <code>BP_MuLoginController</code> (PlayerController ou Widget Controller) que envie e consuma eventos equivalentes aos pacotes manipulados em <code>CGConnectAccountRecv</code>, <code>CGCharacterListRecv</code> e às respostas <code>GCConnectAccountSend</code>. Garanta que o widget de seleção de personagem escute a lista produzida no servidor (estrutura usada em <code>DGCharacterListRecv</code>) por meio de <em>Event Dispatchers</em> e <em>DataTables</em>.</p>
                        </li>
                    </ol>
                </div>

                <div class="recipe-section blueprint-guide">
                    <h4>Sequência guiada no Blueprint</h4>
                    <ol class="blueprint-flow">
                        <li>
                            <h5>BP_MuAssetRegistry (Event BeginPlay)</h5>
                            <p>
                                Use <strong>Event BeginPlay</strong> → <strong>Get Data Table Row Names</strong> → <strong>For Each Loop</strong> para carregar cada linha da tabela que espelha
                                <code>LoadImages</code> e <code>SetButtonInfo</code>. Preencha um <code>Struct</code> com as mesmas referências de textura e tooltips usadas nos IDs <code>IMAGE_MENU_*</code> e
                                chame <strong>Add to Set</strong> para manter o mapeamento antes de sinalizar o <code>BP_MuUIManager</code> com <em>Dispatch Event</em> “AssetsProntos”.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L59-L160】
                            </p>
                        </li>
                        <li>
                            <h5>BP_MuUIManager (Event AssetsProntos)</h5>
                            <p>
                                Dentro de <strong>Event AssetsProntos</strong>, execute <strong>For Each</strong> no DataTable “WidgetsRegistrados” e, para cada linha, faça <strong>Create Widget</strong> → <strong>Add to Viewport</strong>,
                                definindo <strong>Set ZOrder</strong> conforme o campo “LayerDepth” do DataTable. Esse fluxo substitui as chamadas <code>AddUIObj</code> e garante a mesma pilha de interface do manager legado.【F:Source Main 5.2/source/NewUIManager.cpp†L23-L45】
                            </p>
                        </li>
                        <li>
                            <h5>WBP_MainHUD (Event Tick)</h5>
                            <p>
                                Conecte <strong>Event Tick</strong> → <strong>Get Player Character</strong> → <strong>Cast To BP_MuCharacter</strong> → <strong>Get Current Life/Mana</strong> e ajuste barras com <strong>Set Percent</strong>.
                                Reproduza o alerta sonoro configurando um <strong>Branch</strong> que dispara <strong>Play Sound 2D</strong> quando a porcentagem ficar abaixo de 20%, imitando a verificação de <code>RenderLifeMana</code>.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L241-L310】
                            </p>
                        </li>
                        <li>
                            <h5>BP_InteractionRouter (Eventos de clique)</h5>
                            <p>
                                Crie uma <strong>Blueprint Interface</strong> “BPI_MuButton” com evento “HandleClick”. Nos botões WBP, chame <strong>Interface Call</strong> ao clicar e deixe o router decidir
                                qual painel abrir com <strong>Switch on Name</strong>. Esse fluxo reproduz o comportamento condicional de <code>BtnProcess</code>, incluindo o bloqueio de party para níveis baixos.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L763-L816】
                            </p>
                        </li>
                    </ol>
                </div>

                <div class="recipe-section blueprint-translation">
                    <h4>Tradução do C++ → nós Blueprints</h4>
                    <dl class="translation-pairs">
                        <div>
                            <dt><code>LoadBitmap</code> / <code>LoadImages</code></dt>
                            <dd><strong>Blueprint:</strong> DataTable + <em>Set Brush From Texture</em> no widget após <strong>Preload Assets</strong>, mantendo os mesmos arquivos definidos no código legado.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L59-L77】</dd>
                        </div>
                        <div>
                            <dt><code>AddUIObj</code> (UI Manager)</dt>
                            <dd><strong>Blueprint:</strong> <em>Create Widget</em> + <em>Add to Viewport</em> com controle de ordem via <em>Set ZOrder</em>, alimentado pelos dados de camada do DataTable.【F:Source Main 5.2/source/NewUIManager.cpp†L23-L41】</dd>
                        </div>
                        <div>
                            <dt><code>RenderLifeMana</code></dt>
                            <dd><strong>Blueprint:</strong> <em>Event Tick</em> → <em>Get Attribute</em> → <em>Normalize To Range</em> → <em>Set Percent</em> / <em>Set Text</em>, tocando áudio com <em>Play Sound 2D</em> quando a porcentagem cair abaixo de 0,2.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L241-L305】</dd>
                        </div>
                        <div>
                            <dt><code>BtnProcess</code></dt>
                            <dd><strong>Blueprint:</strong> <em>OnClicked</em> → <em>Switch on Name</em> / <em>Switch on Enum</em> → chamadas para <em>Toggle Visibility</em> dos widgets correspondentes, além de <em>Play Sound 2D</em> para o feedback auditivo.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L763-L815】</dd>
                        </div>
                    </dl>
                </div>

                <div class="recipe-section">
                    <h4>Checklist final</h4>
                    <ul class="checklist" aria-label="Checklist receita cliente UE5">
                        <li><input type="checkbox" data-task-id="receita-cliente-widgets" /> Widgets UE5 refletem os objetos registrados em <code>NewUISystem.cpp</code> (HUD, chat, party, inventário) e respeitam profundidade de camada.</li>
                        <li><input type="checkbox" data-task-id="receita-cliente-assets" /> Barras de HP/MP/AG, botões e hotkeys reproduzem o estilo de <code>RenderLifeMana()</code>, <code>RenderHotKeyItemCount()</code> e <code>RenderButtons()</code>.</li>
                        <li><input type="checkbox" data-task-id="receita-cliente-testes" /> Fluxo login → lista de personagens → HUD validado enviando/recebendo pacotes equivalentes aos de <code>CGConnectAccountRecv</code> e <code>DGCharacterListRecv</code>.</li>
                    </ul>
                </div>
            </article>

            <article class="recipe">
                <h3>Receita do Servidor UE5 — GameServer, ConnectServer &amp; Persistência</h3>
                <dl class="recipe-brief">
                    <div>
                        <dt>O quê?</dt>
                        <dd>Montar um servidor dedicado dentro da UE5 que aceite logins, valide personagens e sincronize o mundo.</dd>
                    </div>
                    <div>
                        <dt>Por quê?</dt>
                        <dd>Substituir o código Win32 legado por uma base moderna, integrável e fácil de depurar.</dd>
                    </div>
                    <div>
                        <dt>Quando?</dt>
                        <dd>Assim que o cliente UE5 conseguir simular logins com dados mockados.</dd>
                    </div>
                    <div>
                        <dt>Onde?</dt>
                        <dd><code>Source/MuServer.Target.cs</code>, <code>Source/MuServer/</code> e serviços auxiliares (REST/gRPC).</dd>
                    </div>
                </dl>

                <div class="recipe-section">
                    <h4>Ingredientes (Pré-requisitos)</h4>
                    <ul>
                        <li>Sequência de pacotes detalhada em <code>GameServer/GameServer/Protocol.cpp</code> e <code>JSProtocol.cpp</code> para montar <em>DataTables</em> com IDs, tamanhos e ordem de mensagens.</li>
                        <li>Regras de ConnectServer retiradas de <code>ConnectServer/ConnectServer/ConnectServerProtocol.cpp</code> e <code>ServerList.cpp</code>, convertidas em <code>Enums</code>/<code>Structures</code> expostos a Blueprints.</li>
                        <li>Estruturas de usuário em <code>GameServer/GameServer/User.h</code> transformadas em <code>Blueprint Structs</code> que armazenem status de conexão, timers e flags.</li>
                        <li>Mapeamento das consultas de <code>DataServer/DataServer/CharacterManager.cpp</code> para rotinas Blueprint (HTTP, arquivo ou DataTable) que retornem contas, personagens e inventário.</li>
                    </ul>
                </div>

                <div class="recipe-section">
                    <h4>Modo de preparo</h4>
                    <ol class="recipe-steps">
                        <li>
                            <h5>Mise en place da infraestrutura</h5>
                            <p>Configure um <code>BP_MuServerGameInstance</code> com modo dedicado ativado (<em>Run Dedicated Server</em>) e um <code>BP_MuServerGameMode</code> que carregue DataTables de protocolos assim que o nível servidor iniciar. Use <em>Begin Play</em> para preparar mapas de cabeçalhos iguais aos vistos em <code>ConnectServerProtocolCore</code>.</p>
                        </li>
                        <li>
                            <h5>Cozinhe os handlers de conexão</h5>
                            <p>Construa um <code>BP_MuPacketRouter</code> (Actor ou Subsystem) com uma <em>Blueprint Interface</em> que processe <code>CGConnectAccountRecv</code> → <code>GJConnectAccountSend</code> → <code>JGConnectAccountRecv</code>. Cada etapa deve chamar nós <em>Switch on Enum</em> usando os dados da tabela e acionar <em>Event Dispatchers</em> equivalentes a <code>GCConnectAccountSend</code>/<code>GCMapServerMoveAuthSend</code>.</p>
                        </li>
                        <li>
                            <h5>Portar o estado de usuário</h5>
                            <p>Modele um <code>STRUCT_BP_UserState</code> com os campos de <code>User.h</code> (ex.: <code>LoginMessageSend</code>, <code>Connected</code>, <code>MapServerMoveRequest</code>). Atualize-o em grafos que respondam a <code>CGCloseClientRecv</code>, <code>CGCharacterListRecv</code>, <code>CGMoveRecv</code> e <code>CGPCharacterListRecv</code>, garantindo replicação para clientes utilizando <em>RepNotify</em> ou <em>Multicast Events</em>.</p>
                        </li>
                        <li>
                            <h5>Adicione camada de dados</h5>
                            <p>Implemente um <code>BP_MuAccountSubsystem</code> (GameInstance Subsystem Blueprint) que reprocesse <code>GDCharacterListSend</code> e <code>DGCharacterListRecv</code>. Use nós HTTP/JSON (ou leitura de DataTables) para devolver slots, inventário e resets, preenchendo caches análogos aos do <code>CCharacterManager</code>.</p>
                        </li>
                        <li>
                            <h5>Sirva com replicação e testes</h5>
                            <p>Crie grafos de broadcast inspirados em <code>gSocketManagerModern.PacketSend</code> que executem <em>Multicast</em> quando <code>CGMoveRecv</code> ou outros pacotes de ação chegarem. Execute testes multi-instância (opção <em>New Editor Window (PIE)</em> com número de clientes) verificando se o ConnectServer Blueprint responde como <code>CCServerInfoRecv</code>/<code>CCServerListRecv</code>.</p>
                        </li>
                    </ol>
                </div>

                <div class="recipe-section blueprint-guide">
                    <h4>Sequência guiada no Blueprint</h4>
                    <ol class="blueprint-flow">
                        <li>
                            <h5>BP_MuServerGameInstance (Event Init)</h5>
                            <p>
                                No evento <strong>Init</strong>, carregue o DataTable de protocolos e configure uma <strong>Map (Byte → Struct)</strong> replicando os cabeçalhos 0xF4/0x03/0x06 do ConnectServer. Adicione um <strong>Switch on Byte</strong> para validar se o servidor está pronto antes de emitir os eventos “SolicitarInfo” e “SolicitarLista”, respeitando a checagem original de <code>ConnectServerProtocolCore</code> e <code>CCServerInfoRecv</code>.【F:Source MuServer Update 15/ConnectServer/ConnectServer/ConnectServerProtocol.cpp†L10-L87】
                            </p>
                        </li>
                        <li>
                            <h5>BP_MuPacketRouter (Event OnPacketRecebido)</h5>
                            <p>
                                Monte um dispatcher que recebe <strong>Estrutura MuPacket</strong> (Head, SubHead, Payload). Use <strong>Switch on Byte</strong> para delegar o fluxo 0xF1/0x01 ao evento “ProcessarLogin” e acione <strong>Timeline</strong> ou <strong>Delay</strong> para simular o tempo de rede antes de chamar “EnviarParaDataServer”. Esse fluxo substitui o <code>CGConnectAccountRecv</code> e garante que versão e serial sejam validados antes de criptografar conta e senha.【F:Source MuServer Update 15/GameServer/GameServer/Protocol.cpp†L1950-L1995】
                            </p>
                        </li>
                        <li>
                            <h5>BP_MuAccountSubsystem (Evento ProcessarLogin)</h5>
                            <p>
                                Dentro do subsistema Blueprint, leia o DataTable “MuAccounts” usando <strong>Find Row</strong> e devolva um struct com personagens, resets e localização. O evento deve chamar “GerarRespostaLogin” (equivalente a <code>GJConnectAccountSend</code>) e, logo após, disparar “SolicitarListaPersonagens” como ocorre em <code>CGCharacterListRecv</code> e <code>GDCharacterListSend</code>.【F:Source MuServer Update 15/GameServer/GameServer/Protocol.cpp†L1994-L2019】
                            </p>
                        </li>
                        <li>
                            <h5>BP_MuCharacterCache (Gerenciamento de dados)</h5>
                            <p>
                                Armazene os dados retornados pelo subsistema em um <strong>Map (Name → Struct)</strong> que implemente <strong>Add</strong>/<strong>Remove</strong> seguindo as rotinas de <code>CCharacterManager</code>. Atualize o mapa a cada login/logout para espelhar <code>InsertCharacterInfo</code> e <code>RemoveCharacterInfo</code>.【F:Source MuServer Update 15/DataServer/DataServer/CharacterManager.cpp†L43-L104】
                            </p>
                        </li>
                        <li>
                            <h5>BP_MuWorldReplicator (Evento PropagarMovimento)</h5>
                            <p>
                                Ao receber um pacote 0xD7/0x1C (movimento), converta em <strong>Multicast RPC</strong> ou <strong>RepNotify</strong> enviando posição e direção para todos os clientes conectados. O fluxo deve replicar o laço que percorre <code>VpPlayer2</code> e usa <code>PacketSend</code>/<code>DataSend</code> para broadcast do movimento.【F:Source MuServer Update 15/GameServer/GameServer/Protocol.cpp†L1907-L1945】
                            </p>
                        </li>
                    </ol>
                </div>

                <div class="recipe-section blueprint-translation">
                    <h4>Tradução do C++ → nós Blueprints</h4>
                    <dl class="translation-pairs">
                        <div>
                            <dt><code>ConnectServerProtocolCore</code></dt>
                            <dd><strong>Blueprint:</strong> <em>Switch on Byte</em> (Head) + <em>Switch on Byte</em> (SubHead) + <em>Custom Events</em> “ReceberInfo” / “ReceberLista” para replicar o roteamento 0xF4/0x03/0x06.【F:Source MuServer Update 15/ConnectServer/ConnectServer/ConnectServerProtocol.cpp†L10-L87】</dd>
                        </div>
                        <div>
                            <dt><code>CGConnectAccountRecv</code></dt>
                            <dd><strong>Blueprint:</strong> <em>Custom Event</em> “ProcessarLogin” com verificações (<em>Equal</em>, <em>Branch</em>) de versão/serial e chamadas subsequentes para “EnviarRespostaLogin” e “SolicitarDataServer”, reproduzindo as atribuições de <code>LoginMessageSend</code> e a criptografia da conta.【F:Source MuServer Update 15/GameServer/GameServer/Protocol.cpp†L1950-L1995】</dd>
                        </div>
                        <div>
                            <dt><code>GDCharacterListSend</code></dt>
                            <dd><strong>Blueprint:</strong> <em>Custom Event</em> “SolicitarListaPersonagens” que aciona <em>For Each</em> em uma fonte de dados (HTTP/DataTable) e retorna um array para o cliente via <em>Multicast</em> ou <em>Client RPC</em>, imitando a chamada imediata após <code>CGCharacterListRecv</code>.【F:Source MuServer Update 15/GameServer/GameServer/Protocol.cpp†L2010-L2019】</dd>
                        </div>
                        <div>
                            <dt><code>CCharacterManager::Insert/RemoveCharacterInfo</code></dt>
                            <dd><strong>Blueprint:</strong> Funções “AdicionarPersonagem” / “RemoverPersonagem” operando sobre um <em>Map</em> ou <em>Data Asset</em>, garantindo consistência em sessões simultâneas assim como o map em C++.【F:Source MuServer Update 15/DataServer/DataServer/CharacterManager.cpp†L64-L104】</dd>
                        </div>
                        <div>
                            <dt><code>gSocketManagerModern.PacketSend</code> / <code>DataSend</code></dt>
                            <dd><strong>Blueprint:</strong> <em>Multicast RPC</em> / <em>Client RPC</em> chamados a partir do <em>GameMode</em> ou <em>PlayerController</em> servidor para distribuir atualizações de movimento, inventário e chat, reproduzindo o broadcast para <code>VpPlayer2</code>.【F:Source MuServer Update 15/GameServer/GameServer/Protocol.cpp†L1907-L1945】</dd>
                        </div>
                    </dl>
                </div>

                <div class="recipe-section">
                    <h4>Checklist final</h4>
                    <ul class="checklist" aria-label="Checklist receita servidor UE5">
                        <li><input type="checkbox" data-task-id="receita-servidor-target" /> Build dedicado Blueprint-only inicializa e envia respostas equivalentes a <code>CCServerInfoRecv</code>/<code>CCServerListRecv</code>.</li>
                        <li><input type="checkbox" data-task-id="receita-servidor-handlers" /> Sequência <code>CGConnectAccountRecv</code> → <code>JGConnectAccountRecv</code> → <code>DGCharacterListRecv</code> reproduzida com <em>Event Dispatchers</em> e structs Blueprint.</li>
                        <li><input type="checkbox" data-task-id="receita-servidor-persistencia" /> Persistência Blueprint devolve personagens/inventário equivalentes aos campos de <code>DSProtocol.cpp</code> e mantém reconexões ativas em testes multi-cliente.</li>
                    </ul>
                </div>
            </article>
        </section>

        <section class="module blueprint-decoder" data-section-id="interpretacao-blueprint">
            <header>
                <h2>Caderno de Interpretação dos Códigos Legados</h2>
                <p class="tag">Passo a passo em linguagem simples</p>
            </header>

            <article class="lesson interpretation">
                <h3>Cliente original → Blueprint sem mistério</h3>
                <p>
                    Aqui você encontra descrições em português claro do que o <strong>Source Main 5.2</strong> faz e o equivalente direto em Blueprints.
                    Use como referência sempre que travar: leia o que o código realiza, reproduza a rotina visualmente e marque o checklist para consolidar o aprendizado.
                </p>

                <div class="interpretation-card">
                    <h4>HUD principal e botões do menu</h4>
                    <p class="code-path">Fonte: <code>NewUIMainFrameWindow.cpp</code>, linhas 59-199.</p>
                    <div class="interpretation-columns">
                        <section>
                            <h5>O que o código faz</h5>
                            <ul>
                                <li><strong>LoadImages</strong> carrega as texturas do HUD antigo, como barras de HP/MP e botões, usando caminhos <code>Interface\*.jpg</code>.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L59-L77】</li>
                                <li><strong>SetButtonInfo</strong> posiciona cinco botões lado a lado, configurando cor, tooltip e imagem para cada função (shop, status, inventário, amigos, janela).【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L117-L160】</li>
                                <li><strong>Render</strong> desenha frame, barras de vida/escudo/AG, lista de skills e efeitos antes de finalizar com os botões, garantindo sempre a mesma ordem visual.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L180-L199】</li>
                            </ul>
                        </section>
                        <section>
                            <h5>Como replicar com Blueprints</h5>
                            <ol>
                                <li>Crie um <em>Widget Blueprint</em> chamado <code>WBP_MainHUD</code> e adicione <em>Images</em> para cada textura. Carregue-as como <em>Brushes</em> apontando para as mesmas pastas ou equivalentes remasterizados.</li>
                                <li>Organize cinco <em>Buttons</em> dentro de um <em>Horizontal Box</em>. Ajuste <em>Padding</em> para reproduzir o espaçamento de <code>x_Add</code> (30 px) e defina <em>Tooltips</em> com os mesmos textos.</li>
                                <li>No <em>Event Construct</em>, chame uma função <code>ConfigurarHUD</code> que seta as barras de HP/MP/AG em sequência, garantindo que a ordem de atualização siga o fluxo do render legado.</li>
                                <li>Expose variáveis como <code>CorBotaoNormal</code> e <code>CorBotaoPressionado</code> para trocar facilmente cores de destaque, equivalentes aos <code>ChangeImgColor</code> originais.</li>
                            </ol>
                        </section>
                    </div>
                    <ul class="checklist interpretation-checklist" aria-label="Checklist de compreensão do HUD">
                        <li><input type="checkbox" data-task-id="interpretacao-hud-identificar" /> Consegui apontar onde cada barra/botão aparece no Blueprint.</li>
                        <li><input type="checkbox" data-task-id="interpretacao-hud-configurar" /> Configurei a função <code>ConfigurarHUD</code> para atualizar barras na ordem original.</li>
                        <li><input type="checkbox" data-task-id="interpretacao-hud-tooltips" /> Reproduzi os tooltips com textos equivalentes aos do cliente.</li>
                    </ul>
                </div>

                <div class="interpretation-card">
                    <h4>Inventário e efeitos de equipar</h4>
                    <p class="code-path">Fonte: <code>NewUIMyInventory.cpp</code>, linhas 65-188.</p>
                    <div class="interpretation-columns">
                        <section>
                            <h5>O que o código faz</h5>
                            <ul>
                                <li><strong>Create</strong> registra a janela no gerenciador de UI, cria o controle de grid (8×8) e prepara imagens e botões antes de exibir.【F:Source Main 5.2/source/NewUIMyInventory.cpp†L65-L89】</li>
                                <li><strong>EquipItem</strong> transforma um pacote de item em estrutura interna, substitui o slot, chama efeitos e solicita dados extras para pets especiais.【F:Source Main 5.2/source/NewUIMyInventory.cpp†L115-L147】</li>
                                <li><strong>UnequipItem/UnequipAllItems</strong> limpam o slot, removem efeitos visuais e reiniciam informações de pets quando um item sai do equipamento.【F:Source Main 5.2/source/NewUIMyInventory.cpp†L151-L196】</li>
                            </ul>
                        </section>
                        <section>
                            <h5>Como replicar com Blueprints</h5>
                            <ol>
                                <li>No <code>WBP_Inventory</code>, monte um <em>Uniform Grid Panel</em> 8×8 e salve a referência em uma variável <code>InventoryGrid</code>, equivalente ao <code>CNewUIInventoryCtrl</code>.</li>
                                <li>Crie um <em>Actor Component</em> <code>BP_ItemPacketDecoder</code> que recebe um <code>Struct</code> (<em>DataTable Row</em>) e retorna um <code>StructBP_Item</code> pronto para ser colocado no grid.</li>
                                <li>Quando o jogador clica em “equipar”, use um <em>Event Dispatcher</em> <code>OnEquipItem</code> que atualiza um array de slots e dispara efeitos com <em>Niagara</em> ou <em>Timeline</em>, simulando <code>CreateEquippingEffect</code>.</li>
                                <li>Para pets, adicione um <em>Switch on Enum</em> baseado no tipo do item e chame funções <code>SolicitarInfoPet</code> e <code>RemoverInfoPet</code>, reproduzindo as chamadas <code>SendRequestPetInfo</code> e limpeza de dados.</li>
                            </ol>
                        </section>
                    </div>
                    <ul class="checklist interpretation-checklist" aria-label="Checklist de compreensão do inventário">
                        <li><input type="checkbox" data-task-id="interpretacao-inventario-grid" /> Organizei o grid 8×8 com uma variável parecida com <code>InventoryGrid</code>.</li>
                        <li><input type="checkbox" data-task-id="interpretacao-inventario-struct" /> Criei um <code>StructBP_Item</code> para guardar tipo, nível, sockets e efeitos.</li>
                        <li><input type="checkbox" data-task-id="interpretacao-inventario-eventos" /> Configurei <em>Dispatchers</em> para efeitos de equipar e remoção, incluindo os casos de pets.</li>
                    </ul>
                </div>
            </article>

            <article class="lesson interpretation">
                <h3>Servidores legados → Blueprint organizado</h3>
                <p>
                    Esta parte traduz as rotinas centrais do <strong>Source MuServer Update 15</strong> em blocos lógicos que cabem em Blueprints.
                    A intenção é mostrar claramente o fluxo de mensagens e estados para que você monte subsistemas dedicados sem escrever C++.
                </p>

                <div class="interpretation-card">
                    <h4>Handshake do ConnectServer</h4>
                    <p class="code-path">Fonte: <code>ConnectServer/ConnectServerProtocol.cpp</code>, linhas 10-87.</p>
                    <div class="interpretation-columns">
                        <section>
                            <h5>O que o código faz</h5>
                            <ul>
                                <li><strong>ConnectServerProtocolCore</strong> atualiza o tempo do cliente e roteia mensagens pelo cabeçalho 0xF4.【F:Source MuServer Update 15/ConnectServer/ConnectServer/ConnectServerProtocol.cpp†L10-L31】</li>
                                <li><strong>CCServerInfoRecv</strong> valida se o servidor está visível e responde com IP e porta corretos usando <code>DataSend</code>.【F:Source MuServer Update 15/ConnectServer/ConnectServer/ConnectServerProtocol.cpp†L34-L62】</li>
                                <li><strong>CCServerListRecv</strong> gera a lista completa de mundos e envia de volta com o tamanho calculado dinamicamente.【F:Source MuServer Update 15/ConnectServer/ConnectServer/ConnectServerProtocol.cpp†L64-L87】</li>
                            </ul>
                        </section>
                        <section>
                            <h5>Como replicar com Blueprints</h5>
                            <ol>
                                <li>Implemente um <code>BP_ConnectServerSubsystem</code> (GameInstance Subsystem) com um <em>Map</em> <code>Pacote → Função</code> para simular o <code>switch</code> do cabeçalho.</li>
                                <li>Crie uma <em>DataTable</em> <code>DT_ServerList</code> com colunas <em>Código</em>, <em>Nome</em>, <em>IP</em>, <em>Porta</em>, <em>Visível</em> e use-a para preencher arrays que serão enviados via <em>RPC</em>.</li>
                                <li>Ao receber um pedido de info, monte uma <code>Struct</code> <code>BP_ServerInfo</code> e dispare um <em>Custom Event</em> replicado que envia IP/Porta aos clientes conectados.</li>
                            </ol>
                        </section>
                    </div>
                    <ul class="checklist interpretation-checklist" aria-label="Checklist de compreensão do ConnectServer">
                        <li><input type="checkbox" data-task-id="interpretacao-connect-mapa" /> Modelei o mapa <code>Pacote → Função</code> no Subsystem.</li>
                        <li><input type="checkbox" data-task-id="interpretacao-connect-datatable" /> Montei uma <em>DataTable</em> com IP, porta e status de cada servidor.</li>
                        <li><input type="checkbox" data-task-id="interpretacao-connect-broadcast" /> Configurei um evento replicado que envia <code>BP_ServerInfo</code> para os clientes.</li>
                    </ul>
                </div>

                <div class="interpretation-card">
                    <h4>Roteamento de pacotes do GameServer</h4>
                    <p class="code-path">Fonte: <code>GameServer/Protocol.cpp</code>, linhas 1-199.</p>
                    <div class="interpretation-columns">
                        <section>
                            <h5>O que o código faz</h5>
                            <ul>
                                <li>O arquivo inclui dezenas de sistemas (trade, guild, eventos) porque o <code>ProtocolCore</code> distribui cada cabeçalho para o manipulador correto.【F:Source MuServer Update 15/GameServer/GameServer/Protocol.cpp†L1-L73】</li>
                                <li>Antes de roteá-los, o servidor registra o pacote recebido para depuração, imprimindo cabeçalho e tamanho em log vermelho quando não é handshake.【F:Source MuServer Update 15/GameServer/GameServer/Protocol.cpp†L82-L92】</li>
                                <li>O grande <code>switch</code> despacha casos como chat (0x00), ataque (PROTOCOL_CODE2), teleporte (0x1C) ou interações de loja (0x32-0x37) para classes especializadas.【F:Source MuServer Update 15/GameServer/GameServer/Protocol.cpp†L97-L195】</li>
                            </ul>
                        </section>
                        <section>
                            <h5>Como replicar com Blueprints</h5>
                            <ol>
                                <li>Construa um <code>BP_GameServerRouter</code> com um <em>Switch on Byte</em> principal e <em>Macros</em> ou <em>Functions</em> nomeadas (Ex.: <code>TratarChat</code>, <code>TratarAtaque</code>) para cada cabeçalho.</li>
                                <li>Implemente um logger visual usando <code>Print String</code> colorido ou um <em>Widget</em> dedicado que registra os pacotes, simulando o <code>LogAdd</code> vermelho.</li>
                                <li>Para cada caso complexo, chame um <em>Blueprint Interface</em> (<code>BPI_Trade</code>, <code>BPI_ItemManager</code>) para delegar a lógica e manter o gráfico legível.</li>
                            </ol>
                        </section>
                    </div>
                    <ul class="checklist interpretation-checklist" aria-label="Checklist de compreensão do roteador do GameServer">
                        <li><input type="checkbox" data-task-id="interpretacao-protocol-switch" /> Reproduzi o <em>Switch on Byte</em> com eventos nomeados para cada pacote importante.</li>
                        <li><input type="checkbox" data-task-id="interpretacao-protocol-log" /> Configurei um logger visual para ver cada pacote chegando.</li>
                        <li><input type="checkbox" data-task-id="interpretacao-protocol-interfaces" /> Separei a lógica em <em>Blueprint Interfaces</em> ou <em>Function Libraries</em>.</li>
                    </ul>
                </div>

                <div class="interpretation-card">
                    <h4>Estados do jogador e limites</h4>
                    <p class="code-path">Fonte: <code>GameServer/User.h</code>, linhas 13-183.</p>
                    <div class="interpretation-columns">
                        <section>
                            <h5>O que o código faz</h5>
                            <ul>
                                <li>Define limites globais como quantidade máxima de usuários, monstros e inventário estendido, que impactam validações em runtime.【F:Source MuServer Update 15/GameServer/GameServer/User.h†L13-L63】</li>
                                <li>Enumera estados de conexão (<code>OBJECT_OFFLINE</code> → <code>OBJECT_ONLINE</code>) e tipos de interface ativa (trade, party, shop, etc.).【F:Source MuServer Update 15/GameServer/GameServer/User.h†L65-L118】</li>
                                <li>Lista animações/ações possíveis (atacar, sentar, cumprimentar) com constantes numéricas usadas em pacotes e animações.【F:Source MuServer Update 15/GameServer/GameServer/User.h†L120-L183】</li>
                            </ul>
                        </section>
                        <section>
                            <h5>Como replicar com Blueprints</h5>
                            <ol>
                                <li>Crie <code>Enums</code> Blueprint (<code>EPlayerConnectionState</code>, <code>EPlayerInterfaceType</code>, <code>EPlayerAction</code>) com os mesmos nomes/valores para manter compatibilidade.</li>
                                <li>Adicione essas enums em um <code>Struct</code> <code>BP_UserState</code> armazenado no seu <code>BP_UserManager</code>. Atualize-as via <em>RepNotify</em> quando pacotes chegarem.</li>
                                <li>Use os limites (ex.: <code>MAX_MONEY</code>, <code>MAX_SELF_DEFENSE</code>) como constantes em <em>Blueprint Function Libraries</em> para validar entrada do usuário sem precisar revisar o C++ sempre.</li>
                            </ol>
                        </section>
                    </div>
                    <ul class="checklist interpretation-checklist" aria-label="Checklist de compreensão dos estados de usuário">
                        <li><input type="checkbox" data-task-id="interpretacao-user-enums" /> Criei enums Blueprint com os mesmos estados do arquivo.</li>
                        <li><input type="checkbox" data-task-id="interpretacao-user-struct" /> Montei o <code>Struct BP_UserState</code> e configurei replicação.</li>
                        <li><input type="checkbox" data-task-id="interpretacao-user-constantes" /> Anotei limites importantes (dinheiro, slots, ações) em uma biblioteca de constantes.</li>
                    </ul>
                </div>
            </article>
        </section>

        <section class="module blueprint-lab" data-section-id="laboratorio-blueprint">
            <header>
                <h2>Laboratório Guiado de Blueprint</h2>
                <p class="tag">Prática assistida</p>
                <p>Transforme as interpretações em ação imediata. Cada laboratório foca um trecho do código legado e apresenta uma receita "faça junto" totalmente em Blueprints.</p>
            </header>

            <article class="lesson lab-overview">
                <h3>Como usar o laboratório</h3>
                <ul class="lab-hints">
                    <li>Siga primeiro a coluna <strong>Observar no código</strong> para confirmar o que acontece no legado.</li>
                    <li>Em seguida, reproduza os mesmos passos usando a coluna <strong>Construir no Blueprint</strong>.</li>
                    <li>Abra os <em>passos detalhados</em> se ficar em dúvida: eles explicam clique a clique no editor.</li>
                </ul>
            </article>

            <div class="lab-grid">
                <article class="lesson lab-card">
                    <h3>Laboratório 1 — HUD modular com Widget Switcher</h3>
                    <p>Reconstrua o comportamento de <code>CNewUIMainFrameWindow</code> usando apenas UMG, preparando o terreno para alternar interfaces como o cliente original.</p>
                    <div class="lab-columns">
                        <section>
                            <h4>Observar no código</h4>
                            <ul>
                                <li><code>LoadImages</code> registra o caminho de cada textura do HUD antes de mostrá-la.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L59-L116】</li>
                                <li><code>SetButtonInfo</code> guarda um índice para cada botão e associa a função correspondente no <code>CNewUIManager</code>.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L117-L160】</li>
                                <li>No <code>Render</code>, a janela só desenha o botão se <code>m_iCurrentTab</code> combina com a tela ativa.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L180-L199】</li>
                            </ul>
                        </section>
                        <section>
                            <h4>Construir no Blueprint</h4>
                            <ol>
                                <li>Crie <code>WBP_MainHUD</code> com um <em>Widget Switcher</em> guardado em variável <code>SwitcherTabs</code>.</li>
                                <li>Adicione um <em>DataTable</em> <code>DT_HUDButtons</code> contendo nome, ícone, tooltip e o índice esperado.</li>
                                <li>No <em>Event Construct</em>, percorra a DataTable e chame uma função <code>RegistrarBotao</code> que instancia o botão e armazena o índice em <code>Map&lt;Nome → Índice&gt;</code>.</li>
                                <li>Crie um evento <code>SelecionarAba</code> que troca o <em>Active Index</em> do <code>Widget Switcher</code>, simulando <code>m_iCurrentTab</code>.</li>
                            </ol>
                        </section>
                    </div>
                    <button type="button" class="focus-toggle lab-toggle" data-target="lab1-passos" data-open-label="Ocultar passos detalhados" data-close-label="Ver passos detalhados">Ver passos detalhados</button>
                    <div id="lab1-passos" class="lab-extra" hidden>
                        <ol>
                            <li>No Content Browser, clique com o botão direito &gt; <em>User Interface</em> &gt; <strong>Widget Blueprint</strong> e nomeie como <code>WBP_MainHUD</code>.</li>
                            <li>Dentro do widget, arraste um <strong>Widget Switcher</strong> para o canvas, renomeie para <code>SwitcherTabs</code> e marque a caixa <em>Is Variable</em>.</li>
                            <li>Crie a <strong>DataTable</strong> a partir de um <code>Struct</code> <code>ST_HUDButton</code> com campos (Nome, Icone, Tooltip, Indice). Preencha uma linha para cada botão observado no código legado.</li>
                            <li>No <em>Graph</em>, adicione o nó <code>Get Data Table Row Names</code>, faça um <code>For Each Loop</code> e, para cada linha, crie um botão dinamicamente (nó <code>Create Widget</code> → <code>WBP_HUDButton</code>), definindo o ícone/tooltip antes de adicionar ao painel.</li>
                            <li>Implemente o evento <code>SelecionarAba</code> usando <code>SwitcherTabs → Set Active Widget Index</code> e atualize o estado visual do botão clicado com um <em>Bind</em> de cor.</li>
                        </ol>
                    </div>
                    <ul class="checklist lab-checklist" aria-label="Checklist Laboratório 1">
                        <li><input type="checkbox" data-task-id="lab1-widget-switcher" /> Widget Switcher configurado com abas equivalentes às do cliente.</li>
                        <li><input type="checkbox" data-task-id="lab1-tabela-botoes" /> DataTable de botões criada com campos do <code>SetButtonInfo</code>.</li>
                        <li><input type="checkbox" data-task-id="lab1-evento-aba" /> Evento <code>SelecionarAba</code> troca abas e atualiza destaque do botão.</li>
                    </ul>
                </article>

                <article class="lesson lab-card">
                    <h3>Laboratório 2 — Packet Router visual do ConnectServer</h3>
                    <p>Monte um roteador de pacotes inspirado no <code>ConnectServerProtocolCore</code> para treinar a leitura dos cabeçalhos 0xF4 sem usar C++.</p>
                    <div class="lab-columns">
                        <section>
                            <h4>Observar no código</h4>
                            <ul>
                                <li>O <code>ConnectServerProtocolCore</code> confirma o identificador 0xF4 antes de chamar as funções específicas.【F:Source MuServer Update 15/ConnectServer/ConnectServer/ConnectServerProtocol.cpp†L10-L31】</li>
                                <li><code>CCServerInfoRecv</code> monta uma estrutura com IP, porta e estado de visibilidade da sala.【F:Source MuServer Update 15/ConnectServer/ConnectServer/ConnectServerProtocol.cpp†L34-L62】</li>
                                <li><code>CCServerListRecv</code> envia uma lista dinâmica de mundos calculando tamanho final antes do envio.【F:Source MuServer Update 15/ConnectServer/ConnectServer/ConnectServerProtocol.cpp†L64-L87】</li>
                            </ul>
                        </section>
                        <section>
                            <h4>Construir no Blueprint</h4>
                            <ol>
                                <li>Crie um <code>GameInstanceSubsystem</code> Blueprint chamado <code>BP_ConnectRouter</code>.</li>
                                <li>Adicione um <code>Switch on Byte</code> recebendo o campo <em>HeadCode</em> (0xF4). Caso seja diferente, registre um aviso com <code>Print String</code>.</li>
                                <li>Para os subcódigos (0x03 para info, 0x06 para lista), chame funções <code>EnviarInfoServidor</code> e <code>EnviarListaServidores</code>.</li>
                                <li>Use uma <code>DataTable</code> <code>DT_ServerWorlds</code> com IP, Porta, Mundo e Status para popular structs <code>ST_ServerInfo</code>.</li>
                            </ol>
                        </section>
                    </div>
                    <button type="button" class="focus-toggle lab-toggle" data-target="lab2-passos" data-open-label="Ocultar passos detalhados" data-close-label="Ver passos detalhados">Ver passos detalhados</button>
                    <div id="lab2-passos" class="lab-extra" hidden>
                        <ol>
                            <li>No Content Browser, adicione &gt; <em>Blueprint Class</em> &gt; <strong>Game Instance Subsystem</strong> e nomeie como <code>BP_ConnectRouter</code>.</li>
                            <li>Exponha um evento <code>ProcessarPacote</code> que recebe um <code>Struct</code> <code>ST_Pacote</code> (HeadCode, SubCode, Payload).</li>
                            <li>Dentro do evento, coloque um <code>Branch</code> verificando se o <code>HeadCode</code> é 0xF4 antes do <code>Switch on Byte</code> do SubCode.</li>
                            <li>Na função <code>EnviarListaServidores</code>, use <code>Get Data Table Row Names</code> + <code>For Each Loop</code> para montar um array de <code>ST_ServerInfo</code> e dispare um <em>Multicast</em> <code>OnServerListAtualizada</code>.</li>
                            <li>Implemente um <code>Widget</code> simples que escute o evento e mostre a lista em um <em>ListView</em>, confirmando visualmente o resultado.</li>
                        </ol>
                    </div>
                    <ul class="checklist lab-checklist" aria-label="Checklist Laboratório 2">
                        <li><input type="checkbox" data-task-id="lab2-branch-headcode" /> Branch validando o cabeçalho 0xF4 implementado.</li>
                        <li><input type="checkbox" data-task-id="lab2-switch-subcode" /> Switch nos subcódigos chama funções dedicadas.</li>
                        <li><input type="checkbox" data-task-id="lab2-listview" /> Lista de servidores exibida em Widget após processamento.</li>
                    </ul>
                </article>

                <article class="lesson lab-card">
                    <h3>Laboratório 3 — Estados de usuário sincronizados</h3>
                    <p>Pratique a conversão de <code>User.h</code> em <code>Structs</code> e <code>Enums</code> Blueprint mantendo replicação e limites do servidor.</p>
                    <div class="lab-columns">
                        <section>
                            <h4>Observar no código</h4>
                            <ul>
                                <li>O arquivo define constantes como <code>MAX_VIEWPORT</code> e <code>MAX_SELF_DEFENSE</code> usadas em múltiplas validações.【F:Source MuServer Update 15/GameServer/GameServer/User.h†L13-L63】</li>
                                <li>As enums <code>eObjectState</code> e <code>eInterfaceState</code> controlam o que cada jogador pode fazer.【F:Source MuServer Update 15/GameServer/GameServer/User.h†L65-L118】</li>
                                <li>Há uma struct <code>OBJECTSTRUCT</code> com campos de posição, inventário e timers que precisam existir no Blueprint.【F:Source MuServer Update 15/GameServer/GameServer/User.h†L119-L183】</li>
                            </ul>
                        </section>
                        <section>
                            <h4>Construir no Blueprint</h4>
                            <ol>
                                <li>Crie uma <code>Blueprint Enum</code> <code>EUserConnectionState</code> com os mesmos rótulos (<em>Offline</em>, <em>Connected</em>, <em>Playing</em>...).</li>
                                <li>Modele o <code>Struct</code> <code>ST_UserSnapshot</code> contendo posição, HP/MP, inventário rápido e flags.</li>
                                <li>No <code>BP_UserManager</code> (Actor Component), armazene um <code>Map&lt;PlayerId → ST_UserSnapshot&gt;</code> replicado.</li>
                                <li>Implemente eventos <code>AtualizarEstado</code> e <code>AtualizarLimites</code> que conferem os valores máximos antes de aceitar mudanças.</li>
                            </ol>
                        </section>
                    </div>
                    <button type="button" class="focus-toggle lab-toggle" data-target="lab3-passos" data-open-label="Ocultar passos detalhados" data-close-label="Ver passos detalhados">Ver passos detalhados</button>
                    <div id="lab3-passos" class="lab-extra" hidden>
                        <ol>
                            <li>Crie as <strong>Enums</strong> acessando <em>Add New → Blueprints → Enumeration</em> e replique os nomes/ordens vistas em <code>eObjectState</code> e <code>eInterfaceState</code>.</li>
                            <li>No <em>Editor</em>, adicione um <strong>Blueprint Struct</strong> <code>ST_UserSnapshot</code> com campos numéricos (HP, MP, Money) configurando valores padrão iguais aos do arquivo.</li>
                            <li>Em <code>BP_UserManager</code>, habilite <em>Replicates</em> e use <code>RepNotify</code> no Map para atualizar Widgets quando houver alterações.</li>
                            <li>Implemente função <code>AplicarLimites</code> que usa nós <code>Clamp Float/Int</code> com constantes <code>MAX_MONEY</code> e <code>MAX_SELF_DEFENSE</code> definidas em uma <em>Blueprint Function Library</em>.</li>
                            <li>Crie um teste local adicionando dois jogadores simulados e verificando no <em>Output Log</em> se o estado troca ao enviar eventos como <code>OnEntrouEmParty</code>.</li>
                        </ol>
                    </div>
                    <ul class="checklist lab-checklist" aria-label="Checklist Laboratório 3">
                        <li><input type="checkbox" data-task-id="lab3-enums" /> Enums de estado criadas com os mesmos valores do legado.</li>
                        <li><input type="checkbox" data-task-id="lab3-struct" /> Struct <code>ST_UserSnapshot</code> replicada com campos principais.</li>
                        <li><input type="checkbox" data-task-id="lab3-clamp" /> Função <code>AplicarLimites</code> garante que valores não ultrapassem constantes originais.</li>
                    </ul>
                </article>
            </div>
        </section>

        <section class="module support-hub" data-section-id="acompanhamento-continuo">
            <header>
                <h2>Centro de Revisão Contínua</h2>
                <p class="tag">Sustentação do estudo</p>
                <p>Use esta área para repetir revisões críticas e registrar interpretações com suas próprias palavras, mantendo o foco mesmo sem experiência prévia em programação.</p>
            </header>

            <article class="lesson support-checklist">
                <h3>Checklist de manutenção semanal</h3>
                <p>Reserve um bloco de 30 a 45 minutos para validar se os Blueprints continuam fiéis aos comportamentos do código legado.</p>
                <div class="support-grid">
                    <section>
                        <h4>Por que repetir?</h4>
                        <p>Esses testes reforçam o entendimento das entradas e saídas originais, evitando que ajustes recentes quebrem o fluxo do HUD ou do servidor.</p>
                    </section>
                    <section>
                        <h4>O que revisar</h4>
                        <ul class="checklist weekly-checklist" aria-label="Checklist semanal de revisão">
                            <li><input type="checkbox" data-task-id="review-manager-rotinas" /> Conferi se o Blueprint que substitui <code>CNewUIManager</code> ainda mantém a ordem de foco e remoção de UI, igual ao <code>UpdateMouseEvent</code> que reorganiza a lista antes de processar cliques.【F:Source Main 5.2/source/NewUIManager.cpp†L108-L141】</li>
                            <li><input type="checkbox" data-task-id="review-hud-texturas" /> Reabri o HUD e garanti que todos os botões usam as mesmas texturas carregadas por <code>LoadImages</code>, sem trocas acidentais ou ícones faltando.【F:Source Main 5.2/source/NewUIMainFrameWindow.cpp†L59-L116】</li>
                            <li><input type="checkbox" data-task-id="review-protocol-core" /> Executei o fluxo de login observando se o roteador Blueprint dispara as mesmas respostas do <code>ConnectServerProtocolCore</code> para cabeçalhos 0xF4.【F:Source MuServer Update 15/ConnectServer/ConnectServer/ConnectServerProtocol.cpp†L10-L87】</li>
                            <li><input type="checkbox" data-task-id="review-user-states" /> Validei que os estados e limites do jogador continuam respeitando as constantes de <code>User.h</code> (como <code>MAX_SELF_DEFENSE</code> e <code>MAX_MONEY</code>) ao sincronizar inventário e ações.【F:Source MuServer Update 15/GameServer/GameServer/User.h†L13-L183】</li>
                        </ul>
                    </section>
                </div>
            </article>

            <article class="lesson support-journal">
                <h3>Diário de interpretação (O quê, Por quê, Quando, Onde)</h3>
                <p>Registre o que você entendeu de cada trecho. Ao reescrever com suas palavras, você cria um manual personalizado que pode consultar antes de construir o Blueprint correspondente.</p>
                <form id="diary-form" class="diary-form" autocomplete="off">
                    <div class="form-grid">
                        <label>
                            Trecho observado
                            <input type="text" name="topic" id="diary-topic" required placeholder="Ex.: Render() do HUD principal" />
                        </label>
                        <label>
                            Arquivo ou função
                            <input type="text" name="reference" id="diary-reference" placeholder="Ex.: NewUIMainFrameWindow.cpp" />
                        </label>
                    </div>
                    <label class="full-width">
                        Anotações (O quê, Por quê, Quando, Onde)
                        <textarea name="notes" id="diary-notes" rows="4" required placeholder="Descreva com suas palavras o que acontece no código e onde isso aparece no jogo"></textarea>
                    </label>
                    <label class="full-width">
                        Próximo passo em Blueprint
                        <textarea name="next" id="diary-next" rows="3" placeholder="Ex.: Criar Widget com Widget Switcher e mapear botões"></textarea>
                    </label>
                    <div class="diary-actions">
                        <button type="submit" class="primary">Salvar anotação</button>
                        <button type="button" id="diary-clear" class="ghost">Limpar diário</button>
                    </div>
                </form>
                <ul id="diary-list" class="diary-entries" aria-live="polite" aria-label="Anotações salvas do diário"></ul>
            </article>
        </section>
    </main>

    <footer>
        <p>Guia criado para apoiar um aprendizado consistente e profundo da Unreal Engine 5+.</p>
    </footer>

    <template id="toc-item-template">
        <li>
            <a href="#" data-target="">Item</a>
        </li>
    </template>

    <script src="script.js" defer></script>
</body>
</html>
