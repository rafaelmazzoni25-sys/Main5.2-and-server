<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ensino Remake - Guia do Projeto</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header class="hero">
        <div class="hero__overlay"></div>
        <div class="hero__content">
            <h1>Ensino Remake</h1>
            <p>
                Uma trilha didática para reconstruir o <strong>Main 5.2</strong> (cliente) e o <strong>MuServer Update 15</strong>
                (servidor) com adaptação para <strong>Unreal Engine 5</strong>, guiando pessoas que nunca programaram.
            </p>
            <a class="hero__cta" href="#trilha-geral">Começar agora</a>
        </div>
    </header>

    <nav class="quick-nav" aria-label="Navegação rápida">
        <button data-target="introducao">Visão Geral</button>
        <button data-target="tutorial-completo">Tutorial Passo a Passo</button>
        <button data-target="modulos">Módulos Essenciais</button>
        <button data-target="mapa-codigo">Mapa do Código</button>
        <button data-target="cliente-detalhado">Cliente em Detalhes</button>
        <button data-target="servidor-detalhado">Servidor em Detalhes</button>
        <button data-target="unreal-detalhado">Guia Unreal Detalhado</button>
        <button data-target="receitas-unreal">Receitas Unreal</button>
        <button data-target="atlas-unreal">Enciclopédia de Sistemas</button>
        <button data-target="protocolos">Protocolos &amp; Pacotes</button>
        <button data-target="banco-dados">Banco de Dados</button>
        <button data-target="preparacao">Preparação</button>
        <button data-target="trilha-geral">Linha do Tempo</button>
        <button data-target="frontend">Trilha Cliente</button>
        <button data-target="unreal">Trilha Unreal Engine 5</button>
        <button data-target="backend">Trilha Servidor</button>
        <button data-target="laboratorios">Laboratórios Guiados</button>
        <button data-target="erros">Diagnóstico &amp; FAQ</button>
        <button data-target="glossario">Glossário</button>
        <button data-target="pipeline-assets">Pipeline de Assets</button>
        <button data-target="playbook-personagem">Playbook Unreal 1:1</button>
        <button data-target="qa-publicacao">QA &amp; Operações</button>
        <button data-target="recursos">Recursos &amp; Referências</button>
    </nav>

    <main>
        <section id="introducao" class="panel">
            <h2>Propósito</h2>
            <p>
                Este espaço organiza o processo de remake para pessoas iniciantes. Cada etapa apresenta objetivos claros,
                pré-requisitos amigáveis e materiais de apoio. A proposta é seguir um caminho lógico: primeiro compreender
                o cenário, depois preparar o ambiente, em seguida reconstruir o cliente <em>Main</em>, adaptar sistemas na
                <strong>Unreal Engine 5</strong> e finalizar com a estrutura do servidor dedicado.
            </p>
            <div class="callouts">
                <p class="callout callout--tip"><strong>Dica:</strong> Leia cada etapa como se fosse uma receita. Quando um termo
                    parecer complicado, volte ao glossário antes de continuar.</p>
                <p class="callout callout--warning"><strong>Importante:</strong> Sempre faça backup dos arquivos originais
                    antes de editar qualquer asset ou código. Use o Git para registrar cada vitória.</p>
            </div>
            <div class="grid">
                <article class="card">
                    <h3>Como usar</h3>
                    <p>
                        Avance na ordem sugerida. A conclusão de um módulo libera o próximo e reduz dúvidas quando chegar
                        o momento de integrar cliente, Unreal Engine 5 e servidor.
                    </p>
                </article>
                <article class="card">
                    <h3>Perfil</h3>
                    <p>
                        Linguagem simples, focada em quem nunca programou. Sempre explique conceitos com o glossário e
                        marque dúvidas para serem revisitadas ao final de cada etapa.
                    </p>
                </article>
                <article class="card">
                    <h3>Metodologia</h3>
                    <p>
                        Baseada nas dependências reais do projeto original: preparar ferramentas, reaproveitar assets e
                        então sincronizar cliente, Unreal Engine e servidor por meio de passos incrementais.
                    </p>
                </article>
            </div>
        </section>

        <section id="tutorial-completo" class="panel panel--stepper">
            <h2>Tutorial passo a passo completo</h2>
            <p>
                Siga estes dez passos como se estivesse montando um móvel com instruções ilustradas. Cada item traduz o
                que acontece nos arquivos originais (<code>Source Main 5.2</code> e <code>Source MuServer Update 15</code>)
                para ações concretas dentro da <strong>Unreal Engine 5</strong>, sempre reutilizando os assets do cliente
                clássico.
            </p>
            <div class="callouts">
                <p class="callout callout--tip"><strong>Como ler:</strong> execute os passos em ordem. Ao terminar um
                    bloco, marque a checklist antes de seguir adiante.</p>
                <p class="callout callout--warning"><strong>Priorize a documentação:</strong> use o diário de bordo para
                    anotar qualquer termo novo. A meta é não depender de outra fonte além deste guia.</p>
            </div>
            <ol class="stepper">
                <li>
                    <h3>Passo 1 — Preparar o ambiente sem medo de código</h3>
                    <p class="stepper__goal">Instale e organize as ferramentas que abrirão os arquivos originais e a
                        Unreal Engine 5.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>Baixe e instale o <strong>Visual Studio 2019</strong>. No instalador, marque “Desktop
                                development with C++”, “MSVC v142” e “Windows 10 SDK”.</li>
                            <li>No <strong>Epic Games Launcher</strong>, instale a <strong>Unreal Engine 5.3</strong> (ou
                                mais recente) com suporte a C++.</li>
                            <li>Crie a pasta <code>C:\EnsinoRemake</code> e as subpastas <code>MainOriginal</code>,
                                <code>MuServer</code>, <code>UnrealProjeto</code> e <code>Documentos</code>.</li>
                            <li>Copie o conteúdo de <code>Source Main 5.2/</code> para <code>MainOriginal</code> e de
                                <code>Source MuServer Update 15/</code> para <code>MuServer</code>.</li>
                            <li>Abra um documento em branco (Google Docs, Notion ou caderno) chamado “Diário Ensino
                                Remake” com seções Cliente, Unreal e Servidor.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Como isso aparece no projeto original</h4>
                        <p>Os arquivos <code>Main.sln</code>, <code>ConnectServer.sln</code>, <code>JoinServer.sln</code>
                            e <code>GameServer.sln</code> foram pensados para o Visual Studio. Sem esse ambiente os
                            passos seguintes não carregam. A Unreal precisa da pasta organizada para gerar builds na
                            etapa 10.</p>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>O Visual Studio abre <code>MainOriginal/Main.sln</code> sem pedir componentes extras.</li>
                            <li>A Unreal Engine 5 abre com o template “Third Person” salvo em
                                <code>UnrealProjeto</code>.</li>
                            <li>Seu diário possui a primeira anotação listando ferramentas instaladas.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 2 — Separar e catalogar os assets originais</h3>
                    <p class="stepper__goal">Reaproveite texturas, fontes, sons e modelos do cliente clássico para
                        importar na Unreal.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>Abra <code>MainOriginal/source/Global Release/Data</code> e copie as pastas
                                <code>Interface</code>, <code>World</code>, <code>Sound</code> e <code>Local</code> para
                                <code>C:\EnsinoRemake\Documentos\AssetsOriginais</code>.</li>
                            <li>No projeto Unreal, crie em <code>Content</code> as pastas <code>UI</code>,
                                <code>Characters</code>, <code>Effects</code>, <code>Audio</code> e <code>Maps</code>.</li>
                            <li>Importe um exemplo de cada categoria (por exemplo
                                <code>Interface\Layout.tga</code>) apenas para validar a organização.</li>
                            <li>Monte uma planilha com colunas “Asset”, “Local original” e “Onde usar na Unreal”.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Como isso aparece no projeto original</h4>
                        <p><code>ZzzTexture.cpp</code> e <code>NewUIManager.cpp</code> carregam essas imagens através de
                            caminhos como <code>Data/Interface</code>. Quando você importar para a Unreal, usará os
                            mesmos arquivos para montar os Widgets descritos nos próximos passos.</p>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>Consegue localizar qualquer textura pelo nome na planilha.</li>
                            <li>O Content Browser da Unreal mostra pastas organizadas com ícones importados.</li>
                            <li>Os assets originais estão duplicados em um local seguro (backup).</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 3 — Fazer o tour guiado pelo cliente Main 5.2</h3>
                    <p class="stepper__goal">Ler os arquivos principais apenas para entender o que cada um controla.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>No Visual Studio, abra <code>Main.sln</code> e clique duas vezes em
                                <code>Winmain.cpp</code>. Use <kbd>Ctrl</kbd>+<kbd>F</kbd> para procurar
                                <code>g_pUIManager</code>.</li>
                            <li>Abra <code>NewUIManager.cpp</code>, <code>NewUIMainFrameWindow.cpp</code> e
                                <code>LoginWin.cpp</code> para observar como as janelas são criadas.</li>
                            <li>Leia <code>ProtocolSend.cpp</code> e marque onde aparece
                                <code>SendRequestLogInNew</code>. Essa função é a base do login.</li>
                            <li>Anote no diário qual arquivo controla música (dica: <code>PlayMp3</code> em
                                <code>Winmain.cpp</code>).</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>Winmain.cpp</code> inicia o jogo, cria <code>g_pTimer</code>, configura janelas e
                                chama <code>GameLoop</code>.</li>
                            <li><code>NewUIManager.cpp</code> adiciona e mostra interfaces como inventário e opções.</li>
                            <li><code>ProtocolSend::SendRequestLogInNew</code> prepara a mensagem de login com
                                <code>BuxConvert</code>, versão e serial.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>Consegue explicar em voz alta para que serve cada arquivo visitado.</li>
                            <li>Fez capturas de tela dos trechos citados e colou no diário com legendas simples.</li>
                            <li>Sabe onde buscar o fluxo de login, HUD e música no código.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 4 — Traduzir janelas e HUD para um roteiro visual</h3>
                    <p class="stepper__goal">Converter o comportamento das telas do cliente clássico em instruções que
                        qualquer pessoa consiga seguir.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>No Visual Studio, abra <code>NewUIMainFrameWindow.cpp</code> e anote cada chamada a
                                <code>LoadBitmap</code>. Registre o caminho completo citado pelo código (ex. <code>Interface\newui_menu01.jpg</code>,
                                <code>Interface\newui_menu_red.jpg</code>, <code>Interface\partCharge1\newui_menu03.jpg</code>) para saber exatamente
                                quais arquivos do diretório <code>Source Main 5.2/bin/Data/Interface</code> importar.</li>
                            <li>Use o roteiro de <code>ZzzTexture.cpp</code> para converter os pacotes:
                                <ul>
                                    <li>Para texturas <code>.OZJ</code>, descarte os primeiros 24 bytes e salve o restante como <code>.jpg</code>.</li>
                                    <li>Para texturas <code>.OZT</code>, descarte 16 bytes após o cabeçalho e salve como <code>.tga</code> (32 bits).</li>
                                    <li>Repita o processo com um conversor (por exemplo, 7-Zip + editor hexadecimal) e organize os arquivos
                                        convertidos em <code>Content/UI/HUD</code>.</li>
                                </ul>
                            </li>
                            <li>Na Unreal, crie o Widget <code>WB_HUDMain</code> com uma <em>Canvas Panel</em> 640×480 ancorada ao canto inferior.
                                Adicione três <em>Image</em> usando as texturas <code>newui_menu01.jpg</code>, <code>newui_menu02.jpg</code> e
                                <code>newui_menu03.jpg</code> posicionadas em (0,429), (256,429) e (384,429) respectivamente. Crie imagens para as
                                barras de HP/MP/AG/SD e vincule a largura das imagens a variáveis <code>PercentHP</code>, <code>PercentMP</code> etc.</li>
                            <li>Desenhe o minimapa copiando o comportamento de <code>NewUIMiniMap.cpp</code>: importe <code>Interface\WorldMap\MiniMap\</code>,
                                coloque um <em>Image</em> circular e um <em>Border</em> para moldura. Para o inventário, abra <code>NewUIInventoryCtrl.cpp</code>
                                e replique o grid 8×8 com uma <em>UniformGridPanel</em> (cada célula 32×32 px) e eventos de <em>Drag &amp; Drop</em>.</li>
                            <li>No cliente original (build antigo ou capturas), compare cada janela com o widget equivalente. Marque no diário onde
                                cada textura foi usada e registre a sequência Login &rarr; Seleção &rarr; HUD &rarr; Inventário &rarr; Loja.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>NewUIMainFrameWindow::CreateSubControl</code> monta as barras de HP/MP usando as
                                texturas de <code>Data/Interface</code>.</li>
                            <li><code>CNewUIInventoryCtrl::LoadImages</code> carrega cada célula do inventário com base em
                                <code>ZzzInventory.h</code>.</li>
                            <li><code>LoginWin.cpp</code> habilita botões e toca sons com <code>DSPlaySound</code>.</li>
                            <li><code>CNewUIMainFrameWindow::RenderStats</code> atualiza as barras chamando
                                <code>m_PlayerStatusBar.SetStatus()</code>; crie funções Blueprint que recebam valores de HP/MP e
                                atualizem os <em>Bindings</em> do Widget.</li>
                            <li><code>ZzzTexture::OpenJpeg</code> e <code>ZzzTexture::OpenTga</code> mostram como os arquivos
                                <code>.OZJ/.OZT</code> são convertidos; siga o mesmo offset ao exportar manualmente.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>Possui uma página do diário com fotos ou desenhos de cada tela.</li>
                            <li>Tem uma legenda simples explicando o que acontece quando o jogador clica em cada botão.</li>
                            <li>Consegue apontar quais texturas serão importadas para cada tela.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 5 — Configurar o projeto base na Unreal Engine 5</h3>
                    <p class="stepper__goal">Criar a estrutura que substituirá o loop e os gerenciadores do cliente
                        clássico.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>Abra a Unreal e crie o projeto C++ “EnsinoRemake” dentro de
                                <code>C:\EnsinoRemake\UnrealProjeto</code>.</li>
                            <li>No menu <strong>Tools &gt; New C++ Class</strong>, gere:
                                <ul>
                                    <li><code>UEnsinoRemakeGameInstance</code> (herda de <code>UGameInstance</code>) para
                                        iniciar serviços.</li>
                                    <li><code>UUIFlowSubsystem</code> (GameInstance Subsystem) para trocar telas.</li>
                                    <li><code>UNetworkBridgeSubsystem</code> para lidar com rede.</li>
                                </ul>
                            </li>
                            <li>Ative os plugins <em>Enhanced Input</em> e <em>Gameplay Tasks</em>.</li>
                            <li>Crie pastas <code>Blueprints</code>, <code>UI</code>, <code>Systems</code> e
                                <code>Network</code> dentro de <code>Content</code>.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>Winmain.cpp</code> &rarr; <code>UEnsinoRemakeGameInstance</code> controla o ciclo de
                                vida.</li>
                            <li><code>g_pUIManager</code> &rarr; <code>UUIFlowSubsystem</code> decide quais Widgets ficam na
                                tela.</li>
                            <li><code>ProtocolSend.cpp</code> &rarr; <code>UNetworkBridgeSubsystem</code> envia e recebe
                                pacotes.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>O projeto compila com sucesso (menu <strong>Build</strong> da Unreal ou Visual Studio).</li>
                            <li>Os Subsystems aparecem no <strong>Output Log</strong> ao clicar em <strong>Play</strong>.</li>
                            <li>Há uma anotação no diário mapeando cada classe nova ao arquivo original.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 6 — Recriar login e seleção de personagens</h3>
                    <p class="stepper__goal">Transformar o fluxo clássico de botões em Widgets amigáveis.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>No Content Browser, crie os Widgets <code>WB_LoginMenu</code>,
                                <code>WB_SelectCharacter</code> e <code>WB_ServerStatus</code>.</li>
                            <li>Arraste as texturas importadas (background, botões) para cada Widget e configure estados de
                                hover/pressed com imagens <code>newui_menu_Bt01.OZJ</code>, <code>newui_menu_Bt02.OZJ</code> e
                                <code>newui_menu_Bt03.OZJ</code> convertidas para <code>.jpg</code>.</li>
                            <li>No <code>WB_LoginMenu</code>, adicione campos de texto e um botão “Conectar”. No gráfico de
                                eventos, monte a sequência: validar campos &rarr; chamar <code>UUIFlowSubsystem::MostrarStatus</code>
                                &rarr; executar uma função <code>SolicitarLogin</code> no <code>UNetworkBridgeSubsystem</code>
                                passando versão, serial e hash iguais aos definidos em <code>ProtocolSend::SendRequestLogInNew</code>.</li>
                            <li>No <code>WB_SelectCharacter</code>, use um <em>ListView</em> para listar personagens.
                                Preencha com dados fictícios (nome, classe) antes de conectar ao servidor, crie botões “Criar” e
                                “Deletar” que apenas exibem mensagens enquanto o backend não estiver ligado e invoque
                                <code>SolicitarEntradaNoJogo</code> quando o usuário clicar em “Entrar”.</li>
                            <li>No <code>UUIFlowSubsystem</code>, registre funções <code>MostrarLogin</code>,
                                <code>MostrarSelecao</code> e <code>MostrarHUD</code> que trocam widgets usando
                                <code>AddToViewport</code>/<code>RemoveFromParent</code>, reproduzindo a lógica de foco de
                                <code>g_pNewUISystem-&gt;Show</code>.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>LoginWin.cpp</code> chama <code>ProtocolSend::SendRequestLogInNew</code> quando o
                                botão é pressionado.</li>
                            <li><code>CharSelMainWin.cpp</code> carrega a lista de personagens e destaca o selecionado.</li>
                            <li><code>GlobalText[472]</code> e <code>GlobalText[473]</code> são mensagens de “aguarde”. Use
                                o mesmo texto no Widget.</li>
                            <li><code>NewUIButton.cpp</code> demonstra como estados de botões usam texturas alternadas —
                                replique isso com o <em>Button Style</em> do UMG.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>Clicar em “Conectar” mostra uma animação ou mensagem de carregamento.</li>
                            <li>O Widget de seleção troca entre personagens fictícios sem erros.</li>
                            <li>Existe um botão “Voltar” que retorna ao login (como no cliente clássico).</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 7 — Montar personagem, câmeras e interações</h3>
                    <p class="stepper__goal">Replicar movimentação, animações e câmera baseados no código clássico.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>Crie o Blueprint <code>BP_RemakeCharacter</code> herdando de <code>Character</code> e
                                substitua o personagem padrão.</li>
                            <li>No <code>Enhanced Input</code>, crie ações <code>IA_Move</code>, <code>IA_Look</code>,
                                <code>IA_Attack</code> e <code>IA_Action</code>. Ligue aos eventos do Blueprint.</li>
                            <li>Importe animações do cliente ou placeholders e configure um <code>Animation Blueprint</code>
                                para alternar entre idle, corrida e ataque.</li>
                            <li>Adicione uma câmera principal com <code>SpringArm</code> e ajuste zoom para imitar
                                <code>CameraMove.cpp</code>.</li>
                            <li>No componente <code>CharacterMovement</code>, copie limites de velocidade de
                                <code>CharacterMoveSpeed</code> ajustando <code>MaxWalkSpeed</code> para a média registrada no
                                diário (ex.: 350 UU/s) e habilite <em>Use Controller Desired Rotation</em> para sincronizar com
                                a câmera.</li>
                            <li>Crie funções <code>EnviarMovimento</code> e <code>EnviarAtaque</code> no
                                <code>UNetworkBridgeSubsystem</code> que serializam posição (<code>FVector_NetQuantize</code>) e
                                usam a mesma estrutura de <code>ProtocolHead::BOTH_MOVE</code>/<code>BOTH_MESSAGE</code> vista em
                                <code>ProtocolSend::SendCharacterMoveNew</code> e nos pacotes de ataque documentados em
                                <code>Protocol.cpp</code>.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>ZzzCharacter.cpp</code> define velocidades e animações usadas pelo personagem.</li>
                            <li><code>MouseProc.cpp</code> e <code>CameraMove.cpp</code> controlam zoom e rotação do mouse.</li>
                            <li><code>ProtocolSend::SendPositionNew</code> envia coordenadas X/Y a cada movimento.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>O personagem se move, gira e ataca dentro do mapa de teste.</li>
                            <li>A câmera respeita limites de zoom similares ao cliente clássico.</li>
                            <li>As ações disparam eventos de log (usando <code>Print String</code>) para futura ligação com a rede.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 8 — Construir a ponte de rede compatível</h3>
                    <p class="stepper__goal">Enviar e receber pacotes iguais aos do cliente clássico para conversar com o MuServer.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>Adicione uma classe C++ <code>UNetworkBridge</code> (instanciada pelo Subsystem) que usa
                                <code>FSocket</code> para abrir conexão TCP.</li>
                            <li>Implemente métodos <code>EnviarLogin</code>, <code>SolicitarListaDePersonagens</code> e
                                <code>EnviarMovimento</code> copiando o formato de <code>ProtocolSend.cpp</code>.</li>
                            <li>Crie uma função utilitária <code>ApplyBuxConvert</code> reproduzindo a lógica de
                                <code>BuxConvert</code> (troca de bytes) antes de mandar usuário e senha.</li>
                            <li>Use <code>AsyncTask(ENamedThreads::AnyBackgroundThreadNormalTask, ...)</code> para ler
                                pacotes continuamente e repassar eventos ao <code>UUIFlowSubsystem</code>.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>CProtocolSend::SendRequestLogInNew</code> monta o pacote de login (cabeçalho C1,
                                tamanho, conta, senha, versão).</li>
                            <li><code>WSclient.cpp</code> mantém a conexão viva e trata desconexões.</li>
                            <li><code>JoinServer/JoinServerProtocol.cpp</code> (<code>GJConnectAccountRecv</code>) valida os dados.</li>
                            <li><code>GameServer/GameServer/Protocol.cpp</code> (<code>case 0x1B</code>) processa movimento e deve receber exatamente os mesmos bytes.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>Os logs da Unreal mostram os pacotes hexadecimais enviados e recebidos.</li>
                            <li>Um comando <code>Telnet</code> ou <code>Wireshark</code> confirma que o cabeçalho C1 foi enviado.</li>
                            <li>O Subsystem informa erros amigáveis quando o servidor está offline.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 9 — Subir o MuServer e validar a comunicação</h3>
                    <p class="stepper__goal">Executar ConnectServer, JoinServer, GameServer e DataServer aceitando o novo cliente.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>No Visual Studio, abra cada solução (<code>ConnectServer.sln</code>, <code>JoinServer.sln</code>, <code>GameServer.sln</code>, <code>DataServer.sln</code>) e compile em <em>Release</em>.</li>
                            <li>Edite os arquivos <code>*.ini</code> para usar <code>127.0.0.1</code> como endereço IP e portas padrão (44405, 55901, 55960).</li>
                            <li>Inicie os serviços nessa ordem: ConnectServer &rarr; JoinServer &rarr; GameServer &rarr; DataServer.</li>
                            <li>Observe os consoles. Mensagens como “Account logged with global password” aparecem em <code>JoinServerProtocol.cpp</code> quando o login é aceito.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>GameServer/GameServer/GameMain.cpp</code> cria conexões com JoinServer e DataServer.</li>
                            <li><code>JoinServerProtocol::GJConnectAccountRecv</code> confirma contas com o banco.</li>
                            <li><code>DataServer/DataServer/DataServerProtocol.cpp</code> grava inventário e personagens.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>Todos os serviços mostram “Connected” e “listening” nos consoles.</li>
                            <li>O log do JoinServer registra a conta de teste criada no banco.</li>
                            <li>A Unreal tenta logar e recebe resposta (mesmo que mensagem de erro) do JoinServer.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 10 — Testar, ajustar e documentar</h3>
                    <p class="stepper__goal">Comparar comportamento entre cliente clássico e remake, registrando melhorias.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>Execute os quatro serviços do MuServer e abra o cliente Unreal. Faça login com a conta de teste.</li>
                            <li>Movimente o personagem e verifique no console do GameServer se <code>case 0x1B</code> registra as posições.</li>
                            <li>Abra o inventário e confirme no DataServer se a tabela <code>Warehouse</code> recebe atualizações.</li>
                            <li>Anote no diário erros encontrados e como reproduzi-los.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>Protocol.cpp</code> envia atualizações para <code>gGameServerLogOut</code> quando a conexão cai.</li>
                            <li><code>DataServerProtocol::GDCharacterListRecv</code> devolve a lista de personagens.</li>
                            <li><code>NewUIInventoryCtrl.cpp</code> define como itens aparecem; compare com o Widget Unreal.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>Existe um registro completo de testes no diário (data, ação, resultado).</li>
                            <li>Você consegue repetir o login, seleção e entrada no mapa sem consultar outras fontes.</li>
                            <li>Tem uma lista de próximas melhorias (efeitos, eventos) priorizada.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 11 — Movimentação e câmera idênticas</h3>
                    <p class="stepper__goal">Reproduzir a sensação de controle original ajustando velocidade, animações e sincronização de posição.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>No Unreal, ajuste o <code>CharacterMovement</code> para <code>Max Walk Speed = 550</code> e <code>Rotation Rate = 720</code>, igual aos valores observados em <code>gObjCalCharacter</code>.</li>
                            <li>Implemente um <code>UMovementCommandComponent</code> que converta entradas WASD em direções de grade (8 direções) como <code>MoveCommand.cpp</code> faz com <code>PathFindMoveMsg</code>.</li>
                            <li>Ao pressionar uma direção, chame <code>UNetworkBridgeSubsystem::EnviarMovimento</code> (código 0x1B) e aguarde a confirmação 0x1C antes de mover definitivamente o personagem.</li>
                            <li>Sincronize a câmera com um <code>SpringArm</code> com <code>Lag</code> configurado para 0.15 e altura 420 replicando o offset definido em <code>ZzzCharacter.cpp</code>.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>Source Main 5.2/source/MoveCommand.cpp</code> limita direções válidas e calcula passos.</li>
                            <li><code>Source Main 5.2/source/ProtocolSend.cpp</code> envia <code>SendRequestMove</code> com direção.</li>
                            <li><code>Source MuServer Update 15/GameServer/GameServer/Protocol.cpp</code> trata <code>case 0x1B/0x1C</code> confirmando posição e corrige desvios.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>O personagem só conclui o passo após receber 0x1C e corrige automaticamente se houver diferença.</li>
                            <li>A câmera acompanha suavemente sem tremores tanto no cliente clássico quanto no remake.</li>
                            <li>O console do GameServer mostra as mesmas direções registradas em <code>MoveCommand.cpp</code>.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 12 — Combate básico e habilidades</h3>
                    <p class="stepper__goal">Replicar ataques, combos e lançamento de magias respeitando confirmações do servidor.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>Crie um <code>UCombatComponent</code> com funções <code>SolicitarAtaqueBasico</code> e <code>SolicitarHabilidade</code> chamando códigos 0x11 e 0x19, como em <code>ProtocolSend.cpp</code>.</li>
                            <li>Monte animações no Unreal usando <em>Montages</em> iguais aos estados listados em <code>NewCharacterModel.cpp</code> (Idle, Walk, Attack1, Attack2).</li>
                            <li>Registre tabelas <code>DT_Skills</code> com dano, custo e efeitos copiando de <code>SkillAttribute.cpp</code>.</li>
                            <li>Quando o GameServer responder com 0x1A/0x1B (confirmação de dano), atualize HUD, efeitos e números flutuantes.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>Source Main 5.2/source/SkillManager.cpp</code> valida mana, alcance e tempo de recarga.</li>
                            <li><code>Source MuServer Update 15/GameServer/GameServer/Attack.cpp</code> calcula o dano real.</li>
                            <li><code>Protocol.cpp</code> reenvia 0x11/0x19 confirmando acertos para todos os jogadores.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>Ataques básicos tocam o mesmo som e consomem stamina como no cliente clássico.</li>
                            <li>Habilidades respeitam cooldowns e exibem partículas equivalentes aos efeitos originais.</li>
                            <li>O servidor valida dano e envia número final antes de aplicar no HUD.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 13 — NPCs, missões e economia</h3>
                    <p class="stepper__goal">Recriar diálogos, lojas, quests e recompensas conectadas ao banco de dados.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>Cadastre NPCs em <code>DT_NPCs</code> com ID, nome, diálogo e itens usando <code>Data/NPC.txt</code> como referência.</li>
                            <li>Implemente <code>WB_Dialogue</code> exibindo as frases mapeadas em <code>NewNPCDialog.cpp</code> com botões “Comprar”, “Quest”, “Fechar”.</li>
                            <li>Replique o fluxo de quests lendo <code>QuestInfo.cpp</code> e criando um <code>UQuestComponent</code> que sincroniza progresso com pacotes 0x7A/0x7B.</li>
                            <li>Integre com o DataServer chamando procedures equivalentes a <code>GDSaveQuestProgress</code> e atualizando Zen via <code>GDShopLogSave</code>.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>Source Main 5.2/source/NewUINPCShop.cpp</code> e <code>QuestInfoWindow.cpp</code> definem layout e botões.</li>
                            <li><code>Source MuServer Update 15/GameServer/GameServer/Quest.cpp</code> processa estados e recompensas.</li>
                            <li><code>DataServer/DataServer/DataServerProtocol.cpp</code> grava compras, Zen e etapas concluídas.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>NPCs abrem janelas idênticas às do cliente clássico, com os mesmos itens e preços.</li>
                            <li>Quests atualizam objetivos automaticamente quando monstros são derrotados.</li>
                            <li>O Zen descontado ou ganho aparece tanto na Unreal quanto no banco após recarregar.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 14 — Mundo, monstros e eventos ao vivo</h3>
                    <p class="stepper__goal">Montar mapas, spawns e scripts de eventos como Blood Castle dentro da Unreal.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>Importe os mapas usando <code>World Machine</code> ou <code>Heightmaps</code> gerados de <code>World\Terrain</code>, aplicando texturas originais.</li>
                            <li>Cadastre spawns em <code>DT_Monsters</code> com posição e tempo de respawn baseando-se em <code>MonsterSetBase.txt</code>.</li>
                            <li>Implemente <code>Behavior Trees</code> para IA seguindo padrões de <code>MonsterAI.cpp</code> (perseguir, atacar, retornar).</li>
                            <li>Crie controladores de evento (Blueprint Actor) que leem arquivos de configuração como <code>BloodCastle.txt</code> e disparam timers iguais aos do <code>Event.cpp</code>.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>Source Main 5.2/source/ZzzScene.cpp</code> carrega mapas e define zona segura.</li>
                            <li><code>Source MuServer Update 15/GameServer/GameServer/MonsterAI.cpp</code> controla lógica de perseguição.</li>
                            <li><code>GameServer/GameServer/Event.cpp</code> agenda Blood Castle, Devil Square e outros.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>Monstros reaparecem nas mesmas coordenadas e respeitam limites de agressão.</li>
                            <li>Eventos iniciam e encerram com mensagens iguais às do cliente clássico.</li>
                            <li>O minimapa e o HUD mostram indicadores de objetivo atual do evento.</li>
                        </ul>
                    </div>
                </li>
                <li>
                    <h3>Passo 15 — Publicação, QA e suporte</h3>
                    <p class="stepper__goal">Empacotar build, documentar testes e preparar suporte contínuo.</p>
                    <div class="stepper__details">
                        <h4>Faça assim</h4>
                        <ul>
                            <li>Gere build <em>Shipping</em> no Unreal configurando <code>Project Settings &rarr; Packaging</code> para copiar assets convertidos automaticamente.</li>
                            <li>Crie scripts <code>StartAll.bat</code> e <code>StopAll.bat</code> para os serviços do MuServer com logs direcionados para <code>logs/</code>.</li>
                            <li>Documente plano de testes repetível (login, evento, trade) usando modelos de <code>TestCases.xlsx</code> disponíveis neste guia.</li>
                            <li>Monte pasta “Distribuição” com build, scripts, banco e este tutorial em PDF para novos testers.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--explain">
                        <h4>Tradução do código original</h4>
                        <ul>
                            <li><code>GameServer/GameServer/LogProc.cpp</code> mostra formato ideal de logs para replicar no Unreal.</li>
                            <li><code>Source Main 5.2/source/CrashHandler.cpp</code> registra erros — use abordagens parecidas com <code>Unreal Insights</code>.</li>
                            <li><code>Tools/Launcher</code> no pacote original inspiram scripts de distribuição.</li>
                        </ul>
                    </div>
                    <div class="stepper__details stepper__details--checklist">
                        <h4>Você termina quando...</h4>
                        <ul>
                            <li>Existe um pacote zipado com build Unreal, executáveis do servidor e scripts.</li>
                            <li>Qualquer pessoa consegue seguir o plano de testes sem ajuda externa.</li>
                            <li>Logs são armazenados em pastas datadas, facilitando suporte e correções.</li>
                        </ul>
                    </div>
                </li>
            </ol>
            <div class="table-wrapper table-wrapper--compact">
                <table class="data-table data-table--mapping">
                    <caption>Mapa rápido entre arquivos clássicos e componentes da Unreal</caption>
                    <thead>
                        <tr>
                            <th>Elemento original</th>
                            <th>Onde encontrar</th>
                            <th>Como refazer na Unreal 5</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Loop principal do cliente</td>
                            <td><code>Source Main 5.2/source/Winmain.cpp</code></td>
                            <td><code>UEnsinoRemakeGameInstance</code> + <code>GameInstanceSubsystems</code> que inicializam serviços.</td>
                        </tr>
                        <tr>
                            <td>Gerenciador de janelas</td>
                            <td><code>Source Main 5.2/source/NewUIManager.cpp</code></td>
                            <td><code>UUIFlowSubsystem</code> controlando <em>Widget Blueprints</em> (login, HUD, inventário).</td>
                        </tr>
                        <tr>
                            <td>HUD principal</td>
                            <td><code>Source Main 5.2/source/NewUIMainFrameWindow.cpp</code></td>
                            <td>Widgets <code>WB_HUDMain</code> + <code>AHUD</code> customizado com barras, minimapa e mensagens.</td>
                        </tr>
                        <tr>
                            <td>Inventário e slots</td>
                            <td><code>Source Main 5.2/source/NewUIInventoryCtrl.cpp</code></td>
                            <td><code>UInventoryComponent</code> replicado + <code>WB_Inventory</code> com grade e drag &amp; drop.</td>
                        </tr>
                        <tr>
                            <td>Envio de pacotes</td>
                            <td><code>Source Main 5.2/source/ProtocolSend.cpp</code></td>
                            <td><code>UNetworkBridgeSubsystem</code> + funções <code>EnviarLogin</code>, <code>EnviarMovimento</code> com <code>FSocket</code>.</td>
                        </tr>
                        <tr>
                            <td>Tratamento de login no servidor</td>
                            <td><code>Source MuServer Update 15/JoinServer/JoinServer/JoinServerProtocol.cpp</code></td>
                            <td>Método <code>OnLoginResponse</code> no Subsystem validando códigos de retorno 0x01/0x02.</td>
                        </tr>
                        <tr>
                            <td>Movimento e ações do servidor</td>
                            <td><code>Source MuServer Update 15/GameServer/GameServer/Protocol.cpp</code></td>
                            <td>Handlers no <code>UNetworkBridgeSubsystem</code> convertendo bytes em eventos (andar, atacar).</td>
                        </tr>
                        <tr>
                            <td>Salvamento no banco de dados</td>
                            <td><code>Source MuServer Update 15/DataServer/DataServer/DataServerProtocol.cpp</code></td>
                            <td>Chamadas a stored procedures via DataServer + scripts SQL documentados no diário.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section id="modulos" class="panel">
            <h2>Módulos Essenciais para Iniciantes</h2>
            <p>Use estes módulos como base para montar uma rotina de estudos e prática.</p>
            <div class="module-grid">
                <article class="card card--module">
                    <h3>Fundamentos de Computação</h3>
                    <ul>
                        <li>Aprenda a criar pastas, mover arquivos e usar um editor de texto.</li>
                        <li>Entenda o que é um <strong>repositório Git</strong> e por que usamos controle de versão.</li>
                        <li>Revise o conceito de <em>compilar</em> versus <em>executar</em>.</li>
                    </ul>
                </article>
                <article class="card card--module">
                    <h3>Primeiros passos em C++</h3>
                    <ul>
                        <li>Execute exemplos simples em Visual Studio 2019.</li>
                        <li>Pratique variáveis, estruturas condicionais e funções.</li>
                        <li>Leia <code>Winmain.cpp</code> e arquivos de cabeçalho em <code>Source Main 5.2/source</code> apenas
                            para observar a sintaxe.</li>
                    </ul>
                </article>
                <article class="card card--module">
                    <h3>Unreal Engine 5 para Iniciantes</h3>
                    <ul>
                        <li>Instale via Epic Games Launcher com os módulos de <strong>C++</strong>.</li>
                        <li>Assista ao tutorial “First Hour in Unreal Engine 5” para navegar no editor.</li>
                        <li>Crie um projeto vazio baseado no template <em>Third Person</em> para testes.</li>
                    </ul>
                </article>
                <article class="card card--module">
                    <h3>Fluxo de Rede do Mu Online</h3>
                    <ul>
                        <li>Desenhe um mapa simples conectando cliente &rarr; ConnectServer &rarr; JoinServer &rarr; GameServer.</li>
                        <li>Identifique onde o inventário e o login são processados no código original.</li>
                        <li>Marque quais pacotes precisarão ser refeitos no remake.</li>
                    </ul>
                </article>
                <article class="card card--module">
                    <h3>Banco de Dados e Ferramentas</h3>
                    <ul>
                        <li>Instale o SQL Server Express ou MariaDB para simular o armazenamento do MuServer.</li>
                        <li>Pratique consultas básicas com tabelas de exemplo, como <code>Character</code> e <code>Account</code>.</li>
                        <li>Configure um script de backup automático para não perder progresso.</li>
                    </ul>
                </article>
                <article class="card card--module">
                    <h3>Lógica Visual e Blueprints</h3>
                    <ul>
                        <li>Recrie um contador com botões no Blueprint para entender eventos e variáveis.</li>
                        <li>Experimente o sistema de <em>Enhanced Input</em> para ligar teclado, mouse e gamepad.</li>
                        <li>Importe uma textura do Main e use-a em um Widget para praticar fluxo de assets.</li>
                    </ul>
                </article>
            </div>
        </section>

        <section id="mapa-codigo" class="panel">
            <h2>Mapa do Código Original</h2>
            <p>
                Esta visão geral funciona como um GPS. Repare nos nomes das pastas e arquivos porque cada etapa do tutorial
                citará esses pontos de referência. Explore-os em modo de leitura antes de alterar qualquer linha.
            </p>
            <div class="map-grid">
                <article class="card card--map">
                    <h3>Main 5.2 (Cliente)</h3>
                    <ul>
                        <li><code>Source Main 5.2/source/Winmain.cpp</code> &mdash; controla o loop principal do jogo.</li>
                        <li><code>Source Main 5.2/source/NewUIMainFrameWindow.cpp</code> &mdash; monta o HUD clássico.</li>
                        <li><code>Source Main 5.2/source/LoginWin.cpp</code> &mdash; fluxo da tela de login com botões e caixas.</li>
                        <li><code>Source Main 5.2/source/ProtocolSend.cpp</code> &amp; <code>WSclient.cpp</code> &mdash; enviam e recebem pacotes.</li>
                        <li><code>Source Main 5.2/Global Release/Data/</code> &mdash; texturas, fontes e sons que serão importados.</li>
                    </ul>
                </article>
                <article class="card card--map">
                    <h3>MuServer Update 15</h3>
                    <ul>
                        <li><code>Source MuServer Update 15/ConnectServer/ConnectServer.cpp</code> &mdash; primeira porta de entrada dos clientes.</li>
                        <li><code>Source MuServer Update 15/JoinServer/JoinServer.cpp</code> &mdash; valida usuários e repassa para o GameServer.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/GameMain.cpp</code> &mdash; inicializa os mapas e eventos.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/JSProtocol.cpp</code> &mdash; interpreta pacotes da Unreal.</li>
                        <li><code>Source MuServer Update 15/DataServer/DataServer/DataServerProtocol.cpp</code> &mdash; conversa com o banco de dados.</li>
                    </ul>
                </article>
                <article class="card card--map">
                    <h3>Ferramentas Utilitárias</h3>
                    <ul>
                        <li><code>tools/</code> &mdash; scripts auxiliares para builds e importação de assets.</li>
                        <li><code>unreal_recreation_plan.html</code> &mdash; visão macro da migração para Unreal.</li>
                        <li><code>inventory_unreal_inventory_system.html</code> &mdash; referência para o remake do inventário.</li>
                        <li><code>sprite_hud_explanation.html</code> &mdash; detalhes sobre sprites usados na interface.</li>
                        <li>Documentos extras ajudam a tirar dúvidas sem mergulhar direto no código.</li>
                    </ul>
                </article>
            </div>
        </section>

        <section id="cliente-detalhado" class="panel">
            <h2>Cliente Main 5.2 em Detalhes</h2>
            <p>
                Use esta seção como manual definitivo. Cada bloco descreve partes críticas do cliente clássico e explica
                como traduzir o comportamento para o remake na Unreal. Leia com calma e marque no diário de bordo quando
                cada item estiver compreendido ou reproduzido.
            </p>
            <div class="guide-grid">
                <article class="guide-card">
                    <h3>Boot, janelas e áudio</h3>
                    <p>
                        <code>Winmain.cpp</code> centraliza a inicialização: importa gerenciadores de UI, cenas, modelos,
                        áudio e rede, ativa o temporizador global <code>g_pTimer</code> e expõe utilitários como
                        <code>PlayMp3</code>/<code>StopMp3</code> usando <code>wzAudio.lib</code>. Esse arquivo mostra a
                        ordem de carga e serve de referência para a sequência do seu <em>GameInstance</em> na Unreal.
                    </p>
                    <ul>
                        <li>Liste todos os cabeçalhos incluídos em <code>Winmain.cpp</code> para identificar dependências
                            diretas (renderização, inventário, login, efeitos, som).</li>
                        <li>Repita a lógica de tocar e parar trilhas sonoras mapeando cada chamada <code>PlayMp3</code> para
                            <em>Audio Components</em> na Unreal com filas nomeadas.</li>
                        <li>Anote variáveis globais (por exemplo <code>g_pUIManager</code>, <code>g_hWnd</code>) e planeje
                            equivalentes seguros em C++/Blueprint (subsystems, singletons controlados).</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Gestão de UI e janelas</h3>
                    <p>
                        O gerenciador <code>CNewUIManager</code> mantém uma lista ordenada de janelas, processa eventos de
                        mouse/teclado e garante que apenas a interface ativa consuma entrada. Entenda como os métodos
                        <code>AddUIObj</code>, <code>UpdateMouseEvent</code> e <code>UpdateKeyEvent</code> definem a
                        hierarquia para recriar a mesma fila de foco com <em>Widget Switchers</em> e subsistemas de UI.
                    </p>
                    <ul>
                        <li>Mapeie chaves (<code>dwKey</code>) usadas em <code>AddUIObj</code> para saber quais telas devem
                            existir no remake (login, inventário, loja, HUD).</li>
                        <li>Traduza a lógica de ordenação (<code>CompareLayerDepthReverse</code>) para camadas e <em>Z-order</em>
                            no <em>UMG</em>.</li>
                        <li>Implemente na Unreal um serviço de UI que troque widgets imitando <code>RemoveUIObj</code> e
                            <code>RemoveAllUIObjs</code>, garantindo limpeza entre níveis.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>HUD, inventário e itens</h3>
                    <p>
                        <code>NewUIMainFrameWindow.cpp</code> monta o HUD, enquanto <code>NewUIInventoryCtrl.cpp</code>
                        gerencia slots, itens arrastados e interações de mouse. Observe como o inventário duplica itens,
                        calcula posição pela grade e consulta <code>ItemAttribute</code> para tamanho e regras especiais.
                    </p>
                    <ul>
                        <li>Registre tamanhos e offsets de cada slot para construir um grid idêntico no widget
                            <code>WB_Inventory</code>.</li>
                        <li>Documente como <code>CNewUIPickedItem</code> move itens com base no mouse para espelhar o fluxo
                            com <em>Drag &amp; Drop</em> do UMG.</li>
                        <li>Separe texturas em <code>Global Release/Data/Interface</code> e conecte-as às mesmas categorias
                            (armas, armaduras, jóias) antes da importação.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Personagens, efeitos e câmera</h3>
                    <p>
                        As funções de <code>ZzzCharacter.h</code> criam heróis, monstros e helpers, calculam velocidade e
                        atualizam animações. Combine com os módulos de câmera/entrada para definir suas <em>Animation</em>
                        <em>Blueprints</em> e controladores de jogador na Unreal.</p>
                    <ul>
                        <li>Estude <code>CreateCharacter</code>, <code>SetPlayerAttack</code> e <code>CharacterMoveSpeed</code>
                            para derivar estados de máquina e velocidades padrões.</li>
                        <li>Liste efeitos ligados a armas, ataques e buffs para decidir quais migrar para Niagara logo no
                            início.</li>
                        <li>Replique a lógica de <code>ClientSendMoveCharacter</code>/<code>ClientSendPositionPacket</code>
                            como RPCs confiáveis ou <em>replicated moves</em> na Unreal.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Rede e protocolos do cliente</h3>
                    <p>
                        <code>ProtocolSend.cpp</code> mostra como o cliente se conecta, envia login, sincroniza posição e
                        repassa pacotes ao tradutor. Cada case do <code>switch</code> revela os cabeçalhos e formatos que a
                        Unreal deve produzir.</p>
                    <ul>
                        <li>Liste todos os <code>ProtocolHead::</code> usados nos cases e crie enums equivalentes.</li>
                        <li>Observe como <code>SendRequestLogInNew</code> aplica <code>BuxConvert</code> e adiciona versão para
                            reproduzir a mesma serialização.</li>
                        <li>Implemente logs no remake inspirados no console <code>g_ConsoleDebug</code> para depurar pacotes.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Ferramentas e depuração</h3>
                    <p>
                        Vários módulos adicionais (por exemplo <code>./Utilities/Log/</code>, <code>CrashReporter.h</code>)
                        cuidam de relatórios e depuração. Recrie ferramentas equivalentes para registrar problemas no
                        remake, principalmente durante testes em rede.</p>
                    <ul>
                        <li>Implemente logs estruturados (arquivo + canal) inspirados no <code>g_ConsoleDebug</code>.</li>
                        <li>Adapte o comportamento do <code>CrashReporter</code> para capturar falhas da Unreal (use o
                            <em>Crash Reporter</em> nativo ou plugins).</li>
                        <li>Documente flags globais como <code>g_bGameServerConnected</code> e aponte equivalentes em seu
                            <code>UGameInstance</code>.</li>
                    </ul>
                </article>
            </div>
            <div class="guide-notes">
                <h3>Checklist para considerar o cliente compreendido</h3>
                <ul>
                    <li>Você consegue explicar a ordem das chamadas principais em <code>Winmain.cpp</code> sem consultar o
                        código.</li>
                    <li>Consegue demonstrar a movimentação de um item no inventário original e repetir na Unreal.</li>
                    <li>Consegue listar quais pacotes o cliente envia ao logar, mover e atacar.</li>
                    <li>Consegue apontar qual arquivo de textura corresponde a cada elemento da HUD.</li>
                </ul>
            </div>
        </section>

        <section id="servidor-detalhado" class="panel">
            <h2>MuServer em Detalhes</h2>
            <p>
                O servidor clássico é dividido em serviços independentes. Esta seção explica responsabilidades, arquivos
                principais e o que deve ser adaptado para receber clientes criados na Unreal. Leia antes de iniciar qualquer
                ajuste de rede.
            </p>
            <div class="guide-grid">
                <article class="guide-card">
                    <h3>ConnectServer</h3>
                    <p>
                        Responsável por aceitar conexões iniciais, aplicar limitações por IP e devolver a lista de servidores.
                        O <code>WinMain</code> deste serviço carrega dados do <code>ConnectServer.ini</code>, inicia sockets
                        TCP/UDP e agenda timers para atualizar a UI administrativa.</p>
                    <ul>
                        <li>Replique a leitura de configurações (ports, <code>MaxIpConnection</code>) em arquivos <code>.ini</code>
                            próprios ou no banco.</li>
                        <li>Garanta que o remake na Unreal respeite as portas e o handshake esperados antes de contatar o
                            JoinServer.</li>
                        <li>Crie scripts para subir/derrubar o serviço e monitorar logs como o ConnectServer original faz.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>JoinServer &amp; autenticação</h3>
                    <p>
                        <code>JSProtocol.cpp</code> recebe pacotes do ConnectServer e repassa resultados ao GameServer. Ele
                        valida contas, bloqueios e troca códigos de autenticação para mudança de mapa.</p>
                    <ul>
                        <li>Implemente logs detalhados para cada case de <code>JoinServerProtocolCore</code> durante os testes
                            com a Unreal.</li>
                        <li>Confirme que o JoinServer envia <code>GCConnectAccountSend</code> com resultado 1 após validar a
                            conta e replique mensagens de erro para feedback amigável.</li>
                        <li>Documente requisitos de nível de conta (<code>AccountLevel</code>) e bloqueios para configurar seu
                            ambiente de testes.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>GameServer</h3>
                    <p>
                        <code>GameMain.cpp</code> inicializa o servidor de jogo: carrega monstros, tabelas de experiência,
                        conecta-se ao JoinServer e ao DataServer e agenda timers. O loop processa mensagens, atualiza objetos
                        e mantém a lista global <code>gObj</code>.</p>
                    <ul>
                        <li>Leia a sequência <code>GameMainInit</code> &rarr; <code>gObjInit</code> &rarr;
                            <code>gMonsterManager.SetMonsterData</code> para planejar dados que precisam existir antes de o
                            cliente Unreal se conectar.</li>
                        <li>Revise <code>JoinServerMsgProc</code> e <code>DataServerMsgProc</code> para entender como tratar
                            desconexões automaticamente.</li>
                        <li>Planeje como mapear <code>gObj</code> para suas estruturas replicadas, respeitando estados
                            <code>OBJECT_CONNECTED</code>/<code>OBJECT_LOGGED</code>/<code>OBJECT_PLAYING</code>.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Protocolos in-game</h3>
                    <p>
                        <code>Protocol.cpp</code> interpreta tudo que chega do cliente: chat, movimento, ataques, itens,
                        comércio, teleporte. Cada cabeçalho (<code>head</code>) dispara módulos especializados como
                        <code>gAttack</code>, <code>gItemManager</code> e <code>gSkillManager</code>.</p>
                    <ul>
                        <li>Monte uma tabela com cada <code>case</code> usado na sua primeira entrega (chat, movimento,
                            ataques básicos, inventário) e ignore temporariamente o restante.</li>
                        <li>Garanta que a Unreal envie o mesmo formato de pacote (C1/C3 ou C2/C4) antes de implementar novas
                            funcionalidades.</li>
                        <li>Ative logs para <code>PacketIN</code> até estabilizar o remake e desative depois para desempenho.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>DataServer e persistência</h3>
                    <p>
                        <code>DataServerProtocol.cpp</code> manipula listas de personagens, inventários, resets, quests e
                        armazém. Ele divide mensagens por subcabeçalhos para salvar/ler dados específicos.</p>
                    <ul>
                        <li>Mapeie quais chamadas impactam o inventário (<code>GDWarehouseItem</code>) e habilidades
                            (<code>GDMasterSkillTree</code>) para sincronizar com a Unreal.</li>
                        <li>Repita a lógica de <code>gServerManager[index].m_PacketTime</code> em suas ferramentas de
                            monitoramento para detectar travamentos.</li>
                        <li>Projete uma camada intermediária se decidir usar outro banco de dados (ORM, REST) mantendo o
                            formato dos pacotes.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Usuários e eventos</h3>
                    <p>
                        <code>User.cpp</code> e os diversos gerenciadores de evento controlam estados do jogador, arenas,
                        quests e loja. Mesmo que nem tudo seja implementado na primeira fase, consulte esses arquivos para
                        saber como o servidor clássico espera atualizar estatísticas.</p>
                    <ul>
                        <li>Liste variáveis globais (<code>gObjTotalUser</code>, <code>gObjOffStore</code>) e mantenha um
                            dashboard simples para compará-las com a Unreal.</li>
                        <li>Implemente instâncias base para Blood Castle e Castle Siege replicando triggers do GameServer e mantenha-as ativas nos testes de regressão.</li>
                        <li>Garanta que resets de sessão (<code>CloseClient</code>, <code>gObjAllDisconnect</code>) funcionem
                            mesmo quando o cliente for a Unreal.</li>
                    </ul>
                </article>
            </div>
            <div class="guide-notes">
                <h3>Checklist do servidor</h3>
                <ul>
                    <li>Você sabe qual serviço subir primeiro e quais portas abrir.</li>
                    <li>Você consegue reproduzir o fluxo de login completo com logs detalhados.</li>
                    <li>Você consegue explicar onde cada pacote é tratado (JoinServer, GameServer, DataServer).</li>
                    <li>Você possui scripts de start/stop e backup do banco validados.</li>
                </ul>
            </div>
        </section>

        <section id="unreal-detalhado" class="panel">
            <h2>Guia Unreal Detalhado</h2>
            <p>
                Agora que os sistemas originais foram dissecados, use esta seção para planejar o remake na Unreal Engine 5
                passo a passo. Cada bloco conecta arquivos C++ clássicos aos componentes equivalentes na Unreal.
            </p>
            <div class="guide-grid">
                <article class="guide-card">
                    <h3>Arquitetura do projeto</h3>
                    <p>
                        Estruture o projeto com módulos C++ (Core, NetworkBridge, UI) e camadas de Blueprint. Use um
                        <code>UGameInstance</code> para inicialização (equivalente a <code>Winmain.cpp</code>) e <em>Subsystems</em>
                        para serviços persistentes.</p>
                    <ul>
                        <li>Crie pastas <code>Content/UI</code>, <code>Content/Characters</code>, <code>Content/Maps</code> e
                            <code>Source/EnsinoRemake</code> com submódulos organizados.</li>
                        <li>Implemente um <code>UPrimaryGameLayout</code> ou <code>GameFeature</code> para controlar telas
                            equivalentes às janelas do <code>CNewUIManager</code>.</li>
                        <li>Configure <em>GameMode</em>, <em>PlayerController</em> e <em>HUD</em> específicos para login,
                            seleção e jogo.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Fluxo de login e seleção</h3>
                    <p>
                        Monte Widgets para login e seleção de personagens com validação. Crie <code>USTRUCTS</code> que
                        representem mensagens compatíveis com <code>ProtocolSend.cpp</code> e <code>JSProtocol.cpp</code>.</p>
                    <ul>
                        <li>Construa <code>WB_LoginMenu</code> com estados de carregamento e mensagens de erro reutilizáveis.</li>
                        <li>Implemente <code>WB_SelectCharacter</code> usando <em>ListView</em> e dados recebidos do servidor.</li>
                        <li>Crie uma fila de requisições para garantir uma mensagem por vez ao JoinServer.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Movimentação, combate e câmeras</h3>
                    <p>
                        Use <em>Enhanced Input</em> para mapear teclas/mouse, configure um <code>CharacterMovementComponent</code>
                        com valores de velocidade herdados de <code>ZzzCharacter</code> e implemente câmeras equivalentes ao
                        comportamento clássico.</p>
                    <ul>
                        <li>Crie ações para clique de movimentação, WASD e câmera livre.</li>
                        <li>Configure <em>Animation Montages</em> para ataques corpo a corpo e ranged, sincronizando com
                            pacotes de <code>Protocol.cpp</code>.</li>
                        <li>Utilize <em>Timeline</em> e <em>Camera Rigs</em> para replicar zoom/rotação do cliente original.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Inventário e HUD</h3>
                    <p>
                        Recrie o inventário com <em>Widget Blueprints</em>, <code>ActorComponents</code> replicados e tabelas
                        de dados. Sincronize com os pacotes do DataServer para persistência.</p>
                    <ul>
                        <li>Implemente <code>UInventoryComponent</code> com arrays bidimensionais para slots e funções de
                            validação.</li>
                        <li>Configure binding entre o componente e o <code>WB_Inventory</code>, incluindo arrastar/soltar.</li>
                        <li>Atualize o HUD com barras de HP/MP, minimapa e mensagens usando dados replicados do servidor.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Rede e serialização</h3>
                    <p>
                        Crie um módulo <code>NetworkBridge</code> em C++ usando sockets <code>FSocket</code>. Serializa pacotes
                        respeitando cabeçalhos C1/C3 e converta estruturas antigas para <code>UStruct</code> alinhados.</p>
                    <ul>
                        <li>Escreva funções utilitárias para BuxConvert, checksums e compressão conforme o cliente clássico.</li>
                        <li>Implemente threads ou <em>Async Tasks</em> para leitura contínua e filas de processamento.</li>
                        <li>Crie eventos <em>Delegates</em> para despachar respostas (login, lista de personagens, movimento).</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Builds, automação e QA</h3>
                    <p>
                        Configure <em>CI</em> local (scripts) para empacotar a Unreal e subir os serviços do MuServer. Documente
                        testes repetíveis para qualquer iniciante executar.</p>
                    <ul>
                        <li>Gere builds Development e Shipping e valide com a mesma base de dados usada pelo servidor.</li>
                        <li>Automatize cópia de <code>Global Release/Data</code> para a pasta <code>Content</code>.</li>
                        <li>Crie checklists de QA (login, spawn, ataque, desconexão) e peça feedback a outros estudantes.</li>
                    </ul>
                </article>
            </div>
        </section>

        <section id="receitas-unreal" class="panel panel--recipes">
            <h2>Receitas Unreal — Funções recriadas passo a passo</h2>
            <p>
                Utilize estas receitas como manuais de cozinha. Cada bloco indica exatamente quais arquivos do cliente
                e do servidor observar, quais assets converter e quais ações executar dentro da <strong>Unreal Engine 5</strong>
                para obter o mesmo resultado. Siga os passos na ordem e marque a checklist antes de continuar.
            </p>
            <div class="novice-toggle" role="group" aria-labelledby="novice-mode-label">
                <div class="novice-toggle__header">
                    <input type="checkbox" id="novice-mode-toggle" aria-describedby="novice-mode-description">
                    <label for="novice-mode-toggle" id="novice-mode-label">Ativar modo iniciante</label>
                </div>
                <p id="novice-mode-description">
                    Quando ligado, cada receita ganha um tutorial passo a passo explicando os cliques na Unreal, os
                    arquivos a abrir e como validar cada etapa — pensado para quem nunca programou.
                </p>
            </div>
            <div class="recipe-grid">
                <article class="recipe-card" data-recipe="receita-1">
                    <h3>Receita 1 — HUD principal idêntica</h3>
                    <p class="recipe-intro">Recompõe a barra inferior com HP/MP/AG/SD, minimapa e ícones exatamente como o
                        cliente clássico exibe.</p>
                    <h4>Ingredientes do clássico</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIMainFrameWindow.cpp</code> — observe as chamadas
                            <code>LoadBitmap</code> (texturas <code>Interface\newui_menu01.jpg</code>,
                            <code>Interface\newui_menu_red.jpg</code>, <code>Interface\partCharge1\newui_menu03.jpg</code>)
                            e funções <code>RenderFrame</code>/<code>RenderStats</code>.</li>
                        <li><code>Source Main 5.2/source/NewUIMiniMap.cpp</code> — identifica texturas de moldura
                            (<code>Interface\WorldMap\MiniMap</code>) e atualização do ponto do jogador.</li>
                        <li><code>Source Main 5.2/source/ZzzTexture.cpp</code> — explica como converter arquivos
                            <code>.OZJ/.OZT</code> em <code>.jpg/.tga</code> removendo 24 ou 16 bytes iniciais.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Converta as texturas citadas (use qualquer editor hexadecimal para descartar o cabeçalho) e
                            importe tudo para <code>Content/UI/HUD</code>.</li>
                        <li>Crie o Widget <code>WB_HUDMain</code> com <em>Canvas Panel</em> 640×480. Adicione três imagens
                            base posicionadas em (0,429), (256,429) e (384,429). Sobreponha imagens menores para barras e
                            configure <em>Size Box</em> para que a largura varie conforme porcentagens.</li>
                        <li>Crie um <code>Widget Blueprint</code> separado (<code>WB_Minimap</code>) com textura circular e
                            máscara. Adicione ao <code>WB_HUDMain</code> dentro de um <em>Overlay</em> no canto superior
                            direito.</li>
                        <li>No gráfico do <code>WB_HUDMain</code>, exponha funções <code>AtualizarHP</code>,
                            <code>AtualizarMP</code>, <code>AtualizarAG</code> e <code>AtualizarSD</code>. Cada uma recebe o
                            valor atual e máximo, calcula a porcentagem e altera a escala ou tamanho da imagem.</li>
                        <li>No <code>UEnsinoRemakeGameInstance</code>, instancie o Widget e mantenha referência global.
                            Chame as funções de atualização quando eventos de status forem recebidos do servidor.</li>
                    </ol>
                    <h4>Fluxo Blueprint (sem escrever código)</h4>
                    <ol class="blueprint-list">
                        <li>No <strong>Graph</strong> do <code>WB_HUDMain</code>, clique em <em>Event Construct</em> &rarr;
                            <em>Create Widget</em> (<code>WB_Minimap</code>) &rarr; <em>Add to Viewport</em> dentro de um
                            <em>Overlay</em>.</li>
                        <li>Para cada barra, crie um <em>Binding</em> do tamanho: <em>Get Percent HP</em> &rarr;
                            <em>Divide</em> valor atual pelo máximo &rarr; <em>Set Render Scale</em> da imagem.</li>
                        <li>Adicione um <em>Custom Event</em> chamado <code>AplicarStatusDoServidor</code> que recebe uma
                            <code>struct</code> com HP, MP, AG e SD. Dentro dele, chame as quatro funções de atualização.</li>
                        <li>No <code>GameInstance</code>, use <em>Event Init</em> &rarr; <em>Create Widget</em>
                            (<code>WB_HUDMain</code>) &rarr; <em>Add to Viewport</em> &rarr; <em>Promote to Variable</em>
                            (<code>HUDAtivo</code>).</li>
                        <li>Quando o <code>UNetworkBridgeSubsystem</code> processar <code>ReceiveMoveCharacter</code>,
                            dispare <code>HUDAtivo-&gt;AplicarStatusDoServidor</code> para refletir a vida confirmada pelo
                            servidor.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>As texturas convertidas aparecem sem bordas corrompidas.</li>
                        <li>Reduzir o HP no servidor altera imediatamente a barra vermelha na Unreal.</li>
                        <li>O minimapa mostra a posição do jogador e rotaciona conforme a câmera.</li>
                    </ul>
                    <div class="recipe-mapping">
                        <h4>Arquivos de referência</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Elemento</th>
                                    <th>Unreal</th>
                                    <th>Original</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Faixa da HUD</td>
                                    <td>Imagens em <code>WB_HUDMain</code></td>
                                    <td><code>NewUIMainFrameWindow::LoadImages</code></td>
                                </tr>
                                <tr>
                                    <td>Barras de status</td>
                                    <td>Funções <code>Atualizar*</code> + <em>Bindings</em></td>
                                    <td><code>RenderStats</code> e <code>m_PlayerStatusBar.SetStatus</code></td>
                                </tr>
                                <tr>
                                    <td>Minimapa</td>
                                    <td><code>WB_Minimap</code> + material com máscara</td>
                                    <td><code>NewUIMiniMap::Render</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>
                <article class="recipe-card" data-recipe="receita-2">
                    <h3>Receita 2 — Inventário e arrastar/soltar</h3>
                    <p class="recipe-intro">Recria o inventário 8×8, lógica de tamanho de itens e movimentação com o mouse.</p>
                    <h4>Ingredientes do clássico</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIInventoryCtrl.cpp</code> — observe <code>LoadImages</code>,
                            <code>SetItem</code>, <code>UpdateMouseEvent</code> e uso de <code>CNewUIPickedItem</code>.</li>
                        <li><code>Source Main 5.2/source/ZzzInventory.h</code> — lista tamanhos (colunas, linhas) para cada
                            item.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/ItemAddOption.cpp</code> — mostra como o
                            servidor envia atributos extras.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Crie uma <em>Data Table</em> <code>DT_Items</code> com colunas Nome, Classe, Largura, Altura e
                            Caminho da textura, preenchendo com dados de <code>ZzzInventory.h</code>.</li>
                        <li>Implemente um <code>UInventoryComponent</code> com matriz 8×8 de <code>FItemSlot</code> contendo
                            ID, rotação e quantidade.</li>
                        <li>Monte o Widget <code>WB_Inventory</code> com <em>UniformGridPanel</em>. Cada célula possui um
                            <em>Border</em> vazio e um <em>Image</em> preenchido quando existir item.</li>
                        <li>Implemente eventos de <em>Drag &amp; Drop</em>: ao iniciar, armazene o item em uma variável
                            temporária; ao soltar, valide posição e tamanho usando a matriz do componente (mesma lógica de
                            <code>CanMoveTo</code> no código original).</li>
                        <li>Conecte o componente ao Widget via <em>Event Dispatcher</em> que seja chamado quando pacotes do
                            servidor (inventário completo, troca de item) chegarem.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>WB_Inventory</code>, utilize <em>Event Construct</em> &rarr; <em>For Each Loop</em> na
                            matriz 8×8 &rarr; <em>Create Widget</em> (<code>WB_Slot</code>) &rarr; <em>Add Child to
                                UniformGrid</em> definindo linha e coluna.</li>
                        <li>No <em>OnMouseButtonDown</em> do <code>WB_Slot</code>, chame um <em>Event Dispatcher</em>
                            <code>SolicitarMovimentacao</code> passando índice do slot.</li>
                        <li>No <code>UInventoryComponent</code>, implemente <em>Custom Event</em>
                            <code>AplicarMovimentacao</code>: verifique tamanho com <em>Branch</em> + <em>For Loop</em>
                            (igual ao cálculo de <code>GetTargetPos</code>), atualize a matriz e dispare
                            <code>AtualizarWidgets</code>.</li>
                        <li>Crie uma <code>Timeline</code> curta para animações de feedback (fade quando item encaixa) e
                            conecte-a ao <code>WB_Slot</code> após <code>AplicarMovimentacao</code>.</li>
                        <li>No retorno do servidor (<code>GCInventoryItemOneSend</code>), chame
                            <code>AplicarMovimentacao</code> com os dados recebidos antes de permitir outro arrasto.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Itens grandes (2×4) ocupam múltiplas células e bloqueiam sobreposição.</li>
                        <li>Arrastar um item toca o mesmo som configurado em <code>DSPlaySound</code>.</li>
                        <li>O inventário atualiza quando o servidor envia <code>GCInventoryItemOneSend</code> (caso de teste).</li>
                    </ul>
                    <div class="recipe-mapping">
                        <h4>Arquivos de referência</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Elemento</th>
                                    <th>Unreal</th>
                                    <th>Original</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Tamanhos e slots</td>
                                    <td><code>FItemSlot</code> + <em>Data Table</em></td>
                                    <td><code>ZzzInventory.h</code></td>
                                </tr>
                                <tr>
                                    <td>Drag &amp; drop</td>
                                    <td>Eventos de <code>WB_Inventory</code></td>
                                    <td><code>CNewUIPickedItem::Update</code></td>
                                </tr>
                                <tr>
                                    <td>Atualização visual</td>
                                    <td><code>OnInventoryChanged</code> (delegate)</td>
                                    <td><code>NewUIInventoryCtrl::UpdateMouseEvent</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>
                <article class="recipe-card" data-recipe="receita-3">
                    <h3>Receita 3 — Chat, notificações e mensagens</h3>
                    <p class="recipe-intro">Permite digitar mensagens, exibir log e mostrar alertas como no cliente clássico.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIChatInputBox.cpp</code> — fluxo de foco e envio.</li>
                        <li><code>Source Main 5.2/source/NewUIChatLogWindow.cpp</code> — rolagem, filtros e exibição.</li>
                        <li><code>Source Main 5.2/source/wsclientinline.h</code> — função <code>SendChat</code> utilizada pelo
                            cliente clássico para enviar mensagens e whispers.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/Protocol.cpp</code> — casos 0x00/0x02 de
                            mensagens recebidas.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Crie <code>WB_Chat</code> com um <em>ScrollBox</em> para o log e um <em>EditableTextBox</em>
                            para entrada.</li>
                        <li>Adicione botões de filtro (Geral, Guilda, Grupo). Alterne a cor do texto com base na seleção.</li>
                        <li>No evento <code>OnTextCommitted</code>, chame <code>UNetworkBridgeSubsystem::EnviarChat</code>
                            montando pacote igual ao do cliente antigo.</li>
                        <li>Ao receber resposta do servidor, adicione uma linha ao <em>ScrollBox</em> com carimbo de hora.</li>
                        <li>Para notificações (ex. “Você entrou na party”), crie um <code>Widget</code> flutuante usando
                            animações <em>Timeline</em> e textos de <code>GlobalText</code>.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <em>Event Construct</em> do <code>WB_Chat</code>, associe o <em>ScrollBox</em> a uma variável
                            e inicialize um <em>Array</em> de mensagens vazias.</li>
                        <li>No <em>OnTextCommitted</em>, use <em>Select</em> para diferenciar <em>Commit</em> por Enter,
                            construa a string “/w Nome Mensagem” quando detectar whisper e encaminhe para o
                            <code>UNetworkBridgeSubsystem</code>.</li>
                        <li>Ao receber mensagens, crie widgets <code>WB_LinhaChat</code>, defina cor com <em>Switch on
                                ECanalChat</em> e adicione ao <em>ScrollBox</em>; depois chame <em>Scroll To End</em>.</li>
                        <li>Para alertas de sistema, dispare um <code>Event Dispatcher</code> que o <code>HUD</code>
                            escuta, instanciando <code>WB_Notificacao</code> com <em>Play Animation</em>.</li>
                        <li>Armazene as últimas 50 mensagens em array; quando ultrapassar, use <em>Remove Index</em> para
                            manter desempenho.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Pressionar <kbd>Enter</kbd> alterna entre chat ativo/inativo como no arquivo
                            <code>NewUIChatInputBox.cpp</code>.</li>
                        <li>Mensagens longas quebram linha automaticamente.</li>
                        <li>Alertas importantes aparecem na área superior com fade-in/fade-out.</li>
                    </ul>
                    <div class="recipe-mapping">
                        <h4>Arquivos de referência</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Elemento</th>
                                    <th>Unreal</th>
                                    <th>Original</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Entrada de texto</td>
                                    <td><code>EditableTextBox</code> + bindings</td>
                                    <td><code>NewUIChatInputBox::Update</code></td>
                                </tr>
                                <tr>
                                    <td>Log rolável</td>
                                    <td><em>ScrollBox</em></td>
                                    <td><code>NewUIChatLogWindow::RenderText</code></td>
                                </tr>
                                <tr>
                                    <td>Envio de pacote</td>
                                    <td><code>UNetworkBridgeSubsystem::EnviarChat</code></td>
                                    <td><code>SendChat</code> (<code>wsclientinline.h</code>)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>
                <article class="recipe-card" data-recipe="receita-4">
                    <h3>Receita 4 — Combate completo: movimento, combos e poderes</h3>
                    <p class="recipe-intro">Siga esta receita de bolo para recriar o combate inteiro como no Main 5.2:
                        caminhar com confirmação do servidor, executar combos, conjurar habilidades, usar poções e manter
                        buffs ativos sem perder nenhum detalhe.</p>
                    <h4>Ingredientes do clássico (separe antes de começar)</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/ProtocolSend.cpp</code> — pacotes <code>SendCharacterMoveNew</code>,
                            <code>SendRequestMagic</code>, <code>SendRequestPosMagic</code>, <code>SendUseItem</code> e
                            <code>SendMultiAttack</code>.</li>
                        <li><code>Source Main 5.2/source/WSclient.cpp</code> — confirmações <code>ReceiveMoveCharacter</code>,
                            <code>ReceiveAttack</code>, <code>ReceiveMagicAttack</code>, <code>ReceiveDamage</code>,
                            <code>ReceiveDurationMagic</code>.</li>
                        <li><code>Source Main 5.2/source/SkillManager.cpp</code>, <code>SkillHitManager.cpp</code> e
                            <code>ComboSkill.cpp</code> — regras de custo, delays, combos e efeitos especiais.</li>
                        <li><code>Source Main 5.2/source/NewUISkillList.cpp</code> e <code>NewUIHotKey.cpp</code> — gestão de
                            slots, cooldowns visuais e alternância Set 1/Set 2.</li>
                        <li><code>Source Main 5.2/source/GMEffectSlot.cpp</code> e <code>BuffEffectSlot.cpp</code> — ícones,
                            timers e tooltips de buffs.</li>
                        <li>Arquivos de dados <code>SkillList.txt</code>, <code>SkillTree.txt</code>,
                            <code>Item.txt</code>, <code>BuffEffect.txt</code> e animações originais de armas.</li>
                    </ul>
                    <h4>Modo de preparo na Unreal (siga na ordem)</h4>
                    <ol>
                        <li><strong>Passo 1 — Mise en place de dados:</strong> converta <code>SkillList.txt</code>,
                            <code>SkillTree.txt</code>, <code>Item.txt</code> e <code>BuffEffect.txt</code> em
                            <code>Data Tables</code> (<code>DT_Skills</code>, <code>DT_Combos</code>,
                            <code>DT_ItensRapidos</code>, <code>DT_Buffs</code>) usando structs com custos, delays e efeitos.</li>
                        <li><strong>Passo 2 — Ligue a rede:</strong> expanda o <code>UNetworkBridgeSubsystem</code> com funções
                            <code>EnviarMovimentoConfirmado</code>, <code>EnviarComboBasico</code>,
                            <code>EnviarSkillAlvo</code>, <code>EnviarSkillArea</code>,
                            <code>EnviarSkillMultipla</code> e <code>EnviarUsoRapido</code>, mantendo cabeçalhos C1/C3
                            idênticos (0xD7, 0x1F, 0x19, 0x1E, 0x4E, 0x26).</li>
                        <li><strong>Passo 3 — Crie o maestro do personagem:</strong> adicione ao personagem o componente
                            <code>UCombatBridgeComponent</code> que mantém fila de ações, estados (Livre, Atacando,
                            AguardandoConfirmação) e eventos <code>OnComboLiberado</code>,
                            <code>OnSkillConfirmada</code>.</li>
                        <li><strong>Passo 4 — Confirme movimento:</strong> ajuste o <code>CharacterMovementComponent</code>
                            para usar <em>Root Motion</em> opcional. Ao pressionar WASD, envie 0xD7 com destino previsto e
                            só aplique <code>AddMovementInput</code> quando o servidor responder — antes disso mostre
                            animação de pré-passada.</li>
                        <li><strong>Passo 5 — Monte os combos:</strong> importe montagens de armas (leve, pesado, finalizador)
                            e configure <em>Montage Sections</em> para cada golpe. Use <code>DT_Combos</code> para definir
                            janela de entrada e dano extra do combo triplo.</li>
                        <li><strong>Passo 6 — Habilidades em camadas:</strong> crie <code>USkillLoadoutComponent</code> com 10
                            slots, alternância Set 1/Set 2 e suporte a skills canalizadas. Exponha <em>Multicast Delegates</em>
                            para atualizar HUD e bloquear botões durante cooldown.</li>
                        <li><strong>Passo 7 — Calculadora de dano:</strong> implemente um <code>UDamageRouterComponent</code>
                            que recebe confirmações de <code>ReceiveAttack</code>/<code>ReceiveMagicAttack</code>, consulta
                            <code>DT_Skills</code> e instancia partículas, números flutuantes e <em>Hit Reactions</em>.</li>
                        <li><strong>Passo 8 — Poções e itens rápidos:</strong> adicione <code>UQuickSlotManager</code> ligado ao
                            inventário; ao ativar envia 0x26, espera retorno e sincroniza contadores, reproduzindo efeitos
                            Niagara e sons do Main.</li>
                        <li><strong>Passo 9 — Buffs e debuffs:</strong> construa <code>UBuffTimelineComponent</code> que cria
                            entradas animadas na HUD, aplica <code>GameplayEffects</code> (ou multiplicadores próprios) e
                            remove automaticamente via <em>TimerHandle</em> alinhado ao tempo recebido.</li>
                        <li><strong>Passo 10 — Teste cooperativo:</strong> instancie dois personagens em editor Multiplayer e
                            valide combos, projéteis, poções e buffs viajando entre clientes e servidor.</li>
                    </ol>
                    <h4>Cobertura Blueprint passo a passo</h4>
                    <ol class="blueprint-list">
                        <li>No <code>BP_RemakeCharacter</code>, use <em>InputAction Move</em> para chamar
                            <code>EnviarMovimentoConfirmado</code>; receba o pacote 0xD7 no subsistema e execute
                            <em>SetActorLocation</em> seguido de <code>OnMovimentoConfirmado</code>.</li>
                        <li>No <em>Enhanced Input</em>, configure <em>Triggers</em> (Tap, DoubleTap, Hold) no
                            <em>InputAction Attack</em> e mapeie cada resultado para <code>EnviarComboBasico</code> com índice
                            da seção. Use <em>Montage Notify</em> para disparar o próximo golpe após confirmação.</li>
                        <li>Para skills de alvo, trace <em>Hit Result</em> no <code>PlayerController</code>, converta para grid
                            e envie <code>EnviarSkillAlvo</code>; armazene ID do pacote em <code>PendingSkills</code> para
                            reconciliar quando o servidor responder.</li>
                        <li>No <code>WB_SkillBar</code>, conecte botões ao <code>USkillLoadoutComponent</code>, bloqueando UI
                            até receber <code>OnSkillConfirmada</code>. Use <em>Timeline</em> circular para cooldown.</li>
                        <li>Associe poções da HUD ao <code>UQuickSlotManager</code>; após confirmação, reduza quantidade e
                            acione <em>SpawnEmitterAtLocation</em> com texturas originais convertidas.</li>
                        <li>Atualize ícones de buff no <code>WB_HUDMain</code> registrando o evento
                            <code>OnBuffAtualizado</code> e animando <em>Progress Bars</em> para mostrar tempo restante.</li>
                    </ol>
                    <h4>Teste de forno e apresentação</h4>
                    <ul>
                        <li>Sequência de combo (clique simples → clique rápido → segurar) respeita sons, danos e delays do
                            cliente clássico — compare com os logs de <code>ComboSkill.cpp</code>.</li>
                        <li>Habilidades em área só causam dano depois da confirmação 0x1F/0x19; sem resposta, o efeito visual é
                            cancelado automaticamente.</li>
                        <li>Poções reduzem estoque, aplicam cura, exibem buff temporário e travam uso até o servidor liberar.</li>
                        <li>Buffs caducam no mesmo segundo indicado pelo GameServer e removem efeitos do personagem na hora.</li>
                    </ul>
                    <div class="recipe-mapping">
                        <h4>Arquivos de referência</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Elemento</th>
                                    <th>Unreal</th>
                                    <th>Original</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Movimento confirmado</td>
                                    <td><code>UCombatBridgeComponent</code> + <code>UNetworkBridgeSubsystem</code></td>
                                    <td><code>SendCharacterMoveNew</code> / <code>ReceiveMoveCharacter</code></td>
                                </tr>
                                <tr>
                                    <td>Skills e combos</td>
                                    <td><code>USkillLoadoutComponent</code> + montages</td>
                                    <td><code>SkillManager::SkillUseProc</code></td>
                                </tr>
                                <tr>
                                    <td>Buffs e efeitos</td>
                                    <td><code>BuffTimelineComponent</code> + HUD</td>
                                    <td><code>BuffEffectSlot.cpp</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>
                <article class="recipe-card" data-recipe="receita-5">
                    <h3>Receita 5 — Personagem completo: login, classes, seleção e movimentação</h3>
                    <p class="recipe-intro">Transforme o fluxo do personagem em uma receita completa: autenticação,
                        carrossel 3D, criação de classes, movimentação, animações básicas e sincronização com o servidor.</p>
                    <h4>Ingredientes do clássico</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/LoginMainWin.cpp</code> e <code>CharSelMainWin.cpp</code> — layout
                            de botões, sons e navegação.</li>
                        <li><code>Source Main 5.2/source/ProtocolSend.cpp</code> e <code>WSclient.cpp</code> — pacotes
                            0xF1/0xF3/0x1D do login, lista de personagens e entrada no mundo.</li>
                        <li><code>Source Main 5.2/source/CharacterManager.cpp</code>, <code>MoveCommand.cpp</code> e
                            <code>CPlayer.cpp</code> — atributos iniciais, velocidades e estados de movimento.</li>
                        <li><code>Source Main 5.2/source/ObjCreate.cpp</code> — mapeia classes para modelos e armas
                            exibidas na seleção.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/JSProtocol.cpp</code> e
                            <code>Protocol.cpp</code> — validação de conta, criação/apagamento de personagem e pacotes 0xD7.</li>
                        <li>Arquivos <code>CharacterCreate.txt</code>, <code>DefaultClassType.txt</code>,
                            <code>MoveReq.txt</code> e animações básicas de cada classe.</li>
                    </ul>
                    <h4>Modo de preparo na Unreal (sequência de passos)</h4>
                    <ol>
                        <li><strong>Passo 1 — Pré-aqueça o ambiente:</strong> importe texturas da tela de login e seleção,
                            separe sons de clique e configure nível <code>LV_Login</code> e <code>LV_Selecao</code> com
                            iluminação semelhante ao clássico.</li>
                        <li><strong>Passo 2 — Monte o formulário:</strong> crie <code>WB_Login</code> com campos usuário,
                            senha, botão Entrar, atalhos para opções e créditos. Adicione mensagens de ajuda para cada campo.</li>
                        <li><strong>Passo 3 — Ligue à rede:</strong> implemente <code>UNetworkBridgeSubsystem::EnviarLogin</code>
                            serializando <code>PMSG_CONNECT_ACCOUNT_SEND</code> e trate respostas 0xF1 exibindo pop-ups
                            idênticos aos do Main.</li>
                        <li><strong>Passo 4 — Prepare a lista de personagens:</strong> converta
                            <code>CharacterCreate.txt</code> e <code>DefaultClassType.txt</code> em
                            <code>DT_ClassTemplates</code> com classe, arma, animações e atributos iniciais.</li>
                        <li><strong>Passo 5 — Construa o carrossel 3D:</strong> no nível de seleção, crie
                            <code>BP_PersonagemPreview</code> que instancia <code>SkeletalMesh</code>, arma, partículas e
                            animação ociosa. Use <em>LevelSequence</em> para rotação contínua.</li>
                        <li><strong>Passo 6 — Lista navegável:</strong> monte <code>WB_SelecaoPersonagem</code> com
                            <em>ListView</em> lateral; ao clicar, atualize o carrossel e mostre atributos de
                            <code>DT_ClassTemplates</code>.</li>
                        <li><strong>Passo 7 — Criação guiada:</strong> adicione modal <code>WB_CriarPersonagem</code> com
                            campos nome, classe e aparência. Valide regras de <code>JSProtocol.cpp</code> (tamanho mínimo,
                            caracteres permitidos) e pré-visualize stats.</li>
                        <li><strong>Passo 8 — Exclusão segura:</strong> implemente confirmação dupla (senha + checkbox) antes
                            de enviar <code>JSProtocol::GDCharacterDel</code>, exibindo mensagens traduzidas de
                            <code>GlobalText.txt</code>.</li>
                        <li><strong>Passo 9 — Handshake final:</strong> ao escolher personagem, envie 0xF3 subcódigo 0x03,
                            aguarde 0x1D com mapa e chame <em>OpenLevel</em> para o mundo principal.</li>
                        <li><strong>Passo 10 — Instancie o personagem jogável:</strong> no <code>GameMode</code>, crie
                            <code>BP_RemakeCharacter</code> escolhendo <code>SkeletalMesh</code>, animações e armas com base no
                            template selecionado. Aplique stats iniciais e equipe visualmente.</li>
                        <li><strong>Passo 11 — Movimentação fiel:</strong> configure <code>CharacterMovementComponent</code>
                            com velocidades de <code>MoveReq.txt</code> (walk/run) e <em>Acceleration</em> idêntica ao
                            clássico. Associe animações Idle/Walk/Run e transições em <code>ABP_Remake</code>.</li>
                        <li><strong>Passo 12 — Rede + câmera:</strong> envie 0xD7 sempre que input mudar; somente após resposta
                            aplique <code>AddMovementInput</code>. Ajuste câmera terceira pessoa com limites de rotação como em
                            <code>GameMain.cpp</code>.</li>
                        <li><strong>Passo 13 — Extras ligados ao personagem:</strong> carregue aparência (skins, asa inicial),
                            atributos base (Força, Agilidade, Energia), atalhos iniciais e inventário padrão conforme a classe.</li>
                        <li><strong>Passo 14 — HUD e feedback imediatos:</strong> inicialize <code>WB_HUDMain</code> com barras
                            de HP/MP/SD, slots rápidos e mini mapa já preenchidos com os dados recebidos em 0x1D. Garanta que o
                            personagem apareça equipado, com os atributos e atalhos exibidos antes do primeiro movimento.</li>
                    </ol>
                    <h4>Cobertura Blueprint & animação</h4>
                    <ol class="blueprint-list">
                        <li>No <code>WB_Login</code>, conecte o botão Entrar ao evento <code>SolicitarLogin</code>, valide
                            campos e chame o subsistema. Use <em>Widget Switcher</em> para alternar entre login e seleção após
                            0xF3.</li>
                        <li>No <code>BP_PersonagemPreview</code>, exponha função <code>ConfigurarClasse</code> que define malha,
                            armas e partículas usando dados da <code>DT_ClassTemplates</code>.</li>
                        <li>No <code>BP_RemakeCharacter</code>, configure <em>Input Actions</em> para movimento, corrida,
                            rotação e salto, chamando <code>EnviarMovimentoConfirmado</code>. Use <em>State Machine</em> do
                            <code>AnimBlueprint</code> com estados Idle, Walk, Run, Turn, Jump.</li>
                        <li>Implemente <code>Event OnPossessed</code> no <code>PlayerController</code> para aplicar câmera
                            (boom) e bloquear rotação vertical conforme limites do Main.</li>
                        <li>Salve preferências (última conta, último personagem, câmera invertida) usando <code>SaveGame</code>
                            para ajudar estudantes a retomarem as aulas.</li>
                        <li>Ao inicializar o <code>WB_HUDMain</code>, consuma os eventos do <code>UNetworkBridgeSubsystem</code>
                            para preencher barras e slots antes do jogador se mover, reproduzindo os sons clássicos.</li>
                    </ol>
                    <h4>Teste de forno e apresentação</h4>
                    <ul>
                        <li>Login exibe mensagens idênticas ao cliente clássico (versão incorreta, conta bloqueada, limite de
                            tentativas).</li>
                        <li>O carrossel mostra classes com poses corretas, troca armas e animações conforme seleção.</li>
                        <li>Ao entrar no mundo, o personagem caminha e corre com velocidades iguais às tabelas originais e o
                            servidor confirma cada deslocamento (0xD7).</li>
                        <li>A criação/exclusão aplica as mesmas regras do servidor e atualiza a lista sem recarregar o nível.</li>
                        <li>HUD principal abre com barras e slots preenchidos instantaneamente, refletindo os valores recebidos
                            em 0x1D e aplicando os sons originais.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-6">
                    <h3>Receita 6 — Barra de habilidades e atalhos</h3>
                    <p class="recipe-intro">Permite arrastar habilidades para teclas rápidas, consumindo mana e respeitando atrasos
                        como no cliente original.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIHotKey.cpp</code> — lógica de atalhos, abertura do menu rápido e
                            teclas como I, V e F.</li>
                        <li><code>Source Main 5.2/source/SkillManager.cpp</code> — consulta a mana, distância e delay de cada
                            habilidade.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/Protocol.cpp</code> — pacotes 0x19, 0x1B e 0x1E de
                            ataque com habilidades.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Crie o Widget <code>WB_SkillBar</code> com 9 slots (1–8 e botão direito). Cada slot é um <em>Button</em>
                            com imagem e texto da tecla.</li>
                        <li>Implemente <code>USkillBarComponent</code> contendo um array de <code>FSkillSlot</code> (SkillID, Tecla,
                            TempoRestante) preenchido a partir de uma <em>Data Table</em> baseada em <code>SkillAttribute</code>.</li>
                        <li>Quando o jogador aprender uma habilidade, atualize o componente e emita evento para o Widget exibir ícone e
                            custo.</li>
                        <li>Na Unreal, associe cada tecla (1–8, botão direito) ao componente chamando
                            <code>SolicitarUsoHabilidade</code>.</li>
                        <li>Integre com o HUD mostrando barras de cooldown usando <em>Material Parameter Collection</em>.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>WB_SkillBar</code>, utilize <em>Event Construct</em> &rarr; <em>For Each Slot</em> &rarr; crie um
                            <code>WB_SkillSlot</code> e vincule <em>OnClicked</em> ao evento <code>OnSkillSlotClicado</code>.</li>
                        <li>Ao clicar, chame <code>USkillBarComponent::SolicitarUsoHabilidade</code>, que verifica mana e delay
                            consultando <code>SkillManager</code> via C++ ou Blueprint Function Library.</li>
                        <li>Se aprovado, envie pacote 0x19 para o servidor e inicie um <em>Timeline</em> que controla o preenchimento
                            do cooldown.</li>
                        <li>Quando o servidor confirmar com pacote 0x1B/0x1E, finalize o <em>Timeline</em> e notifique o HUD com o dano
                            aplicado.</li>
                        <li>Se faltar mana, exiba callout vermelho reutilizando a lógica do cliente clássico de mensagens no chat.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Cooldowns respeitam o mesmo tempo definido em <code>SkillAttribute</code>.</li>
                        <li>Habilidades fora de alcance mostram aviso “Muito longe” como no cliente original.</li>
                        <li>O servidor valida cada uso antes de causar dano ou efeitos.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-7">
                    <h3>Receita 7 — NPC Loja e trocas entre jogadores</h3>
                    <p class="recipe-intro">Recria o atendimento de NPCs comerciantes e a janela de trade usando as mesmas verificações de
                        servidor.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUINPCShop.cpp</code> — abertura da janela, bloqueio de slots e envio de
                            compras.</li>
                        <li><code>Source Main 5.2/source/NewUIInventoryCtrl.cpp</code> — cálculo da posição alvo para itens.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/Protocol.cpp</code> — pacotes 0x30–0x3D para conversar
                            com NPCs, comprar, vender e confirmar trocas.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Crie o Widget <code>WB_NPCShop</code> com grade 8×15 para itens do vendedor e botões Comprar, Vender, Reparar.
                        </li>
                        <li>No <code>UNetworkBridgeSubsystem</code>, implemente <code>EnviarAbrirNPC</code>,
                            <code>EnviarCompraNPC</code> e <code>EnviarVendaNPC</code> espelhando os pacotes 0x30–0x33.</li>
                        <li>Para trocas entre jogadores, desenvolva o Widget <code>WB_Trade</code> com duas grades (você e alvo) e campos de
                            zen.</li>
                        <li>Crie animações de feedback quando o servidor confirmar com 0x3A/0x3C (zen e confirmação final).</li>
                        <li>Integre com o componente de inventário para bloquear slots enquanto a janela estiver aberta, tal como
                            <code>CNewUINPCShop::LockInventory</code>.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>Ao interagir com NPC, use <em>Line Trace</em> &rarr; cheque tag “Merchant” &rarr; chame
                            <code>EnviarAbrirNPC</code>; quando o servidor responder com a lista, preencha a grade através de um
                            <em>For Each Loop</em>.</li>
                        <li>No botão Comprar, leia slot selecionado, calcule preço e envie <code>EnviarCompraNPC</code>. Desabilite o botão
                            até receber confirmação.</li>
                        <li>Para trade, ao aceitar convite, abra <code>WB_Trade</code>, use <em>Event Dispatcher</em> para bloquear movimentos
                            e envie 0x36/0x37 conforme resposta.</li>
                        <li>Ao clicar em OK, envie 0x3C e aguarde 0x3D; apenas quando ambos confirmarem libere itens e feche janelas.</li>
                        <li>Sincronize o ouro digitado com <code>Binding</code> que chama validação no servidor a cada alteração.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Itens do NPC aparecem nas mesmas posições do arquivo original.</li>
                        <li>É impossível mover itens enquanto a janela de compra estiver aberta, evitando bugs.</li>
                        <li>Trocas só finalizam quando os dois jogadores confirmam, replicando a lógica do pacote 0x3C.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-8">
                    <h3>Receita 8 — Diário de missões e recompensas</h3>
                    <p class="recipe-intro">Configura o sistema de quests, diário e recompensas automáticas igual ao cliente clássico.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/QuestInfoWindow.cpp</code> e <code>QuestProgress.cpp</code> — fluxo do diário e atualizações visuais.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/Quest.cpp</code> — validações de requisitos e pacotes 0x7A/0x7B.</li>
                        <li><code>Data/Quest/QuestList.txt</code> e <code>QuestProgress.txt</code> — dados de objetivos e recompensas.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Crie a <code>Data Table</code> <code>DT_Quests</code> com campos ID, título, descrição, requisito e recompensa usando os arquivos <code>QuestList</code>.</li>
                        <li>Implemente <code>UQuestComponent</code> com arrays <code>QuestsAtivas</code> e <code>QuestsConcluidas</code>, espelhando <code>QuestProgress.cpp</code>.</li>
                        <li>Monte o Widget <code>WB_QuestLog</code> com duas colunas (ativas/completas) e botões “Rastrear” e “Recompensa”.</li>
                        <li>Conecte o componente ao <code>UNetworkBridgeSubsystem</code> para enviar 0x7A (aceitar) e receber 0x7B (atualizar progresso).</li>
                        <li>Implemente função <code>AplicarRecompensa</code> que chama o servidor (0x7D) e atualiza inventário/XP antes de marcar como concluída.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>WB_QuestLog</code>, use <em>Event Construct</em> &rarr; <em>Populate List</em> com dados do componente.</li>
                        <li>Ao clicar em “Aceitar”, chame <code>UQuestComponent::SolicitarAceite</code> &rarr; <code>EnviarQuest</code> (0x7A) &rarr; desabilite botão até resposta.</li>
                        <li>Quando receber 0x7B, atualize barras de progresso via <em>Set Percent</em> e exiba mensagem na HUD.</li>
                        <li>Acione <code>AplicarRecompensa</code> após confirmar no servidor (0x7D) e reproduza efeitos de brilho.</li>
                        <li>Atualize o minimapa com marcadores de objetivo usando <code>Add Quest Marker</code> do componente.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Objetivos aumentam automaticamente ao derrotar monstros ou coletar itens.</li>
                        <li>Recompensas adicionam XP, Zen e itens exatamente como no arquivo <code>QuestList</code>.</li>
                        <li>O diário mostra estados corretos mesmo após reconectar.</li>
                    </ul>
                    <div class="recipe-mapping">
                        <h4>Arquivos de referência</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Elemento</th>
                                    <th>Unreal</th>
                                    <th>Original</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Lista de quests</td>
                                    <td><code>DT_Quests</code></td>
                                    <td><code>QuestList.txt</code></td>
                                </tr>
                                <tr>
                                    <td>Atualização de progresso</td>
                                    <td><code>UQuestComponent</code></td>
                                    <td><code>QuestProgress.cpp</code></td>
                                </tr>
                                <tr>
                                    <td>Entrega de recompensa</td>
                                    <td>Evento <code>AplicarRecompensa</code></td>
                                    <td><code>Quest.cpp :: QuestRewardRun</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>
                <article class="recipe-card" data-recipe="receita-9">
                    <h3>Receita 9 — IA de monstros e respawns</h3>
                    <p class="recipe-intro">Constrói respawns, comportamento e sincronização de monstros replicando o servidor.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/MonsterAI.cpp</code> e <code>MonsterRegen.cpp</code> — regras de perseguição e respawn.</li>
                        <li><code>Data/Monster/MonsterSetBase.txt</code> — posições, direções e tempo de reaparecimento.</li>
                        <li><code>Source Main 5.2/source/ZzzAI.cpp</code> — efeitos visuais de agressão.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Converta <code>MonsterSetBase.txt</code> em <code>DT_MonsterSpawns</code> com mapa, coordenadas e intervalo.</li>
                        <li>Crie <code>AMonsterSpawner</code> que lê a tabela e instancia <code>ABaseMonster</code> com Behavior Tree.</li>
                        <li>Configure Behavior Tree com estados Patrulha, Perseguir, Atacar e Retornar, seguindo as condições de <code>MonsterAI.cpp</code>.</li>
                        <li>Implemente <code>UNetworkBridgeSubsystem::RegistrarSpawn</code> enviando 0x16 (spawn) e recebendo 0x17 (morte).</li>
                        <li>Adapte partículas de agressão usando Niagara com texturas de <code>Data/Effects</code>.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>AMonsterSpawner</code>, execute <em>BeginPlay</em> &rarr; <em>For Each Spawn</em> &rarr; <em>Spawn Actor</em> com parâmetros.</li>
                        <li>No <code>ABaseMonster</code>, use <em>Event Possessed</em> para iniciar Behavior Tree.</li>
                        <li>Ao detectar jogador (<em>OnPerceptionUpdated</em>), dispare evento <code>SolicitarAtaqueMonstro</code> (0x17) e aguarde retorno.</li>
                        <li>Quando morrer, chame <code>UNetworkBridgeSubsystem::NotificarMorteMonstro</code> para o DataServer liberar drops.</li>
                        <li>Use <em>Delay</em> baseado no campo <code>RespawnTime</code> antes de chamar <code>Spawn Actor</code> novamente.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Monstros respeitam limites de perseguição e retornam à posição original.</li>
                        <li>Drops são liberados somente após confirmação do servidor.</li>
                        <li>Respawns seguem os segundos definidos em <code>MonsterSetBase.txt</code>.</li>
                    </ul>
                    <div class="recipe-mapping">
                        <h4>Arquivos de referência</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Elemento</th>
                                    <th>Unreal</th>
                                    <th>Original</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Respawn</td>
                                    <td><code>AMonsterSpawner</code></td>
                                    <td><code>MonsterRegen.cpp</code></td>
                                </tr>
                                <tr>
                                    <td>Comportamento</td>
                                    <td>Behavior Tree + Blackboard</td>
                                    <td><code>MonsterAI.cpp</code></td>
                                </tr>
                                <tr>
                                    <td>Pacote de spawn</td>
                                    <td><code>UNetworkBridgeSubsystem::RegistrarSpawn</code></td>
                                    <td><code>Protocol.cpp</code> (0x16/0x17)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>
                <article class="recipe-card" data-recipe="receita-10">
                    <h3>Receita 10 — Party, guild e correio social</h3>
                    <p class="recipe-intro">Permite formar grupos, guilds e enviar mensagens internas com a mesma lógica do clássico.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIPartyWindow.cpp</code> e <code>NewUIGuildInfoWindow.cpp</code> — layout e interações.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/Party.cpp</code> e <code>GuildClass.cpp</code> — regras de convite, expulsão e habilidades de guild.</li>
                        <li><code>ProtocolSend.cpp</code> (0x40–0x43) e <code>Protocol.cpp</code> (respostas de party/guild).</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Crie Widgets <code>WB_Party</code>, <code>WB_Guild</code> e <code>WB_GuildNotice</code> com slots dinâmicos.</li>
                        <li>Implemente <code>USocialComponent</code> com listas de membros, convites pendentes e privilégios.</li>
                        <li>Conecte convites a pacotes 0x40/0x41 e atualize componentes com respostas 0x42/0x43.</li>
                        <li>Implemente sistema de correio interno usando <code>WB_Mailbox</code> e DataServer (procedures <code>GDSaveMail</code>/<code>GDReadMail</code>).</li>
                        <li>Sincronize buffs de guild (por exemplo, HP extra) aplicando <code>Gameplay Effects</code> quando <code>GuildClass.cpp</code> enviar atualização.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>WB_Party</code>, use <em>Event Construct</em> para preencher slots e bindar botões Sair/Kick.</li>
                        <li>Ao clicar “Convidar”, abra <code>WB_SelectPlayer</code>, chame <code>USocialComponent::EnviarConviteParty</code> e aguarde retorno.</li>
                        <li>Quando receber atualização 0x42, atualize lista e emita notificação sonora via HUD.</li>
                        <li>No correio, ao enviar mensagem, chame <code>EnviarMail</code> (0x78) e limpe formulário somente após confirmação.</li>
                        <li>Atualize buffs de guild usando <em>Gameplay Tags</em> acionadas pelo servidor.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Party mostra HP/MP dos membros em tempo real.</li>
                        <li>Guild notice aparece na tela inicial exatamente como no cliente original.</li>
                        <li>Mensagens do correio persistem após desconectar.</li>
                    </ul>
                    <div class="recipe-mapping">
                        <h4>Arquivos de referência</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Elemento</th>
                                    <th>Unreal</th>
                                    <th>Original</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Gerenciamento de Party</td>
                                    <td><code>USocialComponent</code></td>
                                    <td><code>Party.cpp</code></td>
                                </tr>
                                <tr>
                                    <td>Informações da Guild</td>
                                    <td><code>WB_Guild</code></td>
                                    <td><code>NewUIGuildInfoWindow.cpp</code></td>
                                </tr>
                                <tr>
                                    <td>Correio</td>
                                    <td><code>WB_Mailbox</code> + DataServer</td>
                                    <td><code>GuildClass.cpp</code> / <code>GDSaveMail</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>
                <article class="recipe-card" data-recipe="receita-11">
                    <h3>Receita 11 — Eventos instanciados (Blood Castle, Devil Square)</h3>
                    <p class="recipe-intro">Recria os eventos em instâncias com controles de tempo, objetivos e recompensas.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/BloodCastle.cpp</code> e <code>DevilSquare.cpp</code> — regras e fases.</li>
                        <li><code>Source Main 5.2/source/NewUIBattleCastle.cpp</code> e <code>NewUIEventNotifyWindow.cpp</code> — interface dos eventos.</li>
                        <li>Arquivos <code>Data/Event/BloodCastle.txt</code>, <code>DevilSquare.txt</code> — configuração de horários e recompensas.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Crie níveis dedicados (<code>LV_BloodCastle</code>, <code>LV_DevilSquare</code>) com Level Streaming carregado quando o evento começar.</li>
                        <li>Implemente <code>AEventController</code> que lê tabelas <code>DT_BloodCastle</code>/<code>DT_DevilSquare</code> derivadas dos arquivos originais.</li>
                        <li>Desenvolva Widgets <code>WB_EventTimer</code> e <code>WB_EventScore</code> replicando a UI clássica.</li>
                        <li>Sincronize entradas e saídas com pacotes 0x90–0x94, confirmando com o GameServer antes de teleportar jogadores.</li>
                        <li>Ao finalizar, distribua recompensas chamando <code>UNetworkBridgeSubsystem::EnviarRecompensaEvento</code> (0x95) e atualizando o inventário.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>Quando o servidor enviar “Evento iniciou”, carregue o nível com <em>Load Stream Level</em> e exiba <code>WB_EventTimer</code>.</li>
                        <li>Atualize tempo restante usando <em>Set Timer by Event</em> a cada segundo.</li>
                        <li>Registre progresso (portões destruídos, pontos coletados) em <code>UEventProgressComponent</code> e envie para o servidor.</li>
                        <li>Ao terminar, execute <code>Unload Stream Level</code> e retorne jogadores à cidade original.</li>
                        <li>Chame <code>AplicarRecompensaEvento</code> para adicionar itens/XP e registrar log.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Eventos respeitam horários configurados e notificam todos os jogadores.</li>
                        <li>Objetivos e pontuações combinam com o cliente clássico.</li>
                        <li>Recompensas são entregues somente após confirmação do GameServer.</li>
                    </ul>
                    <div class="recipe-mapping">
                        <h4>Arquivos de referência</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Elemento</th>
                                    <th>Unreal</th>
                                    <th>Original</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Controle de fases</td>
                                    <td><code>AEventController</code></td>
                                    <td><code>BloodCastle.cpp</code> / <code>DevilSquare.cpp</code></td>
                                </tr>
                                <tr>
                                    <td>HUD do evento</td>
                                    <td><code>WB_EventTimer</code></td>
                                    <td><code>NewUIEventNotifyWindow.cpp</code></td>
                                </tr>
                                <tr>
                                    <td>Recompensas</td>
                                    <td><code>AplicarRecompensaEvento</code></td>
                                    <td><code>Event.cpp</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>
                <article class="recipe-card" data-recipe="receita-12">
                    <h3>Receita 12 — Sistema de duelo, placar e espectadores</h3>
                    <p class="recipe-intro">Ativa a arena de duelos com feedback visual, convites, ranking temporário e mensagens do servidor.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIDuelWindow.cpp</code> e <code>NewUIDuelWindow.h</code> — layout do placar e lógica de aceitação.</li>
                        <li><code>Source Main 5.2/source/CDuelMgr.cpp</code> — estados do duelo, lista de espectadores e timers.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/DuelSystem.cpp</code> — validações, limites de tempo e broadcast.</li>
                        <li><code>Source Main 5.2/source/ProtocolSend.cpp</code> — pacotes 0xAA (subcódigos 0x01–0x07) usados em cada etapa.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Converta texturas <code>Interface/duel/*.jpg</code> para <code>.png</code> e importe para <code>Content/UI/Duel</code>.</li>
                        <li>Crie <code>WB_DuelHUD</code> com barras de HP, nomes, contador de vitórias e lista de espectadores em <em>ScrollBox</em>.</li>
                        <li>Implemente <code>UDuelComponent</code> em C++ contendo estados (<code>Idle</code>, <code>Requesting</code>, <code>Fighting</code>, <code>Result</code>) e replicando dados.</li>
                        <li>No <code>UNetworkBridgeSubsystem</code>, serialize requisições/respostas de duelo copiando estruturas <code>PMSG_DUEL_*</code> e valide com logs do servidor.</li>
                        <li>Adicione animação de brilho (azul/vermelho) usando <em>UMG Animations</em> + <em>Material Instances</em> quando um ponto é marcado.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>WB_DuelHUD</code>, crie eventos <code>AtualizarPlacar</code> e <code>AtualizarEspectadores</code> disparados pelo componente.</li>
                        <li>Use <em>Timeline</em> para animar o cronômetro (escala radial) e <em>Play Animation</em> quando um jogador vence.</li>
                        <li>No <code>BP_PlayerController</code>, capture interação “Solicitar Duelo” e chame <code>UDuelComponent::SolicitarDuelo</code>.</li>
                        <li>Quando o servidor enviar “DuelStart”, faça <code>Show Mouse Cursor = false</code>, bloqueie inventário e exiba o HUD.</li>
                        <li>Ao terminar, toque sons de vitória/derrota reutilizando <code>DSPlaySound</code> convertidos para <code>.wav</code>.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Solicitar duelo dispara pop-up para o alvo com opções Aceitar/Recusar e timer regressivo.</li>
                        <li>Placar, cronômetro e espectadores atualizam instantaneamente conforme os pacotes 0xAA recebidos.</li>
                        <li>Logs do GameServer mostram <code>[Duel] Start</code>/<code>[Duel] End</code> sincronizados com a UI.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-13">
                    <h3>Receita 13 — Empire Guardian com waves e HUD</h3>
                    <p class="recipe-intro">Constrói lobby, instância e painel de progresso do evento cooperativo Imperial Guardian.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIEmpireGuardianNPC.cpp</code> e <code>NewUIEmpireGuardianResult.cpp</code> — lobby, HUD e mensagens.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/ImperialGuardian.cpp</code> — fases, portais e timers.</li>
                        <li>Arquivos <code>Data/Event/ImperialGuardian.txt</code> e texturas em <code>Interface/EmpireGuardian</code>.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Modele <code>WB_EmpireGuardianLobby</code> com slots de party, requisitos de nível e contador de tempo.</li>
                        <li>Crie nível instanciado <code>LV_EmpireGuardian</code> com <code>LevelInstance</code> para cada wave (1–4) e portais animados.</li>
                        <li>Implemente <code>AEmpireGuardianManager</code> que consome tabelas <code>DT_EmpireGuardianWaves</code> (convertidas do arquivo .txt) e ativa Level Streaming.</li>
                        <li>Construa <code>WB_EmpireGuardianHUD</code> com barras de progresso, contagem de monstros restantes e objetivo atual.</li>
                        <li>Adicione efeitos Niagara para abertura de portais e <em>Spotlights</em> dinâmicos sincronizados com os timers.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>AEmpireGuardianManager</code>, use <em>OnRep_CurrentWave</em> para atualizar HUD e spawnar inimigos.</li>
                        <li>Ao receber pacote 0xF7:0x10, abra o lobby; quando 0xF7:0x11 chegar, carregue a instância via <em>Open Level</em>.</li>
                        <li>Para cada wave concluída, dispare <em>Multicast</em> com efeito Niagara e mensagem usando textos originais.</li>
                        <li>Ao finalizar, toque cutscene curta com <em>Level Sequence</em> e exiba <code>WB_EmpireGuardianResult</code>.</li>
                        <li>Registre logs em arquivo local <code>Saved/Logs/empire_guardian.log</code> comparando com o servidor.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Lobby bloqueia jogadores sem requisitos e fecha quando o timer expira.</li>
                        <li>Portais e HUD atualizam a cada wave exatamente como o cliente clássico.</li>
                        <li>Recompensas são atribuídas após o pacote 0xF7:0x12 e aparecem na tela de resultado.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-14">
                    <h3>Receita 14 — Cursed Temple com equipes Holy/Illusion</h3>
                    <p class="recipe-intro">Recria o modo competitivo com minimapa dedicado, placar por equipe e feed de kills.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/CNewUICursedTempleSystem.cpp</code> e <code>NewUICursedTempleWindow.cpp</code>.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/CursedTempleEvent.cpp</code> — regras de pontuação.</li>
                        <li>Texturas em <code>Interface/CursedTemple</code> e scripts <code>Data/Event/CursedTemple.txt</code>.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Crie <code>WB_CursedTempleHUD</code> com indicadores de pontos, barra de energia da relíquia e ícones dos líderes.</li>
                        <li>Implemente <code>UCursedTempleComponent</code> replicando estrutura do pacote 0xF8 (match info) e registrando kills.</li>
                        <li>Monte minimapa circular com <code>SceneCapture2D</code> e <em>Material</em> que destaca santuários ocupados.</li>
                        <li>Adicione <code>ACursedTempleObjective</code> que dispara efeitos Niagara quando capturado.</li>
                        <li>Construa tabela <code>DT_CursedRewards</code> com recompensas e bonificações usando dados do arquivo .txt.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>UCursedTempleComponent</code>, use <em>OnRep_MatchState</em> para alternar widgets Preparação/Combate/Resultado.</li>
                        <li>Atualize feed de kills com <em>AddChildToVerticalBox</em> e efeitos sonoros importados do cliente.</li>
                        <li>Ao capturar objetivo, chame <code>Multicast_PlayCaptureFX</code> e ajuste placar usando dados do servidor.</li>
                        <li>Quando restarem 30 segundos, toque animação de alerta utilizando <em>Widget Animation</em>.</li>
                        <li>Finalize exibindo <code>WB_CursedTempleSummary</code> com ranking individual e recompensas.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Pontuação e mensagens coincidem com os logs do GameServer.</li>
                        <li>Feed de kills exibe nome, classe e ícone conforme o cliente clássico.</li>
                        <li>Time vencedor recebe bônus aplicados pelo servidor (exp/zen) e visual highlight na HUD.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-15">
                    <h3>Receita 15 — Doppelganger com linha do tempo e cinematics</h3>
                    <p class="recipe-intro">Implementa o evento Doppelganger com lobby, portais sincronizados e cutscenes.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIDoppelGangerWindow.cpp</code> e <code>DoppelGangerInfo.cpp</code>.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/Doppelganger.cpp</code> — fases e spawn da estátua.</li>
                        <li>Arquivos <code>Data/Event/DoppelGanger/*.txt</code> e texturas em <code>Interface/DoppelGanger</code>.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Crie <code>WB_DoppelLobby</code> com slots de party, requisitos de nível e custo de convite.</li>
                        <li>Implemente <code>ADoppelgangerDirector</code> que controla transições de fase (Pré-entrada, Defesa, Batalha Final) usando <code>Timeline</code>.</li>
                        <li>Construa HUD <code>WB_DoppelHUD</code> com barra de tempo, estado da estátua e lista de mobs restantes.</li>
                        <li>Configure cutscene inicial/final com <em>Level Sequence</em> e triggers enviados pelo GameServer.</li>
                        <li>Adicione efeitos roxos/escuros usando Niagara reaproveitando texturas do cliente.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>Ao receber pacote 0xF7:0x30, abra o lobby e inicie contagem regressiva.</li>
                        <li>Quando a partida iniciar, <em>Open Level</em> e execute <code>ADoppelgangerDirector::StartMatch</code> (replicado).</li>
                        <li>Use <em>Multicast</em> para disparar cutscenes e efeitos quando a estátua sofrer dano.</li>
                        <li>Atualize HUD a cada pacote 0xF7:0x34 (tempo) e 0xF7:0x36 (spawn de mobs).</li>
                        <li>Ao finalizar, toque cutscene final, distribua recompensas e retorne jogadores via <code>ServerTravel</code>.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Lobby bloqueia jogadores fora do horário ou sem convite.</li>
                        <li>Cutscenes e efeitos reproduzem sincronizados para todos os participantes.</li>
                        <li>Recompensas correspondem aos valores definidos em <code>Doppelganger.cpp</code>.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-16">
                    <h3>Receita 16 — Economia Lucky Coin &amp; Lucky Item</h3>
                    <p class="recipe-intro">Implementa troca de moedas, roleta de itens e feedback visual dourado.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIExchangeLuckyCoin.cpp</code> e <code>NewUILuckyItemWnd.cpp</code>.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/LuckyCoinSystem.cpp</code> e <code>ItemAddOption.cpp</code>.</li>
                        <li>Arquivos <code>Data/LuckyItemOption.txt</code>, <code>Data/Item.txt</code> e texturas <code>Interface/LuckyCoin</code>.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Converta <code>LuckyItemOption.txt</code> para <code>DT_LuckyRewards</code> (CSV &rarr; Data Table) com categorias, custos e bônus.</li>
                        <li>Crie <code>WB_LuckyExchange</code> com abas Trocar, Comprar e Histórico. Utilize <em>Widget Switcher</em> para alternar.</li>
                        <li>Implemente <code>ULuckyEconomyComponent</code> com saldo replicado, fila de requisições e integração com DataServer.</li>
                        <li>Adicione roleta visual usando <em>Widget Animation</em> + <em>Dynamic Material Instance</em> para brilho dourado.</li>
                        <li>Registre transações em <code>Saved/Logs/lucky_coin.csv</code> para auditoria educativa.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>WB_LuckyExchange</code>, conecte botões aos eventos <code>SolicitarTroca</code>/<code>SolicitarResgate</code>.</li>
                        <li>Mostre animação de roleta enquanto aguarda resposta do servidor (pacote 0xF3:0x03).</li>
                        <li>Ao receber resultado, atualize saldo, aplique item no inventário e toque som reutilizado do cliente.</li>
                        <li>Permita consultar histórico carregando dados salvos localmente em <em>Data Table</em> auxiliar.</li>
                        <li>Implemente mensagens de erro baseadas nas strings originais (saldo insuficiente, limite diário).</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Saldo sincroniza com DataServer sem divergências.</li>
                        <li>Animações e brilho aparecem com a mesma intensidade do cliente clássico.</li>
                        <li>Log registra todas as operações com timestamp e resultado.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-17">
                    <h3>Receita 17 — Refinaria Jewel of Harmony</h3>
                    <p class="recipe-intro">Permite aplicar e remover opções Harmony com efeitos visuais idênticos.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/UIJewelHarmony.cpp</code> — interface e regras de composição.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/JewelOfHarmonySystem.cpp</code> — cálculos e respostas.</li>
                        <li>Arquivos <code>Data/JewelOfHarmonyOption.bmd</code> e <code>Data/JewelOfHarmonyMix.bmd</code>.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Converta <code>.bmd</code> para JSON com o utilitário <code>BMD_FBX</code> ou scripts fornecidos e gere <code>DT_HarmonyOptions</code>.</li>
                        <li>Crie <code>WB_HarmonyForge</code> com slots para item base, Jewel of Harmony, Jewel of Harmony Smelt e botões Aplicar/Remover.</li>
                        <li>Implemente <code>UHarmonyForgeComponent</code> validando requisitos e enviando pacotes 0xF3:0x50/0x51.</li>
                        <li>Adicione efeito visual com material emissivo azul/roxo aplicado ao item na vitrine, sincronizado com <em>Timeline</em>.</li>
                        <li>Mostre pré-visualização dos atributos usando dados da Data Table antes de confirmar.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>WB_HarmonyForge</code>, reaja a <code>OnItemDropped</code> preenchendo slots e atualizando descrições.</li>
                        <li>Bloqueie botão Aplicar se requisitos não forem atendidos (nível do item, tipo permitido) replicando validações do cliente clássico.</li>
                        <li>Quando receber resposta positiva, atualize item no inventário e reproduza animação de partículas.</li>
                        <li>Em caso de falha, toque som de erro e mostre mensagem derivada do <code>GlobalText</code>.</li>
                        <li>Registre alterações no diário (arquivo <code>Saved/Logs/harmony.log</code>) para auditoria.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Opções exibidas na UI combinam com os valores convertidos dos arquivos <code>.bmd</code>.</li>
                        <li>Pacotes enviados/recebidos correspondem aos logs do GameServer sem divergências.</li>
                        <li>Efeitos de brilho e partículas replicam o visual azul característico do cliente clássico.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-18">
                    <h3>Receita 18 — Chaos Castle completo</h3>
                    <p class="recipe-intro">Transforma o blueprint do evento em um modo jogável com armadilhas, HUD e ranking.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIChaosCastle.cpp</code> — lógica de UI, timers e indicações visuais.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/ChaosCastle.cpp</code> — estados (StandBy, Playing, End) e armadilhas.</li>
                        <li>Arquivos <code>Data/Event/ChaosCastleSetting.txt</code>, <code>Data/Item/ChaosCastleReward.txt</code>.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Crie o nível <code>LV_ChaosCastle</code> replicando plataformas e zonas de queda com <em>Destructible Meshes</em>.</li>
                        <li>Implemente <code>AChaosCastleDirector</code> que consulta <code>DT_ChaosCastleConfig</code> (derivado dos <code>.txt</code>) e controla fases, armadilhas e tempo.</li>
                        <li>Monte <code>WB_ChaosCastleHUD</code> com contadores de sobreviventes, ranking em tempo real e avisos de armadilha.</li>
                        <li>Sincronize com o servidor enviando 0x95 (entrada), 0x95:0x03 (status) e recebendo 0xB0 (pontuação).</li>
                        <li>Registre resultado semanal escrevendo CSV educativo em <code>Saved/Logs/chaos_castle.csv</code> antes de entregar recompensas.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>AChaosCastleDirector</code>, use <em>Event BeginPlay</em> &rarr; <em>Load Data Table Row</em> &rarr; configurar timers para StandBy &rarr; Playing &rarr; End.</li>
                        <li>Quando um jogador cair, detecte com <em>OnComponentEndOverlap</em> e notifique o servidor via <code>ServerReportElimination</code>.</li>
                        <li>Atualize o HUD usando <em>Event Dispatcher</em> disparado ao receber pacotes 0x95:0x06 com contagem de sobreviventes.</li>
                        <li>Ative armadilhas com <em>Timeline</em> acionando <code>Enable Collision</code> em volumes configurados no Data Table.</li>
                        <li>Ao finalizar, toque <em>Level Sequence</em> de encerramento, distribua recompensas e retorne jogadores usando <code>ServerTravel</code>.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Timers e mensagens coincidem com os mostrados no cliente clássico.</li>
                        <li>Recompensas são atribuídas conforme posição e tabela de <code>ChaosCastleReward.txt</code>.</li>
                        <li>Ranking semanal reinicia automaticamente conforme configurado.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-19">
                    <h3>Receita 19 — Facções Gens Vanert/Dupren</h3>
                    <p class="recipe-intro">Entrega facções, missões diárias e buffs de rank integrados ao servidor.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIGensWindow.cpp</code> e <code>NewUIGensRanking.cpp</code>.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/GensSystem.cpp</code> — regras de contribuição, buffs e recompensas.</li>
                        <li>Arquivos <code>Data/GensSystem.txt</code>, <code>Data/Quest/GensQuest.txt</code>, <code>Data/Local/GensText.txt</code>.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Crie Widgets <code>WB_GensLobby</code>, <code>WB_GensRanking</code>, <code>WB_GensQuestCard</code> respeitando layout e ícones originais.</li>
                        <li>Implemente <code>UGensFactionComponent</code> no <code>PlayerState</code> para armazenar facção, pontos, rank e buffs ativos.</li>
                        <li>Converta as tabelas <code>.txt</code> para <code>DT_GensRewards</code>, <code>DT_GensQuests</code> e <code>DT_GensBuffs</code> com chaves idênticas às do servidor.</li>
                        <li>Sincronize pacotes 0xF8 subcódigos 0x03 (atualização de pontos) e 0x04 (ranking) disparando eventos visuais no HUD.</li>
                        <li>Implemente buffs aplicando <code>GameplayEffects</code> conforme rank retornado pelo servidor, exibindo aura Niagara correspondente.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>WB_GensLobby</code>, conecte botões “Entrar Vanert/Dupren” a chamadas <code>SolicitarInscricao</code> que enviam 0xF8:0x00.</li>
                        <li>Atualize a lista de missões preenchendo <code>ListView</code> com dados da Data Table e marcando concluídas ao receber 0xF8:0x05.</li>
                        <li>Mostre rank atual em <code>WB_GensRanking</code> com <em>Sort Custom</em> usando a pontuação recebida.</li>
                        <li>Ao aplicar buff, chame <em>Apply Gameplay Effect to Self</em> com os valores carregados de <code>DT_GensBuffs</code>.</li>
                        <li>Agende reset semanal com <em>Timer by Event</em> lendo configuração <code>ResetDay</code> no Data Table.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Ingressar ou sair de uma facção reflete imediatamente no HUD e nas habilidades.</li>
                        <li>Missões e pontos diários batem com os registros do servidor.</li>
                        <li>Buffs corretos são aplicados/removidos em cada faixa de rank.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-20">
                    <h3>Receita 20 — Cash Shop e entrega de itens</h3>
                    <p class="recipe-intro">Porta o XShop com catálogo dinâmico, carrinho e integração com inventário/banco.</p>
                    <h4>Copie do projeto original</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIInGameShop.cpp</code>, <code>NewUIInGameShop.h</code> e recursos em <code>Interface/XShop</code>.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/CashShop.cpp</code>, <code>CashShopDBSet.cpp</code> e <code>CashShopSocket.cpp</code>.</li>
                        <li>Arquivos <code>Data/ShopItemList.txt</code>, <code>Data/CashShopPackage.txt</code>, <code>Data/CashItemList.txt</code>.</li>
                    </ul>
                    <h4>Monte na Unreal</h4>
                    <ol>
                        <li>Construa <code>WB_CashShop</code> com abas, vitrine <code>TileView</code> e painel de detalhes com pré-visualização do item.</li>
                        <li>Implemente <code>UCashShopComponent</code> gerenciando saldo (WCoin, GoblinPoint), carrinho e pedidos pendentes.</li>
                        <li>Converta tabelas do XShop em <code>DT_CashCatalog</code> e <code>DT_CashPackages</code>, incluindo caminhos das texturas originais.</li>
                        <li>Ao confirmar compra, envie pacote 0xD2 com itens do carrinho; processe resposta 0xD3 atualizando saldo e disparando feedback visual.</li>
                        <li>Implemente caixa de presentes <code>WB_CashMailbox</code> que lista entregas (pacote 0xD6) e permite resgatar direto para o inventário.</li>
                    </ol>
                    <h4>Fluxo Blueprint</h4>
                    <ol class="blueprint-list">
                        <li>No <code>WB_CashShop</code>, use <em>Event Construct</em> para carregar Data Table e preencher abas com <em>Filter by Tag</em>.</li>
                        <li>Adicione animação de destaque quando um item for adicionado ao carrinho e reproduza áudio importado do cliente clássico.</li>
                        <li>Implemente confirmação com <em>Modal</em> exibindo custos e saldo restante antes de enviar o pacote 0xD2.</li>
                        <li>Ao receber 0xD3, atualize saldo e chame <code>AtualizarHUDMoedasPremium</code> no HUD principal.</li>
                        <li>Quando o jogador abrir o baú de presentes, chame <code>SolicitarEntrega</code> enviando 0xD6:0x02 para mover item ao inventário.</li>
                    </ol>
                    <h4>Checklist final</h4>
                    <ul>
                        <li>Catalogo reflete descrições, ícones e preços originais.</li>
                        <li>Compras atualizam saldo e entregam itens sem inconsistências.</li>
                        <li>Logs registram todas as transações para auditoria educativa.</li>
                    </ul>
                </article>
                <article class="recipe-card" data-recipe="receita-21">
                    <h3>Receita 21 — Interfaces completas 1:1 (todas as janelas)</h3>
                    <p class="recipe-intro">Uma receita de bolo para reconstruir <strong>todas</strong> as janelas do
                        <em>NewUI</em>: NPCs, eventos, opções, mensagens, guilda, comércio e alertas exatamente como o cliente
                        clássico, com texturas originais e integração de rede.</p>
                    <h4>Ingredientes do clássico</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIManager.cpp</code> — registra janelas, atalhos e dependências
                            globais do <em>NewUI</em>.</li>
                        <li><code>Source Main 5.2/source/NewUICommonMessageBox.cpp</code>,
                            <code>NewUIOptionWindow.cpp</code>, <code>NewUIInventoryCtrl.cpp</code>,
                            <code>NewUITrade.cpp</code>, <code>NewUIGuildWindow.cpp</code>,
                            <code>NewUIPartyWindow.cpp</code>, <code>NewUIQuestProgress.cpp</code>, <code>NewUIEvent.cpp</code>
                            e todos os arquivos <code>source/NewUI*</code>.</li>
                        <li><code>Source Main 5.2/source/UIControls.h</code> e <code>NewUIButton.cpp</code> — comportamento
                            de botões, abas e atalhos especiais (CTRL, ALT, SHIFT).</li>
                        <li>Pastas <code>Data/Interface</code>, <code>Data/Interface/Custom</code>,
                            <code>Data/Mark</code>, <code>Data/WorldInterface</code> e sons em <code>Data/Sounds</code>.</li>
                        <li>Arquivos de texto <code>Data/Local/GlobalText.txt</code>, <code>MsgBox.txt</code>,
                            <code>ToolTip.txt</code> e <code>EventMsg.txt</code> para legendas e mensagens.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/Protocol.cpp</code>,
                            <code>ItemMove.cpp</code> e <code>DataServerProtocol.cpp</code> — subcódigos de cada janela
                            (trade, guild, cash shop, personal store, eventos, opções).</li>
                    </ul>
                    <h4>Modo de preparo na Unreal (passos detalhados)</h4>
                    <ol>
                        <li><strong>Passo 1 — Mise en place dos assets:</strong> use o conversor BMD/FBX para transformar as
                            texturas da pasta <code>Data/Interface</code>, ícones de <code>Data/Mark</code> e molduras em PNG.
                            Importe para <code>Content/UI/Legacy</code> mantendo subpastas por janela.</li>
                        <li><strong>Passo 2 — Defina a base:</strong> crie o módulo/folder <code>UIFramework</code> contendo
                            <code>UWindowRegistry</code>, <code>UUIAudioLibrary</code> e material padrão de borda replicando
                            <code>newui_frame_*</code>.</li>
                        <li><strong>Passo 3 — Widget mestre:</strong> implemente <code>WB_WindowBase</code> com molduras,
                            barra de título, botões fechar/minimizar, atalhos (ESC, Enter) e eventos <code>OnAbrir</code>,
                            <code>OnFechar</code>, <code>OnSolicitarPacote</code>.</li>
                        <li><strong>Passo 4 — Cadastro das janelas:</strong> no <code>UWindowRegistry</code>, registre cada
                            janela (Inventário, Personagem, Guilda, Trade, Quest, Eventos, Cash Shop, Opções, Mensagens,
                            Duelo, Mini-mapa) com classe do widget, textura base, sons, atalhos e pacotes necessários.</li>
                        <li><strong>Passo 5 — Widgets especializados:</strong> crie derivados de <code>WB_WindowBase</code>
                            como <code>WB_InventoryWindow</code>, <code>WB_CharacterWindow</code>, <code>WB_QuestJournal</code>,
                            <code>WB_NpcShop</code>, <code>WB_GuildPanel</code>, <code>WB_PartySearch</code>,
                            <code>WB_EventBoard</code>, <code>WB_MessageBox</code>, <code>WB_OptionsWindow</code> e
                            <code>WB_PersonalStore</code>.</li>
                        <li><strong>Passo 6 — Componentes reutilizáveis:</strong> construa <code>WB_TabButton</code>,
                            <code>WB_ListHeader</code>, <code>WB_ItemSlot</code> e <code>WB_AmountSpinner</code> replicando os
                            controles descritos em <code>UIControls.h</code>.</li>
                        <li><strong>Passo 7 — Sons e feedback:</strong> preencha <code>UUIAudioLibrary</code> com os cliques e
                            alertas originais. Garanta que cada janela registre qual som usar ao abrir, confirmar e fechar.</li>
                        <li><strong>Passo 8 — Roteador central:</strong> implemente <code>UIRouterComponent</code> no
                            <code>PlayerController</code> para abrir/fechar janelas via <code>UWindowRegistry</code>, evitar
                            sobreposição, controlar foco e emitir eventos globais.</li>
                        <li><strong>Passo 9 — Textos e tooltips:</strong> converta <code>GlobalText.txt</code>,
                            <code>MsgBox.txt</code>, <code>ToolTip.txt</code> e <code>EventMsg.txt</code> em Data Tables;
                            crie função <code>GetTextoGlobal</code> e use <em>Bindings</em> para preencher rótulos, botões e
                            mensagens automaticamente.</li>
                        <li><strong>Passo 10 — Integração de rede:</strong> conecte cada janela aos pacotes equivalentes
                            (<code>0x3F/0x3C</code> trade, <code>0x6D</code> guild, <code>0x2F</code> quest, <code>0xF6</code>
                            eventos, <code>0xD2</code> cash shop). Use <code>UNetworkBridgeSubsystem</code> para atualizar UI
                            quando respostas chegarem.</li>
                        <li><strong>Passo 11 — Persistência local:</strong> para janelas com configurações (Options, Interface,
                            atalhos), salve valores em <code>SaveGame</code> e replique comportamento de <code>NewUIOption</code>.</li>
                        <li><strong>Passo 12 — Documentação visual:</strong> adicione comentários e capturas no Designer
                            indicando qual arquivo original inspirou cada widget, ajudando iniciantes a revisar depois.</li>
                    </ol>
                    <h4>Cobertura Blueprint & automações</h4>
                    <ol class="blueprint-list">
                        <li>No <code>PlayerController</code>, configure <em>InputAction</em> (I, C, V, G, P, O, K, B)
                            chamando <code>UIRouterComponent-&gt;AlternarJanela</code> com a chave cadastrada no
                            <code>UWindowRegistry</code>.</li>
                        <li>Dentro do <code>WB_WindowBase</code>, associe o botão fechar ao evento <code>OnFechar</code>,
                            reproduza áudio da <code>UUIAudioLibrary</code> e chame
                            <code>UIRouterComponent-&gt;FecharJanela</code> para manter o estado sincronizado.</li>
                        <li>Crie <code>WB_WindowAnimator</code> (Blueprint Function Library) com funções
                            <code>AbrirComFade</code> e <code>FecharComSlide</code> usando <em>Timeline</em> para replicar o
                            movimento suave do cliente clássico.</li>
                        <li>Para janelas com abas (Guilda, Quest, Eventos), utilize <em>Widget Switcher</em> preenchido com
                            dados da Data Table e destaque a aba ativa alterando material da borda.</li>
                        <li>Implemente <code>WB_GlobalOverlay</code> que recebe notificações do <code>UIRouter</code> e exibe
                            balões, tooltips e mensagens de sistema (trade, convite de party, alertas de evento).</li>
                        <li>Adicione <code>UIAutomationComponent</code> que percorre janelas registradas, valida widgets
                            obrigatórios e registra no log itens ausentes para alunos corrigirem.</li>
                    </ol>
                    <h4>Teste de forno e apresentação</h4>
                    <ul>
                        <li>Todos os atalhos abrem a janela correta com textura e som originais, e o <code>UIRouter</code>
                            impede janelas duplicadas.</li>
                        <li>Textos e tooltips são carregados das Data Tables sem strings vazias ou fora do idioma.</li>
                        <li>Pacotes de rede atualizam conteúdo imediatamente (trade, guild, quest, cash shop) e registram logs
                            para auditoria didática.</li>
                        <li>Fechar e reabrir qualquer janela preserva posição, abas e animações de entrada/saída.</li>
                    </ul>
                    <div class="recipe-mapping">
                        <h4>Arquivos de referência</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Elemento</th>
                                    <th>Unreal</th>
                                    <th>Original</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Registro de janelas</td>
                                    <td><code>UWindowRegistry</code> + <code>UIRouterComponent</code></td>
                                    <td><code>NewUIManager::CreateInterface</code></td>
                                </tr>
                                <tr>
                                    <td>Layout padrão</td>
                                    <td><code>WB_WindowBase</code> + materiais legados</td>
                                    <td><code>NewUICommonMessageBox::Create</code></td>
                                </tr>
                                <tr>
                                    <td>Textos e tooltips</td>
                                    <td><code>Data Table GlobalText</code></td>
                                    <td><code>GlobalText.txt</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </article>
            </div>
        </section>

        <section id="atlas-unreal" class="panel panel--atlas">
            <h2>Enciclopédia de Sistemas — clássico &rarr; Unreal Engine 5</h2>
            <p>
                Este atlas reúne cada área funcional do <em>Main 5.2</em> e do <em>MuServer Update 15</em> com a tradução
                direta para Blueprints, componentes C++ e ferramentas da <strong>Unreal Engine 5</strong>. Leia cada cartão
                como um mapa: ele mostra quais arquivos abrir, quais assets reutilizar e a ordem das ações para obter o
                mesmo resultado sem precisar interpretar código sozinho.
            </p>
            <div class="callouts">
                <p class="callout callout--tip"><strong>Como usar:</strong> escolha o cartão da área que está trabalhando,
                    siga a lista “Na Unreal” em sequência e marque o checklist antes de avançar.</p>
                <p class="callout callout--warning"><strong>Importante:</strong> sempre compare com os logs do servidor e
                    com o cliente clássico após cada implementação para garantir 100% de compatibilidade.</p>
            </div>
            <div class="atlas-grid">
                <article class="atlas-card">
                    <h3>Interface e UX</h3>
                    <p><strong>Objetivo:</strong> reconstruir todas as janelas do <code>NewUI</code> com Widgets Unreal.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>NewUIMainFrameWindow.cpp</code> — HUD, menus e botões.</li>
                        <li><code>NewUIManager.cpp</code> — fluxo de abertura/fechamento.</li>
                        <li><code>NewUIInventoryCtrl.cpp</code>, <code>NewUIPartyWindow.cpp</code>, <code>NewUICustomMessageBox.cpp</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Modele Widgets <code>WB_HUDMain</code>, <code>WB_MenuLateral</code>, <code>WB_JanelasSecundarias</code> seguindo as texturas importadas.</li>
                        <li>Crie um <code>UUIFlowSubsystem</code> com funções <code>AbrirJanela</code>, <code>FecharJanela</code> e <code>AlternarHUD</code>.</li>
                        <li>Implemente navegação por teclado/mouse usando <em>Widget Switchers</em> e <code>Focus Target</code>.</li>
                        <li>Adicione tabela <code>DT_UIHotkeys</code> para mapear atalhos iguais aos do <code>KeyManager.cpp</code>.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>Janelas respeitam posições e atalhos do cliente clássico.</li>
                        <li>Os sons de abrir/fechar são disparados pela mesma estrutura de dados de <code>DSPlaySound</code>.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Personagem, Movimento e Animações</h3>
                    <p><strong>Objetivo:</strong> espelhar movimento, dash, montarias e câmera.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>MoveCommand.cpp</code>, <code>ZzzCharacter.cpp</code>, <code>NewCharacterModel.cpp</code>.</li>
                        <li><code>ProtocolSend::SendRequestMove</code> e confirmações 0x1C no servidor.</li>
                        <li><code>PetAction.cpp</code> para montarias.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Configure <code>Enhanced Input</code> para WASD, Dash (duplo clique) e montaria (tecla <code>A</code>).</li>
                        <li>Use <code>CharacterMovement</code> com <code>Orient Rotation to Movement</code> e <code>Braking Deceleration = 2048</code>.</li>
                        <li>Implemente <code>UMovementCommandComponent</code> para fila de passos e teleporte via <code>Server Corrections</code>.</li>
                        <li>Adicione animação de montaria usando <em>Montage Slots</em> sincronizados com o servidor (pacote 0x2D).</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>O personagem nunca desliza após parar (valide no console do GameServer).</li>
                        <li>Montar e desmontar atualiza HUD e velocidade instantaneamente.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Combate, Skills e Efeitos</h3>
                    <p><strong>Objetivo:</strong> garantir que dano, buffs e debuffs funcionem como no clássico.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>SkillManager.cpp</code>, <code>MagicInf.cpp</code>, <code>GCMagicSend.cpp</code>.</li>
                        <li><code>Attack.cpp</code> e <code>SkillEffect.cpp</code> no GameServer.</li>
                        <li>Textos de efeito em <code>Data/Local/SkillTooltip.txt</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Crie <code>UAbilityDataTable</code> com dano, alcance, animação e efeitos de partículas.</li>
                        <li>Implemente <code>UCombatComponent</code> com <em>Ability Queue</em> e validações de mana/tempo de recarga.</li>
                        <li>Conecte com <code>UNetworkBridgeSubsystem</code> enviando 0x11/0x19 e recebendo 0x1A/0x1B.</li>
                        <li>Use <em>Niagara</em> para partículas reaproveitando texturas originais de <code>Effects</code>.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>Dano exibido combina com os valores do servidor.</li>
                        <li>Buffs aparecem no HUD e expiram conforme <code>SkillEffect.cpp</code>.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>NPCs, Missões e Economia</h3>
                    <p><strong>Objetivo:</strong> oferecer todas as interações sociais (lojas, quests, trade, refinamento).</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>NewUINPCShop.cpp</code>, <code>QuestInfoWindow.cpp</code>, <code>NewUITrade.cpp</code>.</li>
                        <li><code>Quest.cpp</code>, <code>Shop.cpp</code>, <code>Warehouse.cpp</code> no GameServer.</li>
                        <li>Scripts SQL <code>ShopItem</code>, <code>QuestProgress</code>, <code>WarehouseItems</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Monte Widgets <code>WB_NPCShop</code>, <code>WB_Quest</code> e <code>WB_Trade</code> reutilizando componentes do inventário.</li>
                        <li>Adicione <code>UNPCInteractionComponent</code> com função <code>SolicitarServico</code> para enviar códigos 0x30–0x3D, 0x6F e 0x7A.</li>
                        <li>Integre com <code>UQuestComponent</code> que salva progresso no DataServer antes de liberar recompensas.</li>
                        <li>Sincronize valores de Zen, Joias e itens com tabelas SQL através de <code>Stored Procedures</code> chamadas pelo GameServer.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>Compras e vendas refletem imediatamente no inventário e no Zen.</li>
                        <li>Quests mostram objetivos, contadores e recompensas idênticos ao original.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Duelo 1x1 &amp; Arena</h3>
                    <p><strong>Objetivo:</strong> recriar o sistema de duelos, placar em tempo real e lista de espectadores.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIDuelWindow.cpp</code>, <code>NewUIDuelWindow.h</code> e <code>CDuelMgr.cpp</code>.</li>
                        <li><code>Source Main 5.2/source/ProtocolSend.cpp</code> &mdash; funções <code>SendDuelRequest</code>, <code>SendDuelAnswer</code>, <code>SendDuelQuit</code>.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/DuelSystem.cpp</code> e <code>DuelSystem.h</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Crie <code>WB_DuelHUD</code> com barras de HP dos dois jogadores, cronômetro e lista de espectadores usando dados de <code>CDuelMgr::m_mapDuelUser</code>.</li>
                        <li>Implemente <code>UDuelComponent</code> (Actor Component) no personagem, expondo eventos <code>SolicitarDuel</code>, <code>ResponderDuel</code> e <code>AtualizarPlacar</code>.</li>
                        <li>Na camada de rede, serialize pacotes 0xAA subcódigos 0x01–0x07 espelhando <code>ProtocolSend::SendDuel*</code> e valide respostas com <code>DuelSystem::GDuelRequestRecv</code>.</li>
                        <li>Para o visual, importe texturas <code>Interface\\newui_duel*.jpg</code> e utilize <em>UMG Progress Bars</em> com cores originais.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>Solicitar duelo abre janela modal com tempos idênticos ao clássico.</li>
                        <li>O placar pisca em vermelho quando um jogador atinge zero HP e o GameServer encerra a sessão corretamente.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Empire Guardian (Imperial Guardian)</h3>
                    <p><strong>Objetivo:</strong> suportar filas, HUD progressiva e fechamento automático das waves cooperativas.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIEmpireGuardianNPC.cpp</code> e <code>NewUIEmpireGuardianResult.cpp</code>.</li>
                        <li><code>Source Main 5.2/Global Release/Data/Interface/EmpireGuardian</code> &mdash; molduras e ícones.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/ImperialGuardian.cpp</code> e <code>ImperialGuardian.h</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Crie <code>WB_EmpireGuardianLobby</code> com slots de party e cronômetro usando dados do pacote 0xF7 subcódigo 0x10.</li>
                        <li>Implemente <code>AEmpireGuardianManager</code> que ativa <code>LevelStream</code> por wave, posiciona portais e aplica restrições de tempo conforme <code>ImperialGuardian.cpp</code>.</li>
                        <li>Construa HUD in-game <code>WB_EmpireGuardianHUD</code> exibindo etapa atual, contagem de monstros e objetivos convertendo textos de <code>GlobalText.lua</code>.</li>
                        <li>Reproduza efeitos luminosos das portas com <em>Niagara</em> reaproveitando texturas <code>Effects\\glow_guardian.tga</code>.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>O lobby impede entrada após o limite de jogadores/tempo enviado pelo GameServer.</li>
                        <li>Cada wave conclui quando o servidor envia <code>F7:0x11</code> e os objetivos visuais são atualizados instantaneamente.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Cursed Temple (Battle)</h3>
                    <p><strong>Objetivo:</strong> recriar o modo competitivo com times Holy/Illusion, HUD, minimapa e lógica de rounds.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/CNewUICursedTempleSystem.cpp</code> e <code>NewUICursedTempleWindow.cpp</code>.</li>
                        <li>Texturas em <code>Global Release/Data/Interface/CursedTemple</code> (barras, ícones de equipes).</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/CursedTempleEvent.cpp</code> e <code>CursedTempleEvent.h</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Desenvolva <code>WC_CursedTempleHUD</code> com barra de pontos por equipe, contagem de relíquias e feed de kills.</li>
                        <li>Implemente <code>UCursedTempleComponent</code> para personagens, tratando pacotes 0xF8 (match info) e 0xF6 (pontuação).</li>
                        <li>Construa minimapa dedicado com <code>SceneCapture2D</code> e materiais mascarados usando as texturas originais.</li>
                        <li>Crie efeitos de captura com <em>Niagara</em> (auras roxas/azuis) sincronizados com o estado do objetivo enviado pelo servidor.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>HUD alterna automaticamente entre fases Preparação &rarr; Combate &rarr; Resultado conforme os pacotes.</li>
                        <li>A pontuação bate com os logs de <code>CursedTempleEvent.cpp</code> e a câmera espectador ativa após derrota.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Doppelganger</h3>
                    <p><strong>Objetivo:</strong> implementar filas, portais, avisos visuais e lógica de progressão do evento.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIDoppelGangerWindow.cpp</code> e <code>DoppelGangerInfo.cpp</code>.</li>
                        <li>Textos em <code>Data/Local/doppelganger.txt</code> e texturas em <code>Interface/DoppelGanger</code>.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/Doppelganger.cpp</code> e scripts <code>Event/DoppelGanger/*.txt</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Modele <code>WB_DoppelgangerLobby</code> com requisitos de nível, consumo de convite e horário consultando <code>DoppelGangerInfo::CheckEnterCondition</code>.</li>
                        <li>Implemente <code>ADoppelgangerTimeline</code> que controla spawn de monstros, NPC guia e fase final conforme <code>Doppelganger.cpp</code>.</li>
                        <li>Adicione HUD com barra de tempo restante, objetivos e indicador da estátua usando ícones originais convertidos.</li>
                        <li>Use <em>Sequencer</em> para animar a abertura do portal e o colapso final conforme scripts de evento.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>O lobby bloqueia jogadores sem convite ou fora do horário configurado pelo servidor.</li>
                        <li>O evento encerra com recompensas e mensagens iguais às do cliente clássico.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Lucky Coin &amp; Lucky Item</h3>
                    <p><strong>Objetivo:</strong> replicar a economia de moedas e criação de itens sorteados com feedback visual.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIExchangeLuckyCoin.cpp</code> e <code>NewUILuckyItemWnd.cpp</code>.</li>
                        <li>Dados de itens em <code>Data/LuckyItemOption.txt</code> e <code>Data/Item.txt</code>.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/LuckyCoinSystem.cpp</code> e <code>ItemAddOption.cpp</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Crie <code>WB_LuckyCoinExchange</code> com abas (Trocar, Recompensas, Histórico) e animações de brilho importando texturas <code>Interface\\LuckyCoin</code>.</li>
                        <li>Implemente <code>ULuckyEconomyComponent</code> responsável por saldo, requisições de troca (pacotes 0xF3 subcódigo 0x03) e salvamento via DataServer.</li>
                        <li>Monte tabela <code>DT_LuckyRewards</code> convertendo <code>LuckyItemOption.txt</code> para CSV &rarr; Data Table.</li>
                        <li>Adicione efeitos <em>Niagara</em> e <em>Timeline</em> para revelar itens raros, espelhando o brilho dourado do cliente original.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>Trocas atualizam saldo local e no servidor sem atraso perceptível.</li>
                        <li>Itens criados carregam opções extras idênticas às enviadas pelo <code>LuckyCoinSystem.cpp</code>.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Refinaria Jewel of Harmony</h3>
                    <p><strong>Objetivo:</strong> converter o fluxo de refinaria com interface, tabelas e feedback luminoso.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/UIJewelHarmony.cpp</code>, <code>UIJewelHarmony.h</code>.</li>
                        <li>Arquivos <code>Data/JewelOfHarmonyOption.bmd</code> e <code>Data/JewelOfHarmonyMix.bmd</code>.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/JewelOfHarmonySystem.cpp</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Converta os arquivos <code>.bmd</code> para JSON utilizando o utilitário <code>BMD_FBX</code> adaptado ou ferramentas externas e importe como <code>DataTable</code>.</li>
                        <li>Modele <code>WB_JewelHarmony</code> com slots Arrastar/Soltar para item base, Jewel of Harmony e Jewel of Harmony Smelt.</li>
                        <li>Implemente <code>UHarmonyForgeComponent</code> que valida requisitos, envia pacote 0xF3 subcódigo 0x50 e aguarda resposta 0xF3:0x51.</li>
                        <li>Crie material instanciado com <em>panner</em> e <em>emissive</em> para iluminar o item resultante replicando o efeito azul do cliente clássico.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>A UI bloqueia combinações inválidas e mostra mensagens do servidor traduzidas do <code>GlobalText</code>.</li>
                        <li>O item refinado exibe opções extras idênticas aos registros convertidos dos arquivos <code>.bmd</code>.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Mundo, Monstros e Eventos</h3>
                    <p><strong>Objetivo:</strong> replicar mapas, respawns, IA e cronogramas de eventos.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>ZzzScene.cpp</code>, <code>MapServerManager.cpp</code>, arquivos <code>Data/World</code>.</li>
                        <li><code>MonsterAI.cpp</code>, <code>MonsterSetBase.txt</code>, <code>MonsterSkill.cpp</code>.</li>
                        <li><code>Event.cpp</code>, <code>BloodCastle.cpp</code>, <code>DevilSquare.cpp</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Recrie terrenos com <em>Landscape</em> e aplique materiais com <code>Runtime Virtual Texture</code>.</li>
                        <li>Construa <code>Data Layers</code> por mapa para carregar apenas o necessário (Lorencia, Noria, etc.).</li>
                        <li>Implemente <code>AMonsterSpawner</code> lendo <code>DT_MonsterSpawns</code> gerados a partir de <code>MonsterSetBase.txt</code>.</li>
                        <li>Crie <em>State Machines</em> de IA (Patrulha, Perseguir, Atacar, Retornar) e conecte eventos de servidor (0x18, 0x1E).</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>Spawns e respawns respeitam limites e horários dos arquivos originais.</li>
                        <li>Eventos exibem mensagens globais e prêmios iguais aos configurados em <code>Event.cpp</code>.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Chaos Castle &amp; Chaos Ranking</h3>
                    <p><strong>Objetivo:</strong> reconstruir o evento de eliminação com armadilhas, scoreboard e ranking semanal.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIChaosCastle.cpp</code> e <code>NewUIChaosCastle.h</code> — HUD, regras de entrada e efeitos.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/ChaosCastle.cpp</code> — lógica de rounds, armadilhas e mortes.</li>
                        <li><code>Data/Event/ChaosCastleSetting.txt</code> e <code>Data/Item/ChaosCastleReward.txt</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Construa um <code>AChaosCastleArena</code> com <em>Level Sequence</em> controlando a queda das plataformas e colisores destrutíveis.</li>
                        <li>Modele <code>WB_ChaosCastleHUD</code> com contadores de sobreviventes, timers e slots de recompensa seguindo <code>NewUIChaosCastle::Render</code>.</li>
                        <li>Implemente <code>UChaosCastleComponent</code> no <code>PlayerState</code> para replicar mortes, pontos e ranking (pacotes 0x95, 0xB0).</li>
                        <li>Importe tabelas de armadilhas/recompensas para <code>DT_ChaosCastleConfig</code> e conecte ao GameServer para validação.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>Plataformas e armadilhas ativam no mesmo timing descrito em <code>ChaosCastle.cpp</code>.</li>
                        <li>Ranking semanal registra vitórias e distribui recompensas usando os dados convertidos dos arquivos <code>.txt</code>.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Sistema Gens</h3>
                    <p><strong>Objetivo:</strong> implementar facções Vanert/Dupren com missões diárias, ranqueamento e buffs.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIGensWindow.cpp</code>, <code>NewUIGensRanking.cpp</code>.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/GensSystem.cpp</code> e <code>GensSystem.h</code>.</li>
                        <li><code>Data/GensSystem.txt</code>, <code>Data/Quest/GensQuest.txt</code>, <code>Data/Local/GensText.txt</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Crie <code>WB_GensLobby</code> e <code>WB_GensRanking</code> utilizando <em>Widget Switcher</em> para alternar entre inscrição, recompensas e classificação.</li>
                        <li>Implemente <code>UGensFactionComponent</code> (no <code>PlayerState</code>) para sincronizar pontos, missões e buffs recebidos do servidor (pacotes 0xF8 sub 0x03/0x04).</li>
                        <li>Monte <code>DT_GensRewards</code> e <code>DT_GensQuests</code> convertendo os arquivos <code>.txt</code> para CSV e importando como <em>Data Tables</em>.</li>
                        <li>Reproduza os buffs visuais aplicando <em>Materials</em> dinâmicos e efeitos Niagara de acordo com o rank configurado em <code>GensSystem.cpp</code>.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>Pontos de contribuição atualizam imediatamente após completar missões ou derrotar jogadores rivais.</li>
                        <li>Ranking exibe posição, facção e recompensas iguais às calculadas no servidor clássico.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Cash Shop (XShop)</h3>
                    <p><strong>Objetivo:</strong> portar a loja em tempo real com catálogo dinâmico, carrinho e entregas no inventário.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>Source Main 5.2/source/NewUIInGameShop.cpp</code>, <code>NewUIInGameShop.h</code> e assets em <code>Interface/XShop</code>.</li>
                        <li><code>Source MuServer Update 15/GameServer/GameServer/CashShop.cpp</code> e <code>CashShopDBSet.cpp</code>.</li>
                        <li>Bases <code>Data/ShopItemList.txt</code>, <code>Data/CashShopPackage.txt</code>, <code>Data/CashItemList.txt</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Modele <code>WB_CashShop</code> com abas (Novidades, Pacotes, Consumíveis) usando <code>ListView</code> e <em>TileView</em> para o catálogo.</li>
                        <li>Implemente <code>UCashShopComponent</code> com carrinho local, saldo em WCoin/GP e integração com o servidor via pacotes 0xD2/0xD3.</li>
                        <li>Converta tabelas do XShop para <code>DT_CashCatalog</code> e <code>DT_CashPackages</code> com ícones referenciando texturas originais.</li>
                        <li>Automatize a entrega criando um <code>CashMailbox</code> que injeta itens no inventário (pacote 0xD6) e registra logs educativos em <code>Saved/Logs/cash_shop.csv</code>.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>Preços, descrições e pré-visualizações coincidem com <code>ShopItemList.txt</code> convertido.</li>
                        <li>Compras adicionam itens automaticamente ao inventário ou baú de presentes replicando <code>CashShop.cpp</code>.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Rede, Banco e Serviços</h3>
                    <p><strong>Objetivo:</strong> manter protocolos, segurança e persistência idênticos.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>ProtocolSend.cpp</code>, <code>ProtocolCore.cpp</code>, <code>Protocol.cpp</code>.</li>
                        <li><code>ConnectServer.cpp</code>, <code>JoinServerProtocol.cpp</code>, <code>DataServerProtocol.cpp</code>.</li>
                        <li>Scripts SQL <code>Account</code>, <code>Character</code>, <code>Warehouse</code>.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Implemente <code>UNetworkBridgeSubsystem</code> usando <code>FSocket</code> + threads para leitura.</li>
                        <li>Crie <code>FPacketHeader</code>, <code>FPacketWriter</code> e <code>FPacketReader</code> replicando cabeçalhos C1/C3.</li>
                        <li>Implemente heartbeat (0x0E) com timers e reconexão automática.</li>
                        <li>Mapeie todas as estruturas persistentes para <code>USTRUCT</code> que serão convertidas em JSON/SQL nos serviços externos.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>Todos os pacotes do quadro “Protocolos” têm equivalente na Unreal.</li>
                        <li>Logs registram latência, erros e reconexões como nos serviços originais.</li>
                    </ul>
                </article>
                <article class="atlas-card">
                    <h3>Qualidade, Publicação e Operação</h3>
                    <p><strong>Objetivo:</strong> distribuir o remake com processos repetíveis e documentação clara.</p>
                    <h4>Arquivos clássicos</h4>
                    <ul>
                        <li><code>GameServer/LogProc.cpp</code>, <code>EventManagement.cpp</code>.</li>
                        <li>Pasta <code>tools/</code> e scripts de backup originais.</li>
                        <li>Anotações do guia (este documento) para checklist.</li>
                    </ul>
                    <h4>Na Unreal</h4>
                    <ol class="atlas-steps">
                        <li>Configure <code>Automation Tests</code> para login, inventário e combate usando <em>Functional Testing</em>.</li>
                        <li>Gere builds <em>Shipping</em> e <em>Test</em> com scripts <code>RunUAT BuildCookRun</code>.</li>
                        <li>Monte <code>StartAll.bat</code>, <code>StopAll.bat</code> e <code>BackupDB.bat</code> replicando os passos do original.</li>
                        <li>Crie um manual PDF com capturas de tela do remake e checklist para suporte.</li>
                    </ol>
                    <h4>Checklist</h4>
                    <ul>
                        <li>Builds podem ser recriadas com um único comando documentado.</li>
                        <li>Backups e restaurações do banco foram testados sem perda de dados.</li>
                    </ul>
                </article>
            </div>
        </section>

        <section id="protocolos" class="panel">
            <h2>Protocolos &amp; Pacotes Essenciais</h2>
            <p>
                Esta tabela reúne os pacotes que precisam ser implementados primeiro para que o remake funcione. Compare as
                estruturas com o cliente clássico e mantenha logs organizados.
            </p>
            <div class="table-wrapper">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Ação</th>
                            <th>Código</th>
                            <th>Origem</th>
                            <th>Destino</th>
                            <th>Referência</th>
                            <th>Notas para a Unreal</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Login</td>
                            <td><code>ProtocolHead::BOTH_CONNECT_LOGIN</code></td>
                            <td>Cliente</td>
                            <td>JoinServer</td>
                            <td><code>ProtocolSend::SendRequestLogInNew</code></td>
                            <td>Aplicar <code>BuxConvert</code>, enviar versão/serial corretos e aguardar retorno 0x01.</td>
                        </tr>
                        <tr>
                            <td>Lista de personagens</td>
                            <td><code>ProtocolHead::BOTH_CONNECT_CHARACTER</code></td>
                            <td>JoinServer</td>
                            <td>Cliente</td>
                            <td><code>ReceiveCharacterList</code> no cliente, <code>GDCharacterListRecv</code> no DataServer</td>
                            <td>Crie estruturas com nome, classe, nível e posição para preencher o widget de seleção.</td>
                        </tr>
                        <tr>
                            <td>Movimento</td>
                            <td><code>ProtocolHead::BOTH_MOVE</code> / <code>0x1B</code></td>
                            <td>Cliente</td>
                            <td>GameServer</td>
                            <td><code>ClientSendMoveCharacter</code>, <code>ProtocolCore</code> case 0x1B</td>
                            <td>Sincronize passos e caminhos; use <em>Server Authoritative Movement</em> na Unreal.</td>
                        </tr>
                        <tr>
                            <td>Posição</td>
                            <td><code>ProtocolHead::BOTH_POSITION</code> / <code>0x1C</code></td>
                            <td>GameServer</td>
                            <td>Cliente</td>
                            <td><code>ReceiveMovePosition</code>, <code>gMove.CGTeleportRecv</code></td>
                            <td>Atualize posição confirmada e trate teleporte antes de atualizar câmera.</td>
                        </tr>
                        <tr>
                            <td>Itens no inventário</td>
                            <td><code>0x24</code> / subcódigos</td>
                            <td>Cliente &amp; GameServer</td>
                            <td>Cliente &amp; DataServer</td>
                            <td><code>gItemManager.CGItemMoveRecv</code>, <code>GDWarehouseItemRecv</code></td>
                            <td>Converta slots linha/coluna e mantenha histórico para desfazer ações.</td>
                        </tr>
                        <tr>
                            <td>Chat</td>
                            <td><code>0x00</code></td>
                            <td>Cliente</td>
                            <td>GameServer</td>
                            <td><code>CGChatRecv</code>, <code>ProtocolCore</code></td>
                            <td>Implemente filtro básico na Unreal e mostre mensagens no chat replicado.</td>
                        </tr>
                        <tr>
                            <td>Ataque básico</td>
                            <td><code>PROTOCOL_CODE2</code></td>
                            <td>Cliente</td>
                            <td>GameServer</td>
                            <td><code>gAttack.CGAttackRecv</code></td>
                            <td>Envie ID do alvo, direção e animação; valide se o servidor responde com dano/efeito.</td>
                        </tr>
                        <tr>
                            <td>Keep alive</td>
                            <td><code>ProtocolHead::SERVER_CONNECT</code> / <code>0x0E</code></td>
                            <td>Cliente &amp; GameServer</td>
                            <td>Ambos</td>
                            <td><code>SendPingTest</code>, <code>CGLiveClientRecv</code></td>
                            <td>Implemente heartbeat com timers na Unreal para detectar quedas rapidamente.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="callouts">
                <p class="callout callout--tip"><strong>Prática:</strong> Antes de implementar um pacote na Unreal, capture o
                    tráfego do cliente original e anote bytes relevantes. Reproduza exatamente e só depois modernize.</p>
                <p class="callout"><strong>Segurança:</strong> Mantenha validações de servidor (nível, estado) intactas para
                    evitar exploits mesmo em versões de estudo.</p>
            </div>
        </section>

        <section id="banco-dados" class="panel">
            <h2>Banco de Dados e Configuração</h2>
            <p>
                O DataServer espera um conjunto específico de tabelas e stored procedures. Para quem nunca administrou banco,
                siga os passos abaixo e use scripts de teste antes de conectar o cliente da Unreal.
            </p>
            <div class="guide-grid">
                <article class="guide-card">
                    <h3>Estrutura mínima</h3>
                    <ul>
                        <li>Tabela <code>Account</code> com colunas <code>memb___id</code>, <code>memb__pwd</code>,
                            <code>AccountLevel</code>, <code>bloc_code</code> e <code>ConnectStat</code>.</li>
                        <li>Tabela <code>Character</code> com nome, classe, nível, mapa, coordenadas e inventário binário.</li>
                        <li>Tabela <code>Warehouse</code> para itens do baú e <code>Guild</code> para informações de guilda.</li>
                        <li>Stored procedures equivalentes a <code>dbo.sp_CreateCharacter</code>,
                            <code>dbo.sp_DeleteCharacter</code>, <code>dbo.sp_GetWarehouse</code>.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Scripts de inicialização</h3>
                    <ul>
                        <li>Crie um script SQL que gera usuários de teste, personagens e inventários básicos.</li>
                        <li>Implemente backup automático diário (SQL Server Agent ou tarefas agendadas).</li>
                        <li>Valide permissões: o DataServer utiliza um usuário com <em>db_owner</em> limitado ao banco do jogo.</li>
                        <li>Mantenha um script de restauração rápida para voltar ao estado inicial durante treinamentos.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Configuração dos serviços</h3>
                    <ul>
                        <li>Atualize arquivos <code>*.ini</code> dos serviços com IP local, portas e credenciais do banco.</li>
                        <li>Teste a conexão com ferramentas simples (por exemplo, <code>sqlcmd</code> ou scripts Python) antes de
                            rodar o DataServer.</li>
                        <li>Registre no diário de bordo o endereço de cada serviço (ConnectServer, JoinServer, GameServer).</li>
                        <li>Configure firewall para permitir tráfego nas portas especificadas.</li>
                    </ul>
                </article>
                <article class="guide-card">
                    <h3>Monitoramento e diagnóstico</h3>
                    <ul>
                        <li>Implemente planilha ou dashboard para acompanhar <code>gServerManager[index].m_PacketTime</code> e
                            detectar travamentos.</li>
                        <li>Automatize exportação de logs do DataServer para análise posterior.</li>
                        <li>Crie scripts que limpem personagens antigos mas mantenham contas de teste.</li>
                        <li>Documente como reexecutar scripts quando atualizar pacotes ou formatos de inventário.</li>
                    </ul>
                </article>
            </div>
            <div class="callouts">
                <p class="callout callout--warning"><strong>Cuidado:</strong> Nunca teste comandos destrutivos em produção.
                    Use sempre um banco de dados local separado e backups antes de qualquer migração.</p>
            </div>
        </section>

        <section id="preparacao" class="panel">
            <h2>Preparação Inicial</h2>
            <div class="timeline" data-track="preparacao"></div>
        </section>

        <section id="trilha-geral" class="panel">
            <h2>Linha do Tempo Geral</h2>
            <p>Use esta linha do tempo como referência macro. Ela mostra como os módulos do cliente, da Unreal Engine 5 e do
                servidor se encaixam.</p>
            <div class="timeline" data-track="geral"></div>
        </section>

        <section id="frontend" class="panel">
            <h2>Trilha Cliente (Main 5.2)</h2>
            <p>
                O código do cliente original está em <code>Source Main 5.2/source</code>, com módulos de interface e sistemas
                de jogo escritos em C++. As etapas desta trilha ajudam a compreender a estrutura antes de portar ou adaptar
                funcionalidades para a Unreal Engine 5.
            </p>
            <div class="timeline" data-track="frontend"></div>
        </section>

        <section id="unreal" class="panel">
            <h2>Trilha Unreal Engine 5</h2>
            <p>
                Depois de entender o cliente clássico, estas etapas guiam a criação do remake dentro da Unreal Engine 5,
                conectando Blueprints, C++ e assets importados do projeto original.
            </p>
            <div class="timeline" data-track="unreal"></div>
        </section>

        <section id="backend" class="panel">
            <h2>Trilha Servidor (MuServer)</h2>
            <p>
                O servidor é dividido em serviços dedicados como <code>ConnectServer</code>, <code>JoinServer</code>,
                <code>GameServer</code> e outros dentro de <code>Source MuServer Update 15</code>. Esta trilha ensina como
                configurar, testar e integrar cada peça.
            </p>
            <div class="timeline" data-track="backend"></div>
        </section>

        <section id="laboratorios" class="panel">
            <h2>Laboratórios Guiados</h2>
            <p>
                Use estes roteiros práticos para testar cada módulo. Faça um laboratório por vez e anote o que funcionou ou
                não. Se ficar perdido, retorne ao mapa do código para localizar os arquivos citados.
            </p>
            <div class="labs">
                <article class="lab">
                    <h3>Laboratório 1 &mdash; Menu de Login na Unreal</h3>
                    <ol>
                        <li>Copie as texturas em <code>Source Main 5.2/Global Release/Data/Interface</code> para a pasta <code>Content/UI</code> do projeto Unreal.</li>
                        <li>Crie um <em>Widget Blueprint</em> chamado <code>WB_LoginMenu</code> com campos de usuário e senha.</li>
                        <li>Adapte o fluxo de <code>LoginWin.cpp</code> para Blueprints: valide campos e prepare um evento "Conectar".</li>
                        <li>Implemente uma chamada C++ que usa <code>ProtocolSend.cpp</code> como referência para enviar o pacote de login.</li>
                        <li>Teste com um botão "Modo Offline" que apenas imprime uma mensagem para confirmar o layout.</li>
                    </ol>
                </article>
                <article class="lab">
                    <h3>Laboratório 2 &mdash; Inventário Sincronizado</h3>
                    <ol>
                        <li>Mapeie a estrutura de slots em <code>Source Main 5.2/source/NewUIInventoryCtrl.cpp</code>.</li>
                        <li>Crie uma <em>Data Table</em> na Unreal com colunas para nome do item, ícone e tipo de slot.</li>
                        <li>Implemente um <code>ActorComponent</code> C++ que replica dados usando o exemplo de <code>Source MuServer Update 15/GameServer/GameServer/User.cpp</code>.</li>
                        <li>Monte um Widget <code>WB_Inventory</code> que atualiza slots quando o servidor enviar pacotes de <code>JSProtocol.cpp</code>.</li>
                        <li>Execute um teste multijogador local e observe se dois clientes recebem as mesmas atualizações.</li>
                    </ol>
                </article>
                <article class="lab">
                    <h3>Laboratório 3 &mdash; Combate Básico Online</h3>
                    <ol>
                        <li>Estude <code>Source Main 5.2/source/ZzzCharacter.cpp</code> para entender como danos são aplicados.</li>
                        <li>No GameServer, leia <code>GameServer/GameServer/SkillManager.cpp</code> e <code>Protocol.cpp</code> para mapear pacotes de ataque.</li>
                        <li>No projeto Unreal, crie uma <em>Ability</em> simples usando <em>Blueprint</em> ou C++ que chama um RPC confiável.</li>
                        <li>Imite a estrutura de pacotes do servidor com um <code>UStruct</code> C++ e envie os dados via <code>JSProtocol.cpp</code>.</li>
                        <li>Valide o resultado checando o log do servidor e os números de dano exibidos na HUD.</li>
                    </ol>
                </article>
                <article class="lab">
                    <h3>Laboratório 4 &mdash; Pacotes e Monitoramento</h3>
                    <ol>
                        <li>Capture pacotes com o cliente clássico realizando login, movimento e ataque. Salve os hexadecimais.</li>
                        <li>Implemente no módulo <code>NetworkBridge</code> da Unreal um log similar ao <code>Protocol.cpp</code>
                            que escreva cada cabeçalho recebido.</li>
                        <li>Teste o envio de um pacote de login pela Unreal e valide se o JoinServer responde com <code>result = 1</code>.</li>
                        <li>Ative o <code>PacketIN</code> do <code>Protocol.cpp</code> e compare byte a byte com os pacotes do remake.</li>
                        <li>Documente discrepâncias e ajuste serialização até que os logs fiquem idênticos.</li>
                    </ol>
                </article>
                <article class="lab">
                    <h3>Laboratório 5 &mdash; DataServer e Persistência</h3>
                    <ol>
                        <li>Execute scripts SQL para criar contas e personagens de teste.</li>
                        <li>Inicie o DataServer e verifique se <code>GDCharacterListRecv</code> retorna dados completos.</li>
                        <li>Conecte a Unreal e confirme se o inventário recebido bate com o banco (slots, itens e quantidades).</li>
                        <li>Realize uma troca de item no remake e observe <code>GDWarehouseItemSaveRecv</code> gravando a alteração.</li>
                        <li>Faça backup e restaure o banco para garantir que o processo está documentado.</li>
                    </ol>
                </article>
                <article class="lab">
                    <h3>Laboratório 6 &mdash; HUD completa na Unreal</h3>
                    <ol>
                        <li>Converta as texturas citadas em <code>NewUIMainFrameWindow.cpp</code> usando o método de
                            <code>ZzzTexture::OpenJpeg/OpenTga</code> (remova 24/16 bytes) e importe para <code>Content/UI/HUD</code>.</li>
                        <li>Monte os Widgets <code>WB_HUDMain</code> e <code>WB_Minimap</code> seguindo a Receita 1: combine
                            imagens base, barras e minimapa com máscaras circulares.</li>
                        <li>No <code>UEnsinoRemakeGameInstance</code>, crie um evento <code>OnStatusAtualizado</code> chamado
                            quando o <code>UNetworkBridgeSubsystem</code> processar pacotes de <code>ReceiveDamage</code> e
                            <code>ReceiveMovePosition</code>. Atualize HP/MP/AG/SD e a posição do minimapa.</li>
                        <li>Execute o cliente clássico em paralelo, cause dano em ambos os personagens e compare visualmente se
                            as barras da Unreal respondem no mesmo ritmo.</li>
                        <li>Documente screenshots com HUD original x HUD Unreal e anote diferenças que precisam de ajuste.</li>
                    </ol>
                </article>
            </div>
        </section>

        <section id="erros" class="panel">
            <h2>Diagnóstico, Erros Comuns e Perguntas Frequentes</h2>
            <p>
                Quando algo der errado, utilize este roteiro para isolar o problema rapidamente. Cada cenário aponta arquivos
                específicos do cliente ou servidor que explicam a causa e como resolvê-la.
            </p>
            <div class="faq-grid">
                <article class="faq-card">
                    <h3>Cliente Unreal não conecta ao JoinServer</h3>
                    <ul>
                        <li>Verifique se o ConnectServer está entregando a porta correta conforme <code>ConnectServer.ini</code>.</li>
                        <li>Confirme que o pacote de login contém versão/serial processados por <code>SendRequestLogInNew</code>.</li>
                        <li>Leia os logs de <code>JoinServerProtocolCore</code> e identifique se o resultado é 0 (erro de senha) ou 5 (conta bloqueada).</li>
                        <li>Teste com o cliente clássico para validar se o serviço está funcional.</li>
                    </ul>
                </article>
                <article class="faq-card">
                    <h3>Inventário não atualiza ou itens somem</h3>
                    <ul>
                        <li>Confirme se o componente da Unreal envia pacotes com mesma grid do <code>CNewUIInventoryCtrl</code>.</li>
                        <li>Ative logs no DataServer para <code>GDWarehouseItemSaveRecv</code> e veja se a mensagem chega.</li>
                        <li>Cheque a serialização do item (tipo, opção, durabilidade) antes de enviar ao servidor.</li>
                        <li>Restaurar backup do banco e repetir o teste garante consistência.</li>
                    </ul>
                </article>
                <article class="faq-card">
                    <h3>Movimento atrasado ou teleporte inesperado</h3>
                    <ul>
                        <li>Certifique-se de que <code>ClientSendMoveCharacter</code> está sendo replicado como RPC confiável.</li>
                        <li>Observe <code>gMove.CGTeleportRecv</code> para entender se o servidor está corrigindo posição.</li>
                        <li>Sincronize o tick rate da Unreal com o tempo esperado pelo servidor clássico.</li>
                        <li>Desative temporariamente efeitos pesados para descartar problemas de performance.</li>
                    </ul>
                </article>
                <article class="faq-card">
                    <h3>Crash ao iniciar qualquer serviço</h3>
                    <ul>
                        <li>Verifique dependências faltantes (bibliotecas, redistribuíveis) listadas nos projetos Visual Studio.</li>
                        <li>Use o <code>CrashReporter</code> ou <code>CMiniDump</code> para coletar logs e identificar DLLs ausentes.</li>
                        <li>Execute como administrador apenas se o serviço precisar abrir portas reservadas (&lt; 1024).</li>
                        <li>Mantenha antivírus/desligamento de firewall controlado durante os testes.</li>
                    </ul>
                </article>
                <article class="faq-card">
                    <h3>Blueprints bagunçados ou difíceis de manter</h3>
                    <ul>
                        <li>Separe lógica de interface (Widgets) de lógica de rede (Actor Components) conforme o cliente clássico faz com módulos distintos.</li>
                        <li>Nomeie todas as variáveis com prefixos (<code>BP_</code>, <code>C++</code>) e documente no diário.</li>
                        <li>Utilize <em>Comment Boxes</em> para agrupar blocos equivalentes a funções do código original.</li>
                        <li>Faça revisões semanais para refatorar Blueprints em C++ se necessário.</li>
                    </ul>
                </article>
                <article class="faq-card">
                    <h3>Diferenças entre gráfico original e Unreal</h3>
                    <ul>
                        <li>Releia o pipeline de efeitos em <code>Winmain.cpp</code> e arquivos <code>ZzzEffect</code> para priorizar o que migrar.</li>
                        <li>Use Niagara para partículas e <em>Material Instances</em> para texturas animadas.</li>
                        <li>Ative <em>Lumen</em> ou <em>Nanite</em> somente após validar desempenho em máquinas modestas.</li>
                        <li>Documente diferenças aceitas (ex.: novas sombras) e explique aos aprendizes o motivo.</li>
                    </ul>
                </article>
            </div>
        </section>

        <section id="glossario" class="panel">
            <h2>Glossário Rápido</h2>
            <dl class="glossario">
                <div>
                    <dt>Asset</dt>
                    <dd>Qualquer arquivo reutilizável (textura, som, modelo 3D) que pode ser importado no cliente ou no Unreal.
                    </dd>
                </div>
                <div>
                    <dt>Blueprint</dt>
                    <dd>Sistema visual da Unreal que permite criar lógica sem programar escrevendo código. Ideal para montar a
                        primeira versão da interface.</dd>
                </div>
                <div>
                    <dt>Build</dt>
                    <dd>Processo de compilar o código e gerar um executável. O Visual Studio cuida disso para o cliente e a
                        Unreal gera <em>packages</em> para o remake.</dd>
                </div>
                <div>
                    <dt>Hot Reload</dt>
                    <dd>Recurso da Unreal para recompilar código C++ enquanto o editor está aberto, acelerando testes rápidos.</dd>
                </div>
                <div>
                    <dt>Replica&ccedil;&atilde;o</dt>
                    <dd>Mecânica que sincroniza dados entre cliente e servidor na Unreal. Fundamental para inventário e
                        movimentação.</dd>
                </div>
            </dl>
        </section>

        <section id="pipeline-assets" class="panel">
            <h2>Pipeline de Assets &amp; Migração Técnica</h2>
            <p>
                Transforme arquivos do <em>Main 5.2</em> e serviços do <em>MuServer</em> em assets prontos para a
                <strong>Unreal Engine 5</strong> sem precisar interpretar código. Siga cada checklist para importar,
                converter e validar o conteúdo reutilizando exatamente os mesmos recursos visuais e sonoros do jogo
                original.
            </p>
            <div class="callouts">
                <p class="callout callout--tip"><strong>Antes de começar:</strong> deixe o explorador de arquivos aberto
                    nas pastas <code>Source Main 5.2/Global Release/Data</code> e <code>Source Main 5.2/source</code>. Você
                    alternará entre elas e a janela da Unreal a cada etapa.</p>
                <p class="callout callout--warning"><strong>Formato importa:</strong> sempre converta texturas para
                    <code>.PNG</code> com canal alfa e sons para <code>.WAV</code> 16 bits. Isso evita falhas na importação
                    automática do Unreal.</p>
            </div>

            <div class="asset-tool" aria-live="polite">
                <div class="asset-tool__header">
                    <h3>Assistente automático de assets</h3>
                    <p>
                        Carregue a pasta <code>Data</code> do cliente original e deixe o navegador indicar o que precisa ser
                        convertido para formatos aceitos pela <strong>Unreal Engine 5</strong>. Nada é enviado para a internet:
                        a análise acontece localmente usando o mesmo mapeamento visto em
                        <code>NewUIMainFrameWindow.cpp</code>, <code>ZzzBMD.cpp</code> e <code>ZzzOpenData.cpp</code>.
                    </p>
                </div>
                <div class="asset-tool__picker">
                    <label for="asset-root-input" class="asset-tool__label">
                        <span>Escolha a pasta <code>Data</code> ou o diretório raiz com os assets</span>
                        <input type="file" id="asset-root-input" name="asset-root-input" webkitdirectory directory multiple>
                    </label>
                    <ul class="asset-tool__tips">
                        <li>Use navegadores baseados em Chromium (Chrome, Edge) para habilitar a seleção de pastas.</li>
                        <li>Mantenha o diretório original do cliente sem renomear subpastas; isso melhora o reconhecimento.</li>
                        <li>Após a varredura, siga as receitas exibidas para converter e importar cada categoria.</li>
                    </ul>
                </div>
                <div class="asset-tool__status" id="asset-tool-status">
                    Nenhum diretório analisado ainda. Assim que você apontar a pasta <code>Data</code>, os resultados aparecem
                    aqui.
                </div>
                <div class="asset-tool__summary" id="asset-tool-summary" hidden>
                    <div class="asset-tool__totals row row-cols-1 row-cols-md-3 g-3">
                        <div class="col">
                            <div class="asset-tool__totals-card card h-100 border-0 shadow-sm">
                                <div class="card-body">
                                    <span class="asset-tool__totals-label">Arquivos analisados</span>
                                    <span class="asset-tool__totals-value" id="asset-total-files">0</span>
                                </div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="asset-tool__totals-card card h-100 border-0 shadow-sm">
                                <div class="card-body">
                                    <span class="asset-tool__totals-label">Conversões sugeridas</span>
                                    <span class="asset-tool__totals-value" id="asset-convertible-files">0</span>
                                </div>
                            </div>
                        </div>
                        <div class="col">
                            <div class="asset-tool__totals-card card h-100 border-0 shadow-sm">
                                <div class="card-body">
                                    <span class="asset-tool__totals-label">Arquivos já compatíveis</span>
                                    <span class="asset-tool__totals-value" id="asset-compatible-files">0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="asset-tool__categories" id="asset-results">
                        <!-- conteúdo gerado via JavaScript -->
                    </div>
                    <div class="asset-tool__visualization" id="asset-visualization" hidden>
                        <div class="d-flex flex-column flex-lg-row align-items-lg-center justify-content-between gap-3">
                            <h4 class="mb-0">Visualização rápida da pasta <code>Data</code></h4>
                            <p class="asset-visualization__summary alert alert-info mb-0" id="asset-visualization-status">
                                Selecione a pasta <code>Data</code> para localizar rapidamente arquivos de HUD, Inventário e
                                Personagens.
                            </p>
                        </div>
                        <div class="asset-visualization__list row row-cols-1 row-cols-lg-3 g-4" id="asset-visualization-list"></div>
                    </div>
                </div>
            </div>

            <div class="asset-tool__guide" id="bmd-fbx">
                <h4>Conversor autom&aacute;tico <code>BMD_FBX</code></h4>
                <p>
                    Utilize o conversor C++ <code>BMD_FBX</code> para transformar arquivos <code>.BMD</code> em
                    <code>.FBX</code> prontos para a Unreal. O utilit&aacute;rio reorganiza a hierarquia de ossos,
                    gera materiais e localiza texturas legadas automaticamente.
                </p>
                <ul class="asset-tool__guide-list">
                    <li>
                        <strong>Raiz unificada:</strong> cria um osso <code>root</code> e clusters para cada
                        <code>Bone_t</code>, corrigindo modelos com v&aacute;rias ra&iacute;zes antes de salvar em
                        <code>SaveFbx</code>.
                    </li>
                    <li>
                        <strong>Materiais nomeados:</strong> renomeia texturas para <code>Mesh_T_###</code>, conecta
                        <code>FbxFileTexture</code> aos materiais Phong e usa <code>FindTextureRecursive</code> para
                        extrair <code>.OZJ/.OZT/.OZB</code> diretamente para a pasta de destino.
                    </li>
                    <li>
                        <strong>Anima&ccedil;&otilde;es consistentes:</strong> converte quadros com
                        <code>BMD_FBX::FRAME_TIME</code>, inclui poses de bind via <code>StoreBindPose</code> e exporta
                        normais opcionais quando <code>export_normals</code> est&aacute; habilitado.
                    </li>
                </ul>
                <pre class="asset-tool__guide-code"><code>BMD_FBX converter;
BMD_FBX::SetRootPath(R"(C:\EnsinoRemake\Data)");
BMD_FBX::SetFrameTime(1.0 / 30.0);
converter.Unpack(
    R"(C:\EnsinoRemake\MainOriginal\Data\Character\Knight01.bmd)",
    nullptr,
    true,   // localizar texturas
    true,   // renomear texturas
    true    // exportar normais
);
</code></pre>
                <p class="asset-tool__guide-note">
                    Se alguma textura n&atilde;o for encontrada localmente, defina <code>BMD_FBX::SetRootPath</code>
                    apontando para uma pasta global de <code>Data</code>. O conversor registra cada arquivo faltante no
                    console, facilitando o ajuste antes da importa&ccedil;&atilde;o no Unreal.
                </p>
            </div>

            <div class="asset-tool__configurator card border-0 shadow-sm" id="bmd-configurator" hidden>
                <div class="card-body d-flex flex-column gap-4">
                    <div class="d-flex flex-column flex-lg-row align-items-lg-center justify-content-between gap-3">
                        <div>
                            <h5 class="card-title mb-1">Gerador de snippet <code>BMD_FBX</code></h5>
                            <p class="card-text text-muted mb-0">
                                Personalize as op&ccedil;&otilde;es do conversor C++ e copie um bloco pronto para
                                compilar junto ao utilit&aacute;rio. As configura&ccedil;&otilde;es abaixo usam os
                                mesmos par&acirc;metros de <code>Unpack</code> presentes no c&oacute;digo legado.
                            </p>
                        </div>
                        <span
                            class="asset-tool__configurator-count badge rounded-pill text-uppercase small fw-semibold"
                            id="bmd-configurator-count"
                        ></span>
                    </div>

                    <form class="asset-tool__configurator-form row g-3" autocomplete="off">
                        <div class="col-12 col-lg-6">
                            <label for="bmd-root-path" class="form-label text-uppercase small fw-semibold"
                                >Pasta raiz para texturas (<code>SetRootPath</code>)</label
                            >
                            <input
                                type="text"
                                class="form-control"
                                id="bmd-root-path"
                                name="bmd-root-path"
                                value="C:\\EnsinoRemake\\Data"
                                placeholder="C:\\EnsinoRemake\\Data"
                            />
                            <div class="form-text">
                                Defina onde <code>FindTextureRecursive</code> procurar&aacute; texturas adicionais caso o
                                diret&oacute;rio local n&atilde;o contenha todos os arquivos.
                            </div>
                        </div>
                        <div class="col-12 col-lg-6">
                            <label for="bmd-output-dir" class="form-label text-uppercase small fw-semibold"
                                >Destino opcional para FBX</label
                            >
                            <input
                                type="text"
                                class="form-control"
                                id="bmd-output-dir"
                                name="bmd-output-dir"
                                placeholder="C:\\EnsinoRemake\\SaidaFBX"
                            />
                            <div class="form-text">
                                Se vazio, <code>Unpack</code> salva ao lado do <code>.BMD</code> original usando o
                                sufixo <code>_fbx</code> do utilit&aacute;rio.
                            </div>
                        </div>
                        <div class="col-6 col-lg-3">
                            <label for="bmd-frame-time" class="form-label text-uppercase small fw-semibold"
                                >Frame time (<code>SetFrameTime</code>)</label
                            >
                            <input
                                type="number"
                                class="form-control"
                                id="bmd-frame-time"
                                name="bmd-frame-time"
                                value="0.033333"
                                step="0.001"
                                min="0.001"
                            />
                            <div class="form-text">Equivale a 1 / FPS. O padr&atilde;o de 0,033 gera 30 quadros/s.</div>
                        </div>
                        <div class="col-12 col-lg-9">
                            <div class="asset-tool__configurator-switches d-flex flex-column flex-lg-row gap-2">
                                <div class="form-check form-switch">
                                    <input
                                        class="form-check-input"
                                        type="checkbox"
                                        role="switch"
                                        id="bmd-find-textures"
                                        name="bmd-find-textures"
                                        checked
                                    />
                                    <label class="form-check-label" for="bmd-find-textures"
                                        >Localizar texturas adicionais (<code>find_textures</code>)</label
                                    >
                                </div>
                                <div class="form-check form-switch">
                                    <input
                                        class="form-check-input"
                                        type="checkbox"
                                        role="switch"
                                        id="bmd-rename-textures"
                                        name="bmd-rename-textures"
                                        checked
                                    />
                                    <label class="form-check-label" for="bmd-rename-textures"
                                        >Renomear texturas (<code>rename_textures</code>)</label
                                    >
                                </div>
                                <div class="form-check form-switch">
                                    <input
                                        class="form-check-input"
                                        type="checkbox"
                                        role="switch"
                                        id="bmd-export-normals"
                                        name="bmd-export-normals"
                                        checked
                                    />
                                    <label class="form-check-label" for="bmd-export-normals"
                                        >Exportar normais (<code>export_normals</code>)</label
                                    >
                                </div>
                            </div>
                        </div>
                    </form>

                    <div class="asset-tool__configurator-files">
                        <h6 class="text-uppercase small fw-semibold mb-2">Arquivos detectados</h6>
                        <ul
                            class="asset-tool__configurator-files-list list-group list-group-flush"
                            id="bmd-configurator-files"
                        ></ul>
                    </div>

                    <div class="asset-tool__configurator-code">
                        <div class="d-flex align-items-center justify-content-between gap-3">
                            <h6 class="text-uppercase small fw-semibold mb-0">C&oacute;digo pronto para uso</h6>
                            <button
                                type="button"
                                class="btn btn-outline-light btn-sm asset-tool__configurator-copy"
                                id="bmd-copy-button"
                                disabled
                            >
                                Copiar
                            </button>
                        </div>
                        <pre class="asset-tool__configurator-pre"><code id="bmd-configurator-code"></code></pre>
                    </div>

                    <p class="asset-tool__configurator-options text-muted small mb-0" id="bmd-configurator-options"></p>
                </div>
            </div>

            <div class="table-wrapper table-wrapper--compact">
                <table class="data-table data-table--mapping">
                    <caption>Mapa rápido de conversão 1:1</caption>
                    <thead>
                        <tr>
                            <th>Origem Main/MuServer</th>
                            <th>Onde encontrar</th>
                            <th>Conversão para Unreal</th>
                            <th>Resultado esperado</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>HUD e elementos UI</td>
                            <td><code>Global Release/Data/Interface</code> (arquivos <code>.OZJ</code>/<code>.OZT</code>)</td>
                            <td>Extrair com <em>MuOZ Extractor</em> &rarr; salvar como <code>.PNG</code> &rarr; importar para
                                <code>Content/UI/HUD</code> com <em>sRGB</em> ativo.</td>
                            <td><code>WB_HUDMain</code> exibindo barras, botões e mini mapa com mesma textura.</td>
                        </tr>
                        <tr>
                            <td>Personagens e monstros</td>
                            <td><code>Global Release/Data/Character</code> e <code>source/ZzzBMD.cpp</code></td>
                            <td>Converter <code>.BMD</code> usando <em>MuModel Viewer</em> &rarr; exportar <code>.FBX</code>
                                com skeleton &rarr; importar para <code>Content/Characters</code> com rig <em>Humanoid</em>.</td>
                            <td>Mallas com animações retargetadas no <code>ABP_Player</code> e <code>ABP_Monster</code>.</td>
                        </tr>
                        <tr>
                            <td>Itens e ícones</td>
                            <td><code>Global Release/Data/Item</code> e <code>source/ZzzInventory.h</code></td>
                            <td>Exportar ícones para <code>.PNG</code> 64x64 &rarr; criar <code>DataTable</code> baseado em
                                <code>FItemSlot</code> &rarr; ligar ao <code>WB_Inventory</code>.</td>
                            <td>Grid replicado com mesmos ícones e descrições do inventário clássico.</td>
                        </tr>
                        <tr>
                            <td>Efeitos e skills</td>
                            <td><code>Global Release/Data/Effect</code>, <code>source/ZzzEffect.cpp</code></td>
                            <td>Converter texturas para <code>.TGA</code> &rarr; criar sistemas Niagara usando curvas de
                                <code>SkillEffectMgr.cpp</code> &rarr; anexar a <code>AbilitySystemComponent</code>.</td>
                            <td>Partículas com tempo e cor idênticos às habilidades originais.</td>
                        </tr>
                        <tr>
                            <td>Música e sons</td>
                            <td><code>Global Release/Data/Music</code> e <code>source/DSPlaySound.h</code></td>
                            <td>Converter <code>.WAV</code> 22 kHz &rarr; criar <code>SoundCue</code> com volume igual ao
                                definido em <code>DSPlaySound.cpp</code> &rarr; mapear em <code>AudioSubsystem</code>.</td>
                            <td>Trilhas e efeitos sincronizados com ações (login, ataque, drop de item).</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="grid">
                <article class="card">
                    <h3>Interface &amp; HUD</h3>
                    <ol class="step-list">
                        <li>Abrir <code>NewUIMainFrameWindow.cpp</code> e listar widgets (HP, MP, Buff, Radar). Anotar nomes no
                            diário.</li>
                        <li>Extrair texturas correspondentes em <code>Data/Interface</code> e importar para
                            <code>Content/UI/HUD</code>. Marcar “Create Material” desativado.</li>
                        <li>No Unreal, criar <code>WB_HUDMain</code> duplicando layout da captura do cliente clássico.</li>
                        <li>Adicionar <code>ProgressBar</code> para HP/MP/AG com preenchimento manual. Conectar a variáveis do
                            <code>PlayerState</code> via <code>Bind Widget</code>.</li>
                        <li>Criar <code>WidgetSwitcher</code> para notificações (party, trade, eventos) e replicar textos de
                            <code>NewUINotice.cpp</code>.</li>
                    </ol>
                </article>
                <article class="card">
                    <h3>Personagens &amp; animações</h3>
                    <ol class="step-list">
                        <li>Extrair modelo do personagem base usando <em>MuModel Viewer</em> e exportar como
                            <code>Character_Base.fbx</code>.</li>
                        <li>No importador da Unreal, habilitar <em>Use T0 As Ref Pose</em> e gerar <code>Physics Asset</code>
                            para colisões.</li>
                        <li>Configurar <code>ABP_Player</code> com estados Idle/Walk/Run/Attack usando tempos de
                            <code>ZzzCharacter.cpp</code> (velocidade 6.5f, aceleração 2048).</li>
                        <li>Retargetar animações de monstros repetindo o processo com <code>ABP_Monster</code> e eventos de
                            ataque baseados em <code>MonsterSkillManager.cpp</code>.</li>
                        <li>Salvar <code>DataTable</code> <code>DT_Characters</code> contendo nome da mesh, animação padrão e
                            sons associados.</li>
                    </ol>
                </article>
                <article class="card">
                    <h3>Áudio, FX &amp; automação</h3>
                    <ol class="step-list">
                        <li>Converter faixas de <code>Data/Music</code> para <code>.WAV</code> estéreo. Importar para
                            <code>Content/Audio/Music</code> e criar <code>SoundCue</code> com atenuação 3D.</li>
                        <li>Mapear sons em <code>DSPlaySound.cpp</code> e criar <code>DataTable</code>
                            <code>DT_SoundLibrary</code> com colunas <em>Evento</em>, <em>SoundCue</em>, <em>Volume</em>.</li>
                        <li>Converter texturas de efeito para <code>.TGA</code>, criar materiais <code>M_Skill_*</code> e
                            sistemas Niagara seguindo parâmetros de <code>SkillEffectMgr.cpp</code>.</li>
                        <li>No Unreal, criar <code>FXSubsystem</code> com funções Blueprint para <code>SpawnEffect</code> e
                            <code>PlaySoundByEvent</code>.</li>
                        <li>Registrar automação no <code>Editor Utility Widget</code> para importar novos assets em lote com
                            prefixos padronizados.</li>
                    </ol>
                </article>
            </div>
        </section>

        <section id="playbook-personagem" class="panel">
            <h2>Playbook Unreal 1:1 — Mecânicas Essenciais</h2>
            <p>
                Use este playbook para reconstruir comportamento, interações e sistemas principais respeitando o fluxo do
                <em>Main 5.2</em> e do <em>MuServer</em>. Cada card aponta os arquivos originais, o Blueprint ou classe C++
                equivalente e a ordem de implementação para não travar em dependências.
            </p>
            <div class="callouts">
                <p class="callout callout--tip"><strong>Modo fácil:</strong> execute uma etapa por vez. Após concluir o
                    checklist, teste dentro do nível <code>Test_Level</code> com dois jogadores simulados (uma instância
                    <em>Listen Server</em> e uma instância <em>Client</em>).</p>
                <p class="callout callout--warning"><strong>Sincronização:</strong> sempre compare os logs do
                    <code>GameServer</code> (<code>GameServer/GameServer/JSProtocol.cpp</code>) com a aba <em>Output Log</em>
                    da Unreal. Diferenças indicam pacote montado incorretamente.</p>
            </div>
            <div class="grid">
                <article class="card">
                    <h3>Movimentação &amp; física</h3>
                    <ol class="step-list">
                        <li>Estudar <code>ZzzCharacter.cpp</code> e <code>CameraMove.cpp</code> para anotar velocidade,
                            aceleração e limites de rotação.</li>
                        <li>No Unreal, configurar <code>InputAction_Move</code>, <code>InputAction_Look</code> e sensibilidade
                            idêntica no <code>Enhanced Input</code>.</li>
                        <li>Atualizar <code>BP_PlayerCharacter</code> para usar <code>CharacterMovement</code> com valores de
                            <code>Max Walk Speed</code> = 600 e <code>Rotation Rate</code> = 540, espelhando o cliente.
                        </li>
                        <li>Criar <code>CameraBoom</code> com ajuste de zoom baseado no valor padrão em
                            <code>Options.ini</code> do Main (campo <code>CameraDistance</code>).</li>
                        <li>Testar com <em>Play in Editor</em> em modo <em>New Editor Window</em> e validar que o pacote
                            <code>0x10</code> (movimento) chega ao <code>GameServer</code> sem divergência.</li>
                    </ol>
                </article>
                <article class="card">
                    <h3>Combate &amp; skills</h3>
                    <ol class="step-list">
                        <li>Anotar no diário as skills básicas lendo <code>SkillInfo.h</code> e os efeitos em
                            <code>SkillEffectMgr.cpp</code>.</li>
                        <li>Criar <code>AbilitySystemComponent</code> no <code>BP_PlayerState</code> e registrar habilidades
                            como <code>GA_NormalAttack</code>, <code>GA_Skill01</code>.</li>
                        <li>Configurar animações no <code>ABP_Player</code> usando notificadores (<em>AnimNotifies</em>) para
                            sincronizar sons e efeitos.</li>
                        <li>Montar <code>BP_CombatComponent</code> que monta pacotes de ataque baseados em
                            <code>ProtocolSend.cpp::CGSendAttack</code>.</li>
                        <li>Validar dano recebido usando eventos <code>JSProtocol.cpp::CGDamageRecv</code> e atualizar
                            <code>WB_HUDMain</code> com feedback visual.</li>
                    </ol>
                </article>
                <article class="card">
                    <h3>Economia &amp; inventário</h3>
                    <ol class="step-list">
                        <li>Ler <code>NewUIInventoryCtrl.cpp</code> e <code>ItemType.h</code> para entender slots, pilhas e
                            limites.</li>
                        <li>Popular <code>DT_ItemDefinitions</code> usando colunas <em>ID</em>, <em>Nome</em>, <em>Mesh</em>,
                            <em>Icone</em>, <em>Stack</em>.</li>
                        <li>Implementar <code>BP_InventoryComponent</code> com replicação <code>COND_OwnerOnly</code>.</li>
                        <li>Ligar <code>WB_Inventory</code> ao componente via <code>Event OnRep_Items</code> e arrastar itens
                            com <code>DragDropOperation</code>.</li>
                        <li>Sincronizar com o servidor usando o pacote <code>0x79</code> seguindo estrutura de
                            <code>DataServerProtocol.cpp::WarehouseItemsSend</code>.</li>
                    </ol>
                </article>
                <article class="card">
                    <h3>Sistemas sociais &amp; chat</h3>
                    <ol class="step-list">
                        <li>Revisar <code>ChatWnd.cpp</code> e <code>ProtocolSend.cpp::SendChatMessage</code> para saber os
                            canais (global, party, guild).</li>
                        <li>No Unreal, criar <code>WB_Chat</code> com abas e cores iguais às constantes em
                            <code>ChatMacroDef.h</code>.</li>
                        <li>Implementar <code>BP_ChatComponent</code> com filas replicadas e filtros anti-spam baseados em
                            <code>Filter.cpp</code>.</li>
                        <li>Enviar mensagens usando <code>NetworkBridge</code> e atualizar o servidor via
                            <code>Protocol.cpp::CGChatRecv</code>.</li>
                        <li>Adicionar histórico persistente salvando em <code>Saved/Logs/chat.log</code> para facilitar
                            suporte.</li>
                    </ol>
                </article>
                <article class="card">
                    <h3>Mundo, eventos &amp; instâncias</h3>
                    <ol class="step-list">
                        <li>Listar mapas em <code>WorldList.xml</code> e arquivos <code>Terrain</code> do cliente clássico.
                        </li>
                        <li>Importar alturas para o Unreal usando <code>Landscape</code> e texturas de splat extraídas com
                            <em>MuTerrain Tool</em>.</li>
                        <li>Criar <code>LevelInstance</code> para eventos (Blood Castle, Devil Square) e conectar ao
                            <code>EventManager</code> inspirado em <code>GameServer/Event/*.cpp</code>.</li>
                        <li>Configurar <code>BP_Portal</code> com colisão e pacote <code>0x1C</code> para sincronizar
                            transições com o servidor.</li>
                        <li>Testar spawn de monstros usando dados de <code>MonsterSetBase.txt</code> convertidos para
                            <code>DataTable</code> <code>DT_SpawnGroups</code>.</li>
                    </ol>
                </article>
                <article class="card">
                    <h3>Duelo, rankings e HUD competitiva</h3>
                    <ol class="step-list">
                        <li>Estudar <code>NewUIDuelWindow.cpp</code> e <code>CDuelMgr.cpp</code> para mapear estados e timers do duelo.</li>
                        <li>Implementar <code>UDuelComponent</code> na Unreal com estados replicados e pacotes 0xAA convertidos.</li>
                        <li>Construir <code>WB_DuelHUD</code> com barras de HP, cronômetro circular e lista de espectadores usando texturas originais.</li>
                        <li>Sincronizar confirmações com o GameServer (<code>DuelSystem.cpp</code>) e registrar logs comparativos.</li>
                        <li>Adicionar scoreboard pós-partida exibindo vitórias acumuladas e recompensas.</li>
                    </ol>
                </article>
                <article class="card">
                    <h3>Economia avançada &amp; refinaria</h3>
                    <ol class="step-list">
                        <li>Ler <code>NewUIExchangeLuckyCoin.cpp</code>, <code>NewUILuckyItemWnd.cpp</code> e <code>UIJewelHarmony.cpp</code> para entender fluxos completos.</li>
                        <li>Converter arquivos <code>LuckyItemOption.txt</code> e <code>JewelOfHarmonyOption.bmd</code> em <em>Data Tables</em> para uso na Unreal.</li>
                        <li>Criar componentes <code>ULuckyEconomyComponent</code> e <code>UHarmonyForgeComponent</code> com integração ao DataServer.</li>
                        <li>Desenvolver Widgets <code>WB_LuckyExchange</code> e <code>WB_HarmonyForge</code> com animações de brilho e feedback visual.</li>
                        <li>Executar testes end-to-end verificando saldo, resultados e mensagens de erro alinhadas ao cliente clássico.</li>
                    </ol>
                </article>
            </div>
        </section>

        <section id="qa-publicacao" class="panel">
            <h2>QA, Testes Multijogador &amp; Operações Contínuas</h2>
            <p>
                Garanta que o remake funcione do login à publicação. Esta seção organiza testes passo a passo, validação de
                rede, preparação de builds e rotinas de suporte para que qualquer pessoa consiga manter o projeto ativo sem
                consultar outras fontes.
            </p>
            <div class="callouts">
                <p class="callout callout--tip"><strong>Registro automático:</strong> use a planilha “QA Ensino Remake” do
                    diário para marcar cada execução. Sem marcação, a etapa deve ser refeita.</p>
                <p class="callout callout--warning"><strong>Dois computadores?</strong> Caso não tenha, abra duas instâncias
                    do editor (Play as Listen Server + Play as Client) para simular partidas.</p>
            </div>
            <div class="grid">
                <article class="card">
                    <h3>Checklists diários</h3>
                    <ol class="step-list">
                        <li>Iniciar ConnectServer, JoinServer, GameServer e DataServer com scripts fornecidos.</li>
                        <li>Abrir o cliente Unreal, logar com conta de teste e percorrer login &rarr; seleção &rarr; mapa.</li>
                        <li>Validar HUD completo (HP, MP, buffs) e inventário carregado do banco.</li>
                        <li>Executar combate contra um monstro e garantir drops corretos.</li>
                        <li>Registrar resultado e anexar screenshot no diário.</li>
                    </ol>
                </article>
                <article class="card">
                    <h3>Testes multijogador</h3>
                    <ol class="step-list">
                        <li>Executar <code>RunUAT -Test</code> com cenário “Dois jogadores + servidor local”.</li>
                        <li>Verificar latência exibida no HUD (<code>TelemetrySubsystem</code>) e comparar com ping real.</li>
                        <li>Conferir sincronização de inventário, chat e movimentação usando logs do <code>GameServer</code>.
                        </li>
                        <li>Testar negociações (trade) e partilha de party replicando pacotes <code>0xCB</code> e
                            <code>0xF3</code>.</li>
                        <li>Registrar bugs em planilha com status (Novo, Investigando, Resolvido).</li>
                    </ol>
                </article>
                <article class="card">
                    <h3>Publicação &amp; atualização</h3>
                    <ol class="step-list">
                        <li>Gerar build <em>Shipping</em> via <code>File &gt; Package Project &gt; Windows</code> e salvar em
                            <code>Builds/Cliente</code>.</li>
                        <li>Copiar arquivos de configuração <code>DefaultEngine.ini</code>, <code>DefaultGame.ini</code> e
                            credenciais de rede para pasta <code>Config</code>.</li>
                        <li>Rodar script <code>PackageMuServer.bat</code> para agrupar serviços com configurações atualizadas.</li>
                        <li>Testar instalador em máquina limpa (VM) e documentar passos com screenshots.</li>
                        <li>Atualizar seção “Release Notes” no diário com mudanças e links para download.</li>
                    </ol>
                </article>
                <article class="card">
                    <h3>Suporte &amp; monitoramento</h3>
                    <ol class="step-list">
                        <li>Ativar logs detalhados no servidor (<code>GameServer/GameServer/LogProc.cpp</code>) e salvar em
                            <code>Logs/&lt;data&gt;</code>.</li>
                        <li>Criar <code>Dashboard.xlsx</code> com métricas: jogadores online, ping médio, erros críticos.</li>
                        <li>Configurar alertas de e-mail usando <code>PowerShell</code> para quedas de serviço.</li>
                        <li>Manter FAQ atualizada com soluções rápidas (reinstalação, reset de senha, portas bloqueadas).</li>
                        <li>Planejar sessões semanais de revisão para revisar feedback e priorizar correções.</li>
                    </ol>
                </article>
            </div>
        </section>

        <section id="recursos" class="panel">
            <h2>Recursos &amp; Referências</h2>
            <ul class="resource-list">
                <li><strong>Documentação original:</strong> consulte <code>README.md</code> para uma visão geral do pacote.</li>
                <li><strong>Assets do cliente:</strong> disponíveis em <code>Source Main 5.2/Global Release</code> e
                    <code>Source Main 5.2/source</code>.</li>
                <li><strong>Componentes do servidor:</strong> explore <code>Source MuServer Update 15/</code> para entender cada
                    serviço.</li>
                <li><strong>Guias complementares:</strong> verifique
                    <code>unreal_recreation_plan.html</code>, <code>unreal_item_system_guide.html</code> e
                    <code>inventory_unreal_inventory_system.html</code> para aprofundar sistemas específicos.</li>
                <li><strong>Aprendizado Unreal Engine 5:</strong> playlist oficial “Unreal Engine 5 Fundamentals” e a
                    documentação sobre <em>Enhanced Input</em> e <em>Common UI</em>.</li>
                <li><strong>Comunidade:</strong> participe de fóruns como o Unreal Slackers (Discord) para tirar dúvidas
                    rápidas.</li>
            </ul>
        </section>
    </main>

    <footer>
        <p>Projeto educativo criado para orientar o remake completo usando os assets originais.</p>
    </footer>

    <template id="timeline-item">
        <article class="timeline__item">
            <header>
                <h3 class="timeline__title"></h3>
                <p class="timeline__duration"></p>
            </header>
            <p class="timeline__description"></p>
            <button class="timeline__toggle" type="button">Ver pré-requisitos</button>
            <ul class="timeline__prereqs" hidden></ul>
        </article>
    </template>

    <script src="script.js"></script>
</body>
</html>
