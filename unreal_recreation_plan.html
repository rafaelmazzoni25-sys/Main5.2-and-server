<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Plano Direcionado para Recriação do Projeto na Unreal Engine 5</title>
  <style>
    :root {
      color-scheme: light;
      --azul-escuro: #123a63;
      --azul: #0c8dd9;
      --azul-claro: #ecf4ff;
      --cinza: #455a74;
      --verde: #35a07e;
      --amarelo: #f6b73c;
      --vermelho: #d9534f;
      --fundo: #f3f6fb;
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.65;
      margin: 0;
      background: var(--fundo);
      color: #1f2a3a;
    }
    header {
      background: linear-gradient(135deg, var(--azul-escuro), var(--azul));
      color: #fff;
      padding: 3rem 1.5rem 2.5rem;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    header::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at top right, rgba(255, 255, 255, 0.28), transparent 55%);
    }
    header h1 {
      margin: 0 auto 0.75rem;
      max-width: 720px;
      font-size: clamp(2.25rem, 2.7vw + 1.1rem, 3.25rem);
    }
    header p {
      margin: 0 auto;
      max-width: 720px;
      font-size: 1.05rem;
      opacity: 0.95;
    }
    main {
      max-width: 1160px;
      margin: -2.75rem auto 4rem;
      padding: 0 1.5rem 4rem;
    }
    section {
      background: #fff;
      margin: 2rem 0;
      padding: 2.5rem 2.25rem;
      border-radius: 20px;
      box-shadow: 0 26px 60px rgba(18, 58, 99, 0.12);
      position: relative;
      overflow: hidden;
    }
    section::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(145deg, rgba(12, 141, 217, 0.05), transparent 60%);
      pointer-events: none;
    }
    h2 {
      margin: 0 0 1.75rem;
      padding-left: 0.85rem;
      border-left: 5px solid var(--azul);
      color: var(--azul-escuro);
      font-size: 1.75rem;
    }
    h3 {
      margin-top: 1.75rem;
      color: var(--cinza);
      font-size: 1.25rem;
    }
    p {
      margin: 0 0 1rem;
    }
    ol, ul {
      margin: 0 0 1.35rem 1.25rem;
    }
    li {
      margin-bottom: 0.45rem;
    }
    strong.badge {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      font-size: 0.85rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      background: rgba(12, 141, 217, 0.14);
      color: var(--azul-escuro);
      border-radius: 999px;
      padding: 0.35rem 0.9rem;
    }
    .grid-3 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.25rem;
      margin-top: 1.5rem;
    }
    .atlas-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin: 1.75rem 0 1.5rem;
    }
    .atlas-tab {
      background: rgba(12, 141, 217, 0.14);
      border: 1px solid rgba(12, 141, 217, 0.35);
      color: var(--azul-escuro);
      border-radius: 999px;
      padding: 0.55rem 1.25rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .atlas-tab.active {
      background: linear-gradient(135deg, var(--azul), #0b6ac1);
      color: #fff;
      box-shadow: 0 12px 24px rgba(12, 141, 217, 0.25);
    }
    .atlas-tab:hover {
      transform: translateY(-2px);
    }
    .atlas-content {
      display: none;
      border-radius: 16px;
      border: 1px solid #d7e5f7;
      background: #fafdff;
      padding: 1.75rem 1.5rem;
      gap: 1.35rem;
    }
    .atlas-content.active {
      display: grid;
    }
    .atlas-content h3 {
      margin-top: 0;
      color: var(--azul-escuro);
    }
    .atlas-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1.15rem;
      font-size: 0.95rem;
    }
    pre {
      background: #0f1e2f;
      color: #d7f5ff;
      padding: 1rem 1.25rem;
      border-radius: 14px;
      overflow-x: auto;
      font-size: 0.92rem;
      line-height: 1.5;
      box-shadow: inset 0 0 0 1px rgba(12, 141, 217, 0.15);
    }
    pre code {
      white-space: pre;
    }
    .conversion-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin: 2rem 0 1.25rem;
    }
    .conversion-button {
      border: 1px solid rgba(12, 141, 217, 0.3);
      background: rgba(12, 141, 217, 0.08);
      color: var(--azul-escuro);
      border-radius: 999px;
      padding: 0.55rem 1.35rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .conversion-button.active {
      background: linear-gradient(135deg, var(--azul), #0b6ac1);
      color: #fff;
      box-shadow: 0 14px 32px rgba(12, 141, 217, 0.28);
      transform: translateY(-1px);
    }
    .conversion-pane {
      display: none;
      border: 1px solid #d6e4f6;
      border-radius: 18px;
      background: #fbfeff;
      padding: 2rem 1.75rem;
      margin-bottom: 1.75rem;
      box-shadow: 0 20px 45px rgba(18, 58, 99, 0.09);
    }
    .conversion-pane.active {
      display: block;
    }
    .conversion-pane h3 {
      margin-top: 0;
      color: var(--azul-escuro);
    }
    .source-card {
      background: rgba(236, 244, 255, 0.65);
      border: 1px solid rgba(12, 141, 217, 0.18);
      border-radius: 16px;
      padding: 1.25rem 1.35rem 1.5rem;
      margin: 1.25rem 0 1.75rem;
      box-shadow: 0 14px 38px rgba(12, 141, 217, 0.12);
    }
    .source-card .source-meta {
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      color: var(--cinza);
      margin-bottom: 0.75rem;
    }
    .layout-map {
      width: 100%;
      max-width: 720px;
      margin: 1.75rem auto;
      display: block;
      border-radius: 12px;
      box-shadow: 0 10px 28px rgba(12, 141, 217, 0.15);
    }
    .layout-map text {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      font-size: 14px;
      fill: #0b2d4a;
      font-weight: 600;
    }
    .layout-map rect {
      fill: rgba(12, 141, 217, 0.18);
      stroke: rgba(12, 141, 217, 0.65);
      stroke-width: 1.5;
    }
    .layout-map rect.asset {
      fill: rgba(53, 160, 126, 0.22);
      stroke: rgba(53, 160, 126, 0.7);
    }
    .conversion-pane ol {
      margin-left: 1.35rem;
    }
    .conversion-pane li {
      margin-bottom: 0.65rem;
    }
    .atlas-table thead {
      background: rgba(12, 141, 217, 0.12);
    }
    .atlas-table th,
    .atlas-table td {
      padding: 0.75rem 0.85rem;
      text-align: left;
      border-bottom: 1px solid #dfe9f7;
      vertical-align: top;
    }
    .atlas-table th {
      color: var(--azul-escuro);
      font-weight: 700;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .atlas-table code {
      background: rgba(12, 141, 217, 0.08);
      color: var(--azul-escuro);
      padding: 0.15rem 0.35rem;
      border-radius: 6px;
      font-size: 0.85rem;
    }
    .atlas-grid {
      display: grid;
      gap: 1.1rem;
    }
    .atlas-highlight {
      border-left: 5px solid var(--azul);
      background: rgba(12, 141, 217, 0.08);
      padding: 1rem 1.15rem;
      border-radius: 12px;
    }
    .atlas-list {
      display: grid;
      gap: 0.55rem;
      margin: 0;
      padding-left: 1.15rem;
    }
    .card {
      border-radius: 16px;
      border: 1px solid #d7e5f7;
      background: #fafdff;
      padding: 1.4rem 1.3rem 1.15rem;
      position: relative;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 18px 40px rgba(12, 141, 217, 0.18);
    }
    .card h3 {
      margin-top: 0;
      font-size: 1.2rem;
    }
    .checklist {
      display: grid;
      gap: 0.85rem;
      margin-top: 1.5rem;
    }
    .checklist label {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.75rem;
      align-items: start;
      padding: 1rem 1rem 1rem 1.25rem;
      border-radius: 12px;
      background: #f7fbff;
      border: 1px solid #dce9f9;
    }
    .checklist input[type="checkbox"] {
      width: 1.15rem;
      height: 1.15rem;
      margin-top: 0.35rem;
    }
    .interactive-panel {
      background: var(--azul-escuro);
      color: #fff;
      border-radius: 18px;
      padding: 1.75rem;
      display: grid;
      gap: 1rem;
      position: relative;
      overflow: hidden;
    }
    .interactive-panel::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.22), transparent 58%);
      pointer-events: none;
    }
    .interactive-panel label {
      font-weight: 600;
    }
    .interactive-panel select,
    .interactive-panel button {
      border-radius: 10px;
      border: none;
      padding: 0.7rem 0.85rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .interactive-panel select {
      background: #fff;
      color: var(--azul-escuro);
    }
    .interactive-panel button {
      background: linear-gradient(135deg, var(--azul), #0b6ac1);
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s ease, filter 0.2s ease;
    }
    .interactive-panel button:hover {
      transform: translateY(-1px);
      filter: brightness(1.06);
    }
    .interactive-output {
      background: rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      padding: 1.35rem;
      line-height: 1.55;
      font-size: 0.98rem;
    }
    details {
      background: #f7fbff;
      border-radius: 14px;
      border: 1px solid #d9e7f8;
      margin-top: 1.25rem;
      padding: 1rem 1.25rem 1.15rem;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--azul-escuro);
    }
    details pre {
      background: #0b2038;
      color: #d9e9ff;
      padding: 1.1rem 1.25rem;
      border-radius: 12px;
      overflow-x: auto;
      margin-top: 1rem;
      font-size: 0.92rem;
      line-height: 1.45;
    }
    .timeline {
      display: grid;
      gap: 1.25rem;
    }
    .timeline-step {
      background: #fafdff;
      border: 1px solid #d6e6f9;
      border-radius: 14px;
      padding: 1.35rem 1.2rem 1.25rem;
      display: grid;
      gap: 0.75rem;
      position: relative;
    }
    .timeline-step strong {
      color: var(--azul-escuro);
    }
    .timeline-step .label {
      position: absolute;
      top: -12px;
      right: 16px;
      background: var(--amarelo);
      color: #fff;
      font-weight: 700;
      border-radius: 999px;
      padding: 0.25rem 0.75rem;
      letter-spacing: 0.02em;
    }
    .callout {
      border-left: 5px solid var(--verde);
      background: #f0f9f4;
      padding: 1.1rem 1.35rem;
      border-radius: 12px;
      margin-top: 1.5rem;
    }
    .warning {
      border-left-color: var(--vermelho);
      background: #fff1f1;
    }
    footer {
      text-align: center;
      padding: 2rem 1rem 4rem;
      color: #60718b;
      font-size: 0.95rem;
    }
    @media (max-width: 720px) {
      section {
        padding: 2.1rem 1.6rem;
      }
      .interactive-panel {
        padding: 1.3rem 1.2rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Guia de Recriação Total do Projeto na Unreal Engine 5</h1>
    <p>
      Este documento interativo indica a ordem ideal para reconstruir o projeto na UE5 reaproveitando assets originais.
      Cada etapa traz instruções práticas, checklist de prontidão, exemplos em Blueprint e pontos de verificação antes de avançar.
    </p>
  </header>
  <main>
    <section id="resumo">
      <h2>Sequência Recomendada de Implementação</h2>
      <p>
        Foque em <strong>importação controlada dos assets</strong>, seguido de uma <strong>base funcional de interface e inventário</strong>,
        antes de expandir para sistemas de progressão, drops, mapas e efeitos. Esta ordem reduz retrabalho e mantém o jogo jogável rapidamente.
      </p>
      <div class="interactive-panel">
        <div>
          <label for="perfil">Selecione seu foco atual:</label>
          <select id="perfil">
            <option value="default">Quero seguir a ordem ideal sugerida</option>
            <option value="asset">Tenho muitos assets convertidos e quero validar se posso usá-los</option>
            <option value="ui">Preciso reconstruir a interface o quanto antes</option>
            <option value="core">Quero priorizar sistemas centrais (itens, XP, drops)</option>
            <option value="maps">Preciso entregar mapas jogáveis rápido</option>
            <option value="vfx">Necessito atualizar efeitos e feedback audiovisual</option>
          </select>
        </div>
        <button type="button" id="verPlano">Ver ordem sugerida</button>
        <div class="interactive-output" id="saidaPlano">
          Selecione um foco e clique em <strong>Ver ordem sugerida</strong> para receber um roteiro imediato.
        </div>
      </div>
      <div class="grid-3" style="margin-top: 2rem;">
        <div class="card">
          <h3><span class="badge">1º</span> Fase de Validação</h3>
          <ul>
            <li>Auditoria de assets originais e conversão para UE5.</li>
            <li>Configuração de projeto, plugins e convenções.</li>
            <li>Protótipo básico de HUD + inventário navegável.</li>
          </ul>
        </div>
        <div class="card">
          <h3><span class="badge">2º</span> Fase Sistêmica</h3>
          <ul>
            <li>Recriação de itens, XP e drops com dados reaproveitados.</li>
            <li>Estruturação de mapas com spawners, colisões e navegação.</li>
            <li>Validação de rede/multiplayer (se aplicável).</li>
          </ul>
        </div>
        <div class="card">
          <h3><span class="badge">3º</span> Fase Sensorial</h3>
          <ul>
            <li>Atualização de efeitos visuais, sonoros e UI final.</li>
            <li>Polimento de performance, LODs, iluminação e pós-processo.</li>
            <li>Testes completos, correções finais e empacotamento.</li>
          </ul>
        </div>
      </div>
      <div class="checklist">
        <label>
          <input type="checkbox" />
          <span><strong>Inventariou todos os assets reutilizáveis</strong> (modelos, animações, sons, UI, dados) e marcou os que precisam de retrabalho.</span>
        </label>
        <label>
          <input type="checkbox" />
          <span><strong>Definiu a meta de FPS/plataformas alvo</strong> para orientar decisões de LOD, textura e iluminação.</span>
        </label>
        <label>
          <input type="checkbox" />
          <span><strong>Configurou controle de versão</strong> (Perforce, Git LFS ou similar) e separou branch para migração.</span>
        </label>
      </div>
    </section>

    <section id="atlas">
      <h2>Atlas Completo do Projeto Original</h2>
      <p>
        Utilize este atlas para rastrear onde cada funcionalidade do cliente e do servidor reside no projeto legado.
        Ele indica arquivos, diretórios e binários essenciais para orientar a migração 1:1 para a Unreal Engine 5,
        contemplando tanto o frontend (cliente) quanto o backend (servidores e bancos de dados).
      </p>
      <div class="atlas-tabs">
        <button class="atlas-tab active" data-tab="frontend">Cliente (Front-end)</button>
        <button class="atlas-tab" data-tab="backend">Servidor (Back-end)</button>
        <button class="atlas-tab" data-tab="dados">Dados &amp; Scripts Compartilhados</button>
        <button class="atlas-tab" data-tab="pipeline">Integração UE5 (Front + Back)</button>
      </div>

      <div class="atlas-content active" data-tab="frontend">
        <h3>Arquitetura do Cliente Original <small>(pasta <code>Source Main 5.2/source</code>)</small></h3>
        <table class="atlas-table">
          <thead>
            <tr>
              <th>Área</th>
              <th>Arquivos/Diretórios Originais</th>
              <th>Responsabilidade Atual</th>
              <th>Adaptação Recomendada na UE5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Boot &amp; Loop</td>
              <td><code>Winmain.cpp</code>, <code>Winmain.h</code>, <code>Builder.cpp</code></td>
              <td>Cria janela OpenGL, inicializa subsistemas, roda loop de mensagens.</td>
              <td>Recriar fluxo em <code>UGameInstance</code> + <code>AGameModeBase</code>, migrando inicialização para <code>Subsystems</code> e <code>Game Feature Plugins</code>.</td>
            </tr>
            <tr>
              <td>Gestão de UI</td>
              <td><code>UIManager.cpp</code>, <code>NewUIManager.cpp</code>, <code>NewUIMainFrameWindow.cpp</code></td>
              <td>Orquestra HUD legado, troca de janelas e renderização 2D.</td>
              <td>Mapear widgets para <code>UMG</code>/<code>Common UI</code>; criar <code>BP_UIRoot</code> que instancia subwidgets e responde a <code>Gameplay Tags</code>.</td>
            </tr>
            <tr>
              <td>Inventário &amp; Itens</td>
              <td><code>NewUIMyInventory.cpp</code>, <code>ZzzInventory.cpp</code>, <code>ItemManager.cpp</code></td>
              <td>Renderiza slots, valida equipáveis, consulta dados de itens.</td>
              <td>Usar <code>Data Assets</code> e <code>Data Tables</code> em UE5; criar componentes <code>BP_InventoryManager</code> e <code>BP_ItemInstance</code> com replicação opcional.</td>
            </tr>
            <tr>
              <td>Progressão &amp; Personagem</td>
              <td><code>CharacterManager.cpp</code>, <code>QuestMng.cpp</code>, <code>GM3rdChangeUp.cpp</code></td>
              <td>Controla atributos, quests, classes avançadas e desbloqueios.</td>
              <td>Implementar em <code>Actor Components</code> (ex.: <code>BP_ProgressionComponent</code>) e <code>Gameplay Ability System</code> para buffs/skills.</td>
            </tr>
            <tr>
              <td>Mapas &amp; Mundo</td>
              <td><code>MapManager.cpp</code>, <code>w_MapProcess.cpp</code>, diretório <code>Time/</code></td>
              <td>Carrega dados de mapas, portais, horários de eventos e colisões.</td>
              <td>Converter layouts em <code>Level Streaming</code> / <code>World Partition</code>; migrar triggers para <code>Blueprint Actors</code> reutilizando CSVs como <code>Data Tables</code>.</td>
            </tr>
            <tr>
              <td>Efeitos &amp; Renderização</td>
              <td><code>ZzzEffect.cpp</code>, <code>SkillEffectMgr.cpp</code>, <code>GlobalBitmap.cpp</code>, <code>TextureScript.cpp</code></td>
              <td>Gera partículas, animações de habilidades e gerencia texturas legacy.</td>
              <td>Transformar assets em sistemas Niagara/Material Functions; migrar tabelas de efeitos para <code>Curve</code> e <code>Data Assets</code>.</td>
            </tr>
            <tr>
              <td>Rede &amp; Protocolos</td>
              <td><code>ProtocolSend.cpp</code>, <code>SocketSystem.cpp</code>, <code>WSclient.cpp</code></td>
              <td>Empacota mensagens, gerencia sockets TCP, interpreta respostas do servidor.</td>
              <td>Substituir por camadas HTTP/WebSocket/GRPC via <code>FHttpModule</code> ou plugins; definir <code>BP_ServerGateway</code> para traduzir mensagens.</td>
            </tr>
            <tr>
              <td>Localização &amp; Texto</td>
              <td><code>GlobalText.h</code>, <code>MultiLanguage.cpp</code>, <code>Local.cpp</code></td>
              <td>Carrega arquivos de texto, alterna idiomas e strings dinâmicas.</td>
              <td>Importar para <code>Localization Dashboard</code> da UE5; usar <code>FText</code> com <code>String Tables</code> para manter suporte multi-idioma.</td>
            </tr>
          </tbody>
        </table>
        <div class="atlas-highlight">
          <strong>Checklist Frontend:</strong>
          <ul class="atlas-list">
            <li>Revisar dependências OpenGL/Win32 em <code>Winmain.cpp</code> para substituição por módulos UE5.</li>
            <li>Gerar inventário de widgets <code>NewUI*</code> e mapear cada um para um <em>Widget Blueprint</em> equivalente.</li>
            <li>Converter dados lidos via <code>LoadData.cpp</code> em <code>Data Tables</code> para compartilhar com o backend.</li>
          </ul>
        </div>
      </div>

      <div class="atlas-content" data-tab="backend">
        <h3>Arquitetura dos Servidores <small>(pasta <code>MuServer_Season_5_Update_15</code>)</small></h3>
        <table class="atlas-table">
          <thead>
            <tr>
              <th>Componente</th>
              <th>Localização</th>
              <th>Função</th>
              <th>Pontos para Migração</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>ConnectServer</td>
              <td><code>ConnectServer/</code></td>
              <td>Autenticação inicial, direciona clientes para <em>JoinServer</em>.</td>
              <td>Planeje endpoint REST/WebSocket para handshake; mantenha lista de shards/configuração.</td>
            </tr>
            <tr>
              <td>JoinServer</td>
              <td><code>JoinServer/</code></td>
              <td>Gerencia login de contas, seleção de servidor e fila.</td>
              <td>Converter lógica para serviço de identidade (OAuth/JWT) integrado a banco atual.</td>
            </tr>
            <tr>
              <td>DataServer</td>
              <td><code>DataServer/</code></td>
              <td>Centraliza persistência de personagens, inventário e XP.</td>
              <td>Modelar APIs de persistência (REST/GraphQL) + camada de acesso a dados moderna (ORM ou microserviço).</td>
            </tr>
            <tr>
              <td>GameServer</td>
              <td><code>GameServer/</code> + <code>GameServer/DATA</code></td>
              <td>Executa lógica em tempo real, eventos, drops, skills.</td>
              <td>Planejar reescrita em engine servidor (C++/C#/Go) consumindo mesmas tabelas que UE5; migrar scripts <code>*.dat</code> e <code>.txt</code> para base comum.</td>
            </tr>
            <tr>
              <td>GameServerCS</td>
              <td><code>GameServerCS/</code></td>
              <td>Instância dedicada a Castle Siege e eventos PvP massivos.</td>
              <td>Separar serviços escaláveis (matchmaking/eventos) e sincronizar com UE5 via filas ou serviços em nuvem.</td>
            </tr>
            <tr>
              <td>MHPServer</td>
              <td><code>MHPServer/</code></td>
              <td>Proteção/anticheat legado com monitoramento de pacotes.</td>
              <td>Substituir por solução anti-cheat compatível com UE5 (EOS, Easy Anti-Cheat, VAC) ou criar validações server-side.</td>
            </tr>
            <tr>
              <td>Banco de Dados</td>
              <td><code>DB/</code>, <code>ScriptSql/</code></td>
              <td>Scripts SQL de criação, procedures e seeds.</td>
              <td>Revisar tabelas para normalização; gerar modelos ER atualizados para migração.</td>
            </tr>
            <tr>
              <td>Ferramentas</td>
              <td><code>Tools/</code></td>
              <td>Utilitários de manutenção (ex.: reset, monitoramento de eventos).</td>
              <td>Identificar ferramentas imprescindíveis e recriar painéis Web/CLI com APIs modernas.</td>
            </tr>
          </tbody>
        </table>
        <div class="atlas-highlight">
          <strong>Checklist Backend:</strong>
          <ul class="atlas-list">
            <li>Mapear dependências entre executáveis (ordem de inicialização em <code>StartUp/</code>).</li>
            <li>Catalogar arquivos <code>GameServerInfo - *.dat</code> para definir configurações que devem virar serviços de configuração.</li>
            <li>Exportar procedures críticas do diretório <code>ScriptSql</code> para documentação e refatoração.</li>
          </ul>
        </div>
      </div>

      <div class="atlas-content" data-tab="dados">
        <h3>Dados Compartilhados Entre Cliente e Servidor</h3>
        <div class="atlas-grid">
          <div>
            <strong>Diretório <code>MuServer_Season_5_Update_15/Data</code></strong>
            <ul class="atlas-list">
              <li><code>Item/</code>: tabelas <code>Item.txt</code>, <code>ItemDrop.txt</code>, <code>ItemOption.txt</code>, <code>ItemValue.txt</code> — base para inventário, drops e economia.</li>
              <li><code>Event/</code>: arquivos <code>BloodCastle.dat</code>, <code>DevilSquare.dat</code>, <code>ImperialGuardian.dat</code> descrevendo horários, bosses, recompensas.</li>
              <li><code>Custom/</code>: ajustes proprietários (ex.: <code>CustomCombo.txt</code>, <code>CustomMix.txt</code>, <code>CustomJewel.txt</code>) a serem refletidos em sistemas UE5.</li>
              <li><code>Character/</code>: limites de atributos, taxas de XP e configurações de classes.</li>
              <li>Arquivos globais (<code>Command.txt</code>, <code>Effect.txt</code>, <code>ItemMove.txt</code>) mapeiam comandos e efeitos utilizados tanto no cliente quanto no servidor.</li>
            </ul>
          </div>
          <div>
            <strong>Cliente <code>Source Main 5.2/source</code></strong>
            <ul class="atlas-list">
              <li><code>LoadData.cpp</code> &amp; <code>ReadScript.h</code>: rotinas de parsing de arquivos <code>.txt</code>/<code>.dat</code>.</li>
              <li><code>QuestInfo.cpp</code> e <code>QuestMng.cpp</code>: interpretam scripts de quests armazenados no servidor.</li>
              <li><code>GlobalText.h</code> + <code>Local.cpp</code>: strings compartilhadas com base nos mesmos IDs dos bancos de dados.</li>
            </ul>
          </div>
        </div>
        <div class="atlas-highlight">
          <strong>Práticas Recomendadas:</strong>
          <ul class="atlas-list">
            <li>Centralizar arquivos <code>.txt/.dat</code> em um repositório de dados versionado (Git LFS) e convertê-los para <code>JSON</code> ou <code>CSV</code> padronizado.</li>
            <li>Gerar <em>schemas</em> para cada tabela reutilizada, garantindo compatibilidade entre UE5 e backend moderno.</li>
            <li>Automatizar importação com scripts Python/C# que populam <code>Data Tables</code> na UE5 e alimentam o banco novo.</li>
          </ul>
        </div>
      </div>

      <div class="atlas-content" data-tab="pipeline">
        <h3>Pipeline Integrado Front + Back para Recriação na UE5</h3>
        <ol>
          <li><strong>Inventário de Assets</strong>: classifique meshes, texturas, ícones e sons oriundos do cliente e relacione com tabelas de itens (<code>Data/Item</code>).</li>
          <li><strong>Modelagem de APIs</strong>: transforme processos do <code>GameServer</code> em endpoints (login, load player, salvar inventário, rolagem de drop).</li>
          <li><strong>Sincronização de Dados</strong>: estabeleça formato único (ex.: <code>JSON</code>) e gere conversores a partir dos scripts originais (<code>LoadData.cpp</code>, <code>GameServerInfo - *.dat</code>).</li>
          <li><strong>Blueprint Gateway</strong>: crie <code>BP_ServerGateway</code> para consumir APIs (Login, CharacterLoad, ItemUpdate) com <code>Async Action</code> + <code>HTTP Request</code>.</li>
          <li><strong>Testes Integrados</strong>: para cada sprint, valide uma cadeia completa (ex.: login → carregar inventário → spawn mapa → evento → drop → salvar).</li>
        </ol>
        <div class="atlas-highlight">
          <strong>Ferramentas de Apoio:</strong>
          <ul class="atlas-list">
            <li>Scripts SQL do diretório <code>ScriptSql</code> como referência para modelar migrations modernas.</li>
            <li>Executáveis legados para capturar pacotes (útil ao recriar protocolos em UE5 via <code>Packet Capture</code>).</li>
            <li>Planilhas de estado de assets e dados compartilhados para acompanhar o progresso da migração.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="etapas">
      <h2>Etapas Detalhadas e Critérios de Saída</h2>
      <article>
        <h3>Etapa 0 – Preparação e Auditoria</h3>
        <p><strong>Objetivo:</strong> Garantir que o ambiente esteja pronto e todos os assets tenham status definido antes da migração.</p>
        <ul>
          <li>Configurar projeto UE5 (Game Feature Plugins conforme necessidade, Subsystems, Common UI).</li>
          <li>Importar assets de teste para validar pipelines (1 personagem, 1 arma, 1 HUD, 1 mapa pequeno).</li>
          <li>Criar planilha com origem &gt; destino (texturas, materiais, animações, sons, dados CSV/JSON).</li>
          <li>Montar pasta <code>/Game/LegacyImports</code> e subpastas por categoria (Characters, UI, FX...).</li>
          <li>Estabelecer nomeação consistente (prefixos BP_, SK_, UI_, FX_...).</li>
        </ul>
        <div class="callout warning">
          <strong>Atenção:</strong> Se o asset exigir conversão (por exemplo, materiais antigos), documente o esforço estimado antes de prosseguir para evitar gargalos no meio da recriação dos sistemas.
        </div>
      </article>
      <article>
        <h3>Etapa 1 – Núcleo Jogável (HUD + Inventário)</h3>
        <p><strong>Objetivo:</strong> Viabilizar uma experiência jogável mínima com interface responsiva.</p>
        <ol>
          <li><strong>HUD Modular:</strong> converter elementos UI legados em Widgets UMG separados (barra de vida, mana, XP, minimapa).</li>
          <li><strong>Inventário Base:</strong> criar <em>Data Assets</em> ou tabelas de dados com itens originais; gerar Blueprint <code>BP_InventoryManager</code>.</li>
          <li><strong>Input/UI:</strong> utilizar Enhanced Input + Common UI para navegação com teclado/mouse e controle.</li>
          <li><strong>Persistência:</strong> estruturar salvamento temporário em <code>UGameInstance</code> ou <code>USaveGame</code>.</li>
          <li><strong>Verificação:</strong> jogador consegue abrir HUD, equipar, consumir item e ver feedback visual.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Build jogável onde é possível iniciar partida, visualizar HUD completo e manipular inventário sem falhas.
        </div>
      </article>
      <article>
        <h3>Etapa 2 – Sistemas de Progressão (Itens, XP, Drops)</h3>
        <p><strong>Objetivo:</strong> Reimplementar lógica central reaproveitando dados e comportamento já existente.</p>
        <ol>
          <li><strong>Itens:</strong> Criar <code>BP_ItemBase</code> com metadados (tipo, raridade, efeitos). Importar ícones existentes.</li>
          <li><strong>XP/Nível:</strong> Montar curva de XP (<code>CurveFloat</code>) ou tabela. Implementar <code>BP_ProgressionComponent</code>.</li>
          <li><strong>Drops:</strong> Configurar <code>Data Table</code> com tabelas de loot legadas e componente <code>BP_LootSpawner</code>.</li>
          <li><strong>Balanceamento:</strong> Criar mapa de teste com inimigos representativos e ajustar probabilidades.</li>
          <li><strong>Economia:</strong> Validar integração com moeda/loja se aplicável.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Inimigos derrotados dropam itens corretos, XP sobe conforme curva e jogador atinge nível alvo sem inconsistências.
        </div>
      </article>
      <article>
        <h3>Etapa 3 – Mapas e Conteúdo Jogável</h3>
        <p><strong>Objetivo:</strong> Migrar mapas mantendo navegação, colisões e atmosferas originais.</p>
        <ol>
          <li><strong>Layout:</strong> Usar Level Partitioning/World Composition para mapas extensos. Importar malhas estáticas e colisões personalizadas.</li>
          <li><strong>Navegação:</strong> Regerar NavMesh, volumes de bloqueio, triggers e volumes de respawn.</li>
          <li><strong>Streaming:</strong> Configurar <code>World Partition</code> ou subníveis para iluminação e som.</li>
          <li><strong>Scripts:</strong> Migrar lógica de missões/eventos para <code>Level Blueprint</code> ou <code>Actor Components</code>.</li>
          <li><strong>Testes:</strong> Percorrer cada mapa verificando colisão, iluminação e performance.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Todos os mapas carregam em 30s, sem luzes quebradas, sem buracos de colisão e com triggers funcionais.
        </div>
      </article>
      <article>
        <h3>Etapa 4 – Efeitos, Áudio e Polimento</h3>
        <p><strong>Objetivo:</strong> Restaurar feedback audiovisual e preparar build final.</p>
        <ol>
          <li><strong>VFX:</strong> Atualizar partículas no Niagara reaproveitando texturas/meshes antigos.</li>
          <li><strong>SFX:</strong> Conectar trilhas e sons via <code>MetaSounds</code> ou Sound Cues.</li>
          <li><strong>Iluminação:</strong> Ajustar Lumen, pós-processo e exposição. Validar escalas de lightmaps.</li>
          <li><strong>Performance:</strong> Verificar <em>GPU Visualizer</em>, profiler e ativar LODs/streaming.</li>
          <li><strong>Entrega:</strong> Empacotar build, rodar smoke tests e criar checklist final.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Build final com áudio/visual coerentes, rodando estável dentro das metas de performance definidas na preparação.
        </div>
      </article>
    </section>

    <section id="blueprints">
      <h2>Exemplos Práticos em Blueprint</h2>
      <p>Use os snippets abaixo como base para recriar a lógica principal em Blueprints reaproveitando assets existentes.</p>
      <details open>
        <summary>HUD Dinâmico e Inventário (Widget Blueprint)</summary>
        <ol>
          <li>Criar <code>WBP_HUD</code> contendo componentes de barra de vida/mana (Progress Bar) e painel de inventário (Uniform Grid).</li>
          <li>Associar <code>BP_InventoryManager</code> ao Player Controller e expor eventos <em>OnInventoryChanged</em>.</li>
          <li>No Event Graph do widget, reagir ao evento para atualizar ícones reaproveitados.</li>
        </ol>
        <pre><code>Event Construct
  → Get Player Controller → Cast to BP_PlayerController
  → Bind Event to InventoryManager.OnInventoryChanged

Custom Event OnInventoryChanged (Itens)
  → Clear Children (GridInventario)
  → ForEach Itens:
      Create Widget (WBP_ItemSlot)
      SetData (ItemID, IconeTextura, Quantidade)
      Add Child to Grid (coluna = Index % 6, linha = Index / 6)</code></pre>
      </details>
      <details>
        <summary>Sistema de Itens com Data Table</summary>
        <ol>
          <li>Criar <code>DT_Items</code> (Data Table) baseado em struct <code>FItemStats</code> contendo Nome, Tipo, Raridade, Mesh, Icone, Efeito.</li>
          <li>No <code>BP_ItemBase</code>, adicionar variável <code>ItemRowName</code> e carregar dados na construção.</li>
          <li>Expor função <code>ApplyEffect</code> para uso por consumíveis ou equipamentos.</li>
        </ol>
        <pre><code>Event OnConstruct (BP_ItemBase)
  → Get Data Table Row (DT_Items, ItemRowName)
  → Set DisplayName, Icon, Mesh, Stats

Function ApplyEffect (Alvo)
  Switch on ItemType
    Consumivel → Alvo.ApplyHealth(Stats.HealAmount)
    Equipamento → Alvo.EquiparSlot(Stats.Slot, self)
    Gema → Alvo.AtribuirBuff(Stats.BuffID, Stats.Duration)</code></pre>
      </details>
      <details>
        <summary>XP e Level Up Automatizado</summary>
        <ol>
          <li>Criar componente <code>BP_ProgressionComponent</code> com variáveis <code>CurrentXP</code>, <code>CurrentLevel</code>, <code>XPTable</code>.</li>
          <li>Adicionar função <code>AddExperience</code> chamada por inimigos ao morrer.</li>
          <li>Disparar evento <code>OnLevelUp</code> que atualiza HUD e atributos do personagem.</li>
        </ol>
        <pre><code>Function AddExperience (Amount)
  CurrentXP += Amount
  while CurrentXP ≥ XPTable[CurrentLevel]
    CurrentXP -= XPTable[CurrentLevel]
    CurrentLevel += 1
    OnLevelUp.Broadcast(CurrentLevel)

Event OnLevelUp
  → PlayerStatsComponent.IncrementarAtributos(CurrentLevel)
  → HUDWidget.PlayAnimation(LevelUpAnim)
  → Spawn Niagara (FX_LevelUp) na localização do jogador</code></pre>
      </details>
      <details>
        <summary>Drop de Loot Dinâmico</summary>
        <ol>
          <li><code>BP_LootSpawner</code> recebe tabela <code>DT_LootTable</code> herdada do jogo original.</li>
          <li>Ao destruir inimigo, chamar <code>SpawnLoot</code> informando <em>LootContext</em> (região, dificuldade).</li>
          <li>Gerar item físico com mesh/partícula reutilizada.</li>
        </ol>
        <pre><code>Function SpawnLoot (LootContext)
  EntradasVálidas ← Filtrar DT_LootTable por Região &amp; Raridade
  Sorteio ← Random Weighted Selection (DropRate)
  SpawnActor BP_ItemPickup at GetActorLocation()
  ItemPickup.SetItemID(Sorteio.ItemID)
  ItemPickup.PlayNiagara(FX_Drop, Cor = Sorteio.RaridadeCor)
  ItemPickup.Bind OnCollected → Inventario.AddItem(ItemID)</code></pre>
      </details>
      <details>
        <summary>Carregamento de Mapas com Subníveis</summary>
        <ol>
          <li>Converter mapas grandes para <code>World Partition</code> e criar <em>Data Layers</em> para iluminação, efeitos e gameplay.</li>
          <li>Usar <code>BP_MapManager</code> para carregar subníveis com base na proximidade do jogador.</li>
          <li>Controlar música ambiente e sons locais via <code>Audio Volumes</code>.</li>
        </ol>
        <pre><code>Event BeginPlay (BP_MapManager)
  → Set Data Layer State (Exploração, Loaded)
  → Load Stream Level (Dungeon_Entrada)

Event OnPlayerReachedPortal
  → Load Stream Level (Dungeon_Boss)
  → Set Data Layer State (Exploração, Unloaded)
  → Set Data Layer State (BossFight, Loaded)
  → AudioManager.PlayCue(MusicaBoss)</code></pre>
      </details>
      <details>
        <summary>Efeitos Visuais Atualizados no Niagara</summary>
        <ol>
          <li>Importar texturas de partículas legadas para o Niagara e criar <code>NS_SpellImpact</code>.</li>
          <li>Expor parâmetros de cor e escala para refletir raridade do item/skill.</li>
          <li>Chamar efeito via <code>GameplayCue</code> ou diretamente nos Blueprints de habilidade.</li>
        </ol>
        <pre><code>Function PlayImpactFX (Contexto)
  NiagaraComponent.SetVariableLinearColor("Color", Contexto.RaridadeCor)
  NiagaraComponent.SetVariableFloat("Scale", Contexto.Escala)
  NiagaraComponent.Activate()
  AudioComponent.Play()
  CameraShake.Play(Contexto.ShakeClass)</code></pre>
      </details>
      <details>
        <summary>Gateway UE5 &lt;&gt; Servidor Moderno (HTTP/JSON)</summary>
        <ol>
          <li>Criar <code>BP_ServerGateway</code> (Object Blueprint) com funções assíncronas para Login, LoadCharacter, SaveInventory.</li>
          <li>Utilizar <code>FHttpModule</code> via <em>Blueprint Function Library</em> (nós <code>Execute HTTP Request</code> ou plugin VaRest) para chamar APIs REST.</li>
          <li>Serializar/deserializar <code>JSON</code> refletindo os mesmos campos dos arquivos <code>Data/Item</code> e tabelas SQL.</li>
          <li>Propagar resultados via <em>Delegates</em> (ex.: <code>OnInventoryReceived</code>) para atualizar HUD/inventário.</li>
        </ol>
        <pre><code>Function LoginAsync (Email, Senha)
  Create Request (POST, /auth/login)
  Set Header "Content-Type" = "application/json"
  Set Content (Make JSON → { "email": Email, "password": Senha })
  Send
  On Success:
    Parse JSON → Token, Characters[]
    Store Token
    Broadcast OnLoginSuccess(Token, Characters)
  On Error:
    Broadcast OnLoginFailed(StatusCode, Message)

Function LoadInventoryAsync (CharacterID)
  Create Request (GET, /characters/{CharacterID}/inventory)
  Set Header "Authorization" = Token
  Send
  On Success:
    Parse JSON → Itens[]
    Broadcast OnInventoryReceived(Itens)

Delegate OnInventoryReceived(Itens)
  → BP_InventoryManager.UpdateFromServer(Itens)</code></pre>
      </details>

    </section>

    <section id="codigo-detalhado">
      <h2>Mapeamento de Código &rarr; Blueprints UE5</h2>
      <p>
        Use o painel abaixo para navegar entre os módulos principais. Cada aba traz o trecho de código do projeto
        original, a leitura da lógica e o passo a passo para replicar em Blueprints na Unreal Engine 5 reaproveitando
        os mesmos assets, coordenadas e fluxos de dados.
      </p>
      <div class="conversion-tabs" role="tablist">
        <button class="conversion-button active" data-pane="hud">HUD &amp; Barra de Experiência</button>
        <button class="conversion-button" data-pane="inventory">Inventário e Equipamentos</button>
        <button class="conversion-button" data-pane="progression">Progressão / XP</button>
        <button class="conversion-button" data-pane="drops">Sistema de Drops</button>
        <button class="conversion-button" data-pane="maps">Mapas e Navegação</button>
        <button class="conversion-button" data-pane="effects">Efeitos Visuais</button>
      </div>

      <article class="conversion-pane active" data-pane="hud">
        <h3>HUD Principal com Layout Original</h3>
        <p>
          O cliente define a HUD no <code>CNewUIMainFrameWindow</code>, renderizando faixas, gauges e botões com offsets
          absolutos para 640&times;480 e ajustes proporcionais. Esses valores são a referência direta para posicionar os
          widgets UMG reaproveitando as texturas convertidas de <code>Interface\*.ozj/.ozt</code>.
        </p>
        <div class="source-card">
          <div class="source-meta">Cliente original – <code>Source Main 5.2/source/NewUIMainFrameWindow.cpp</code></div>
          <pre><code>bool SEASON3B::CNewUIMainFrameWindow::Render()
{
        EnableAlphaTest();
        RenderFrame();
        RenderLifeMana();
        RenderGuageSD();
        RenderGuageAG();
        RenderButtons();
        RenderExperience();
        DisableAlphaBlend();
        return true;
}

void SEASON3B::CNewUIMainFrameWindow::RenderFrame()
{
        float width, height;
        float x, y;

        width = 256.f; height = 51.f;
        x = 0.f; y = 480.f - height;
        SEASON3B::RenderImage(IMAGE_MENU_1, x, y, width, height);
        width = 128.f;
        x = 256.f;
        SEASON3B::RenderImage(IMAGE_MENU_2, x, y, width, height);
        width = 256.f;
        x = 256.f + 128.f;
        SEASON3B::RenderImage(IMAGE_MENU_3, x, y, width, height);
}

void SEASON3B::CNewUIMainFrameWindow::RenderGuageSD()
{
        width = 16.f; height = 39.f;
        x = 204; y = 480.f - 49.f;
        RenderBitmap(IMAGE_GAUGE_SD, x, y + (fShield * height), width, height - (fShield * height), 0.f, fShield*height/64.f, width/16.f, (1.0f - fShield)*height/64.f);
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Experiência – <code>RenderExperience()</code> no mesmo arquivo</div>
          <pre><code>x = 2.f; y = 473.f; width = fProgress * 629.f; height = 4.f;
RenderBitmap(IMAGE_GAUGE_EXBAR, x, y, width, height, 0.f, 0.f, 6.f/8.f, 4.f/4.f);
SEASON3B::RenderNumber(635.f, 469.f, (int)fExpBarNum);
if(SEASON3B::CheckMouseIn(x, y, 629.f, 4.f) == true)
{
        sprintf(strTipText, GlobalText[1748], dwExperience, dwNexExperience);
        RenderTipText(280, 418, strTipText);
}</code></pre>
        </div>
        <svg class="layout-map" viewBox="0 0 640 480" aria-labelledby="hud-layout-title">
          <title id="hud-layout-title">Mapa visual da HUD original (640×480)</title>
          <rect x="0" y="429" width="256" height="51" />
          <text x="12" y="446">Menu 1</text>
          <rect x="256" y="429" width="128" height="51" />
          <text x="268" y="446">Menu 2</text>
          <rect x="384" y="429" width="256" height="51" />
          <text x="396" y="446">Menu 3</text>
          <rect class="asset" x="158" y="432" width="45" height="39" />
          <text x="163" y="452">HP</text>
          <rect class="asset" x="437" y="432" width="45" height="39" />
          <text x="442" y="452">MP</text>
          <rect class="asset" x="204" y="431" width="16" height="39" />
          <text x="205" y="425">SD</text>
          <rect class="asset" x="420" y="431" width="16" height="39" />
          <text x="421" y="425">AG</text>
          <rect class="asset" x="2" y="473" width="629" height="4" />
          <text x="6" y="468">XP</text>
        </svg>
        <h4>Passo a passo no UMG</h4>
        <ol>
          <li>Converter as texturas <code>Interface\newui_menu0*.ozj</code>, <code>Interface\newui_menu_red.ozj</code>, <code>Interface\newui_menu_blue.ozj</code>, <code>Interface\newui_menu_sd.ozj</code> e <code>Interface\newui_menu_ag.ozj</code> para <code>.png</code> preservando as dimensões (use a rotina descrita em <code>GlobalBitmap.cpp</code> para remover o cabeçalho de 24 bytes).</li>
          <li>Criar <code>WBP_HUD</code> com um <em>Canvas Panel</em> raiz travado em 640×480 e habilitar <em>Screen Alignment = Fill</em>. Ajustar as âncoras das imagens seguindo o mapa acima (faixas ancoradas em Bottom Stretch, gauges em pontos absolutos).</li>
          <li>Adicionar <em>Progress Bars</em> para HP/MP/SD/AG usando <em>Fill from Bottom</em> e máscaras do mesmo tamanho dos sprites. Os valores de preenchimento replicam <code>height - (valor/max * height)</code>.</li>
          <li>Adicionar um <em>Border</em> invisível sobre a barra de XP e ligar ao evento <code>OnMouseMove</code> para mostrar um tooltip idêntico a <code>RenderTipText</code> (usar <code>Format Text</code> para exibir <em>XP atual</em> / <em>próximo nível</em>).</li>
          <li>Para múltiplas resoluções, encapsular o Canvas em um <em>Scale Box</em> com <em>Stretch = ScaleToFit</em> e expor um multiplicador de DPI para manter legibilidade em monitores maiores.</li>
        </ol>
        <h4>Blueprint (Widget Graph)</h4>
        <pre><code>Event Construct
  → Bind OnStatChanged (BP_PlayerState)
  → AtualizarHUD(Stats)

Event AtualizarHUD (Stats)
  → SetPercent(HPBar, Stats.HP / Stats.MaxHP)
  → SetPercent(MPBar, Stats.MP / Stats.MaxMP)
  → SetPercent(SDBar, Stats.SD / Stats.MaxSD)
  → SetPercent(AGBar, Stats.AG / Stats.MaxAG)
  → AtualizarXP(Stats.CurrentXP, Stats.NextXP)

Function AtualizarXP (XPAtual, XPNecessaria)
  → Progress = Clamp(XPAtual / XPNecessaria, 0, 1)
  → XPBar.SetFillAmount(Progress)
  → XPLabel.SetText(FText::Format("{0}/10", Floor(Progress * 10)))</code></pre>
        <div class="callout">
          <strong>Dica de conversão:</strong> Os botões inferiores usam sprites <code>Interface\partCharge1\newui_menu_Bt*.ozj</code> espaçados de 30&nbsp;px. Monte um <code>UniformGridPanel</code> com colunas fixas e ícones reutilizados para preservar o comportamento original.</div>
      </article>

      <article class="conversion-pane" data-pane="inventory">
        <h3>Inventário, Slots e Equipamentos</h3>
        <p>O inventário é criado por <code>CNewUIMyInventory</code>, instanciando um <code>CNewUIInventoryCtrl</code> e carregando os frames de fundo, botões e slots.</p>
        <div class="source-card">
          <div class="source-meta">Cliente – <code>Source Main 5.2/source/NewUIMyInventory.cpp</code></div>
          <pre><code>bool SEASON3B::CNewUIMyInventory::Create(CNewUIManager* pNewUIMng,
        CNewUI3DRenderMng* pNewUI3DRenderMng, int x, int y)
{
        m_pNewInventoryCtrl = new CNewUIInventoryCtrl;
        if(false == m_pNewInventoryCtrl->Create(m_pNewUI3DRenderMng, g_pNewItemMng,
                this, x+15, y+200, 8, 8))
        {
                SAFE_DELETE(m_pNewInventoryCtrl);
                return false;
        }

        SetPos(x, y);
        LoadImages();
        SetEquipmentSlotInfo();
        SetButtonInfo();
        Show(false);
        return true;
}</code></pre>
        </div>
        <h4>Como migrar para Widget Blueprint</h4>
        <ol>
          <li>Converter os sprites <code>Interface\newui_item_back*.ozt</code>, <code>Interface\newui_item_table*.ozt</code>, <code>Interface\newui_exit_00.ozt</code> e ícones de slots para <code>.png</code>. Use as dimensões originais (ex.: 190×320 para o fundo) e mantenha o padding.</li>
          <li>Criar <code>WBP_Inventory</code> com Canvas 640×480. Posicionar o background em <code>(15, 200)</code> para replicar <code>x+15, y+200</code>.</li>
          <li>Adicionar <code>UniformGridPanel</code> 8×8 com células 32×32. Cada item deve armazenar <code>GridX</code>, <code>GridY</code>, <code>Width</code> e <code>Height</code> para suportar itens 2×n.</li>
          <li>Implementar <code>BP_InventoryComponent</code> no personagem com array de <code>FInventorySlot</code> (ItemID, Quantidade, Rotação, Estados). Expor eventos <code>OnItemAdded</code>, <code>OnItemRemoved</code>, <code>OnSlotUpdated</code>.</li>
          <li>No widget, ligar os eventos para replicar <code>AddItem</code>, <code>DeleteItem</code> e <code>FindItemAtPt</code>, atualizando ícones e highlights.</li>
          <li>Para equipamentos, criar painel lateral com slots nomeados. Mapeie <code>MAX_EQUIPMENT_INDEX</code> e <code>EQUIPMENT_WEAPON_LEFT</code> para <em>Enums</em> blueprint e chame o gateway REST equivalente a <code>SendRequestEquippingInventoryItem</code>.</li>
        </ol>
        <h4>Blueprint sugerido (arrastar &amp; soltar)</h4>
        <pre><code>OnMouseButtonDown (ItemSlot)
  → DetectDragIfPressed

OnDragDetected
  → Create DragDropOperation
  → Operation.Payload = SlotData
  → Operation.DefaultDragVisual = WBP_ItemGhost (usa sprite original)

OnDrop
  → TargetSlot = Grid.Coordenada
  → InventoryComponent.TryMoveItem(Payload.Index, TargetSlot)
  → Se sucesso → AtualizarSlotVisual(TargetSlot)
  → Se falha → Reverter visual</code></pre>
        <div class="callout warning">
          <strong>Sincronização com o servidor:</strong> Cada movimento deve chamar <code>POST /inventory/move</code> replicando as mesmas validações de <code>CGItemDropRecv</code> (itens bloqueados, periódicos, lucky items). O backend precisa retornar o inventário atualizado para evitar divergências.</div>
      </article>

      <article class="conversion-pane" data-pane="progression">
        <h3>Progressão de Experiência (Cliente + Servidor)</h3>
        <p>O cliente calcula a fração da barra enquanto o servidor controla o ganho de XP e a distribuição de pontos.</p>
        <div class="source-card">
          <div class="source-meta">Cliente – <code>RenderExperience()</code> em <code>NewUIMainFrameWindow.cpp</code></div>
          <pre><code>float fNeedExp = dwNexExperience - dwPriorExperience;
float fExp = dwExperience - dwPriorExperience;
float fExpBarNum = (fExp / fNeedExp) * 10.f;
float fProgress = fExpBarNum - (int)fExpBarNum;
RenderBitmap(IMAGE_GAUGE_EXBAR, 2.f, 473.f, fProgress * 629.f, 4.f, 0.f, 0.f, 6.f/8.f, 4.f/4.f);
SEASON3B::RenderNumber(635.f, 469.f, (int)fExpBarNum);</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Servidor – <code>CObjectManager::CharacterLevelUp</code></div>
          <pre><code>if((lpObj->Experience+AddExperience) < lpObj->NextExperience)
{
        lpObj->Experience += AddExperience;
        return 0;
}

while(true)
{
        lpObj->Level++;
        lpObj->LevelUpPoint += gServerInfo.m_LevelUpPoint[lpObj->Class];
        AddExperience -= (((--MaxLevelUp)==0)?AddExperience:(lpObj->NextExperience-lpObj->Experience));
        lpObj->Experience = lpObj->NextExperience;
        gObjCalcExperience(lpObj);
        if((lpObj->Experience+AddExperience) < lpObj->NextExperience)
        {
                lpObj->Experience += AddExperience;
                break;
        }
}</code></pre>
        </div>
        <h4>Blueprint + Backend</h4>
        <ol>
          <li>Criar <code>BP_ProgressionComponent</code> com tabela de XP importada do servidor. Variáveis: <code>CurrentXP</code>, <code>NextXP</code>, <code>Level</code>, <code>PendingLevelUps</code>, <code>PointsToSpend</code>.</li>
          <li>Ao receber XP do servidor (resposta ao equivalente de <code>CharacterLevelUp</code>), aplicar a lógica <code>while</code> em Blueprint para consumir múltiplos level ups.</li>
          <li>Disparar <code>OnLevelUp</code> para atualizar atributos, HUD e tocar efeitos. Reaproveitar animações <code>FX_LevelUp</code> e sons originais.</li>
          <li>Persistir pontos gastando via endpoint <code>POST /characters/{id}/stats</code>, enviando <code>PointsToSpend</code> e atributos finais.</li>
        </ol>
        <h4>Blueprint de processamento</h4>
        <pre><code>OnReceiveXPUpdate (Payload)
  → CurrentXP = Payload.CurrentXP
  → NextXP = Payload.NextXP
  → Level = Payload.Level
  → PointsToSpend = Payload.Points
  → PendingLevelUps = Payload.LevelUps
  → HUDWidget.AtualizarXP(CurrentXP, NextXP)
  → For Loop (Index = 0 .. PendingLevelUps-1)
        → HUDWidget.PlayAnimation(LevelUpAnim)
        → SpawnEmitterAtLocation(FX_LevelUp)
        → PlaySound(LevelUpSound)</code></pre>
        <div class="callout">
          <strong>Validação:</strong> mantenha o cálculo oficial no backend para evitar exploits. O Blueprint apenas replica o resultado para feedback imediato.</div>
      </article>

      <article class="conversion-pane" data-pane="drops">
        <h3>Sistema de Drop e Restrições</h3>
        <p>Os drops verificam múltiplas condições antes de delegar ao mapa. O mesmo fluxo deve existir no backend moderno.</p>
        <div class="source-card">
          <div class="source-meta">Servidor – <code>Source MuServer Update 15/GameServer/GameServer/ItemManager.cpp</code></div>
          <pre><code>void CItemManager::CGItemDropRecv(PMSG_ITEM_DROP_RECV* lpMsg,int aIndex)
{
        CItem* lpItem = &lpObj->Inventory[lpMsg->slot];
        if(lpItem->IsLuckyItem() != 0 || lpItem->m_IsPeriodicItem != 0)
        {
                DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
                return;
        }
        if(gItemMove.CheckItemMoveAllowDrop(lpItem->m_Index) == 0)
        {
                DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
                return;
        }
        ...
        if(gMap[lpObj->Map].ItemDrop(lpItem->m_Index,lpItem->m_Level,lpItem->m_Durability,
                lpMsg->x,lpMsg->y,lpItem->m_Option1,lpItem->m_Option2,lpItem->m_Option3,
                lpItem->m_NewOption,lpItem->m_SetOption,lpItem->m_Serial,aIndex,
                lpItem->m_PetItemLevel,lpItem->m_PetItemExp,lpItem->m_JewelOfHarmonyOption,
                lpItem->m_ItemOptionEx,lpItem->m_SocketOption,lpItem->m_SocketOptionBonus,
                lpItem->m_PeriodicItemTime) == 0)
        {
                DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
                return;
        }
        this->InventoryDelItem(aIndex,lpMsg->slot);
}</code></pre>
        </div>
        <h4>Plano de conversão</h4>
        <ol>
          <li>Expor endpoint <code>POST /drops</code> que recebe ItemID, opções e posição. Aplicar as mesmas validações (Lucky, Periodic, Lock, Bag Manager) antes de autorizar.</li>
          <li>No UE5, criar <code>BP_LootService</code> para enviar a requisição e spawnar <code>BP_ItemPickup</code> apenas após sucesso.</li>
          <li>Reutilizar meshes e partículas originais. Para gemas, reaplicar <code>FX_Drop</code> e as cores herdadas de <code>newui_item_table</code>.</li>
          <li>Manter sincronia: se o servidor negar, tocar som de erro e cancelar o arraste (equivalente ao <code>DataSend</code> com <code>result = 0</code>).</li>
        </ol>
        <pre><code>Function RequestDrop(ItemSlot, GridPos)
  → Build Payload (Slot, GridPos, ItemOptions)
  → HTTP POST /drops
  → OnSuccess:
        Inventory.RemoveSlot(ItemSlot)
        SpawnActor(BP_ItemPickup, GridPos)
  → OnError:
        HUD.ShowMessage("Drop negado: motivo")
        Inventory.RefreshSlot(ItemSlot)</code></pre>
        <div class="callout">
          <strong>Triggers especiais:</strong> Kalima Gate, Mercenary, Life Stone e eventos sazonais têm ramos dedicados no código. Crie tabelas <code>DT_SpecialDrop</code> e trate-as antes da lógica genérica para manter o comportamento original.</div>
      </article>

      <article class="conversion-pane" data-pane="maps">
        <h3>Mapas, Atributos e Respawns</h3>
        <p>O servidor lê os arquivos binários de mapa, armazena atributos e respawns fixos. Esses dados orientam a reconstrução no UE5.</p>
        <div class="source-card">
          <div class="source-meta">Servidor – <code>Source MuServer Update 15/GameServer/GameServer/Map.cpp</code></div>
          <pre><code>void CMap::Load(char* path,int map)
{
        BYTE width, height;
        ReadFile(file,&width,sizeof(width),&BytesRead,0);
        ReadFile(file,&height,sizeof(height),&BytesRead,0);
        this->m_width = width+1;
        this->m_height = height+1;
        int size = this->m_width * this->m_height;
        this->m_MapAttr = (BYTE*)GlobalAlloc(GPTR,size);
        ReadFile(file,this->m_MapAttr,size,&BytesRead,0);
        this->m_path->SetMapDimensions(this->m_width,this->m_height,this->m_MapAttr);
        this->m_MapNumber = map;
}

CMap::CMap()
{
        SetRect(&this->m_MapRespawn[0],130,116,151,137);
        SetRect(&this->m_MapRespawn[1],106,236,112,243);
        SetRect(&this->m_MapRespawn[2],197,35,218,50);
        SetRect(&this->m_MapRespawn[3],174,101,187,125);
}</code></pre>
        </div>
        <h4>Como portar para a UE5</h4>
        <ol>
          <li>Extrair os arquivos de atributos (<code>Map*.att</code>) e meshes (<code>Map*.bmd</code>) do cliente usando a mesma lógica de leitura. Cada byte representa um tile de 4×4 unidades.</li>
          <li>Converter a grade em <code>.csv</code> (X, Y, Attribute) e importar como <code>Data Table</code>. Use Blueprint ou C++ para gerar <code>Landscape</code> e <code>NavModifierVolume</code> conforme o atributo (walkable, noground, safezone).</li>
          <li>Criar <code>BP_MapAttributeVolume</code> que percorre as linhas no <code>BeginPlay</code>, aplicando materiais diferentes e registrando colisões.</li>
          <li>Respawns: transformar os retângulos <code>SetRect</code> em <code>BoxComponent</code> e registrar em <code>BP_GameMode</code> para spawn seguro de jogadores.</li>
          <li>Configurar World Partition subdividindo nos mesmos blocos do cliente (ex.: 256×256 tiles). Reutilizar texturas <code>Data/World</code> e ajustar colisões com base na escala 1 tile = 100 unidades da UE5.</li>
        </ol>
        <pre><code>Event BeginPlay (BP_MapAttributeVolume)
  → ForEach Row (DT_MapAtt)
        → SpawnVolume = AddInstance(Attr == TW_NOGROUND ? NoWalkMaterial : WalkableMaterial)
        → If Attr == TW_SAFEZONE → RegisterRespawnArea(Location, Extent)
        → If Attr == TW_WATER → ApplyWaterPostProcess(Location)</code></pre>
        <div class="callout">
          <strong>Coordenadas originais:</strong> mantenha a escala 1 tile = 100 unidades da UE5 para garantir alinhamento de colisão, alcance de habilidades e posições de NPC.</div>
      </article>

      <article class="conversion-pane" data-pane="effects">
        <h3>Efeitos e Partículas</h3>
        <p>O módulo de efeitos mantém arrays globais e verifica alcance contra personagens antes de aplicar o impacto.</p>
        <div class="source-card">
          <div class="source-meta">Cliente – <code>Source Main 5.2/source/ZzzEffect.cpp</code></div>
          <pre><code>PARTICLE  Particles[MAX_PARTICLES];
OBJECT Effects[MAX_EFFECTS];

bool AddRangeAttack(vec3_t Position, float Range, short PKKey, int DamageKey[], int* piCount, int iMaxKey)
{
        for(int i=0;i<MAX_CHARACTERS_CLIENT;i++)
        {
                CHARACTER *c = &CharactersClient[i];
                OBJECT *o = &c->Object;
                float dx = Position[0]-o->Position[0];
                float dy = Position[1]-o->Position[1];
                float Distance = sqrtf(dx*dx+dy*dy);
                if(o->Live && o->Visible && c!=Hero && !c->Dead && Distance<=Range)
                {
                        DamageKey[(*piCount)++] = c->Key;
                        if(*piCount >= iMaxKey) break;
                }
        }
        return true;
}</code></pre>
        </div>
        <h4>Estratégia Niagara</h4>
        <ol>
          <li>Converter texturas de partículas em <code>Data/Effect</code> para <code>.png</code> ou <code>.tga</code> padrão. Importar como Sprite ou Flipbook no Niagara.</li>
          <li>Criar <code>NS_RangeAttack</code> com inputs <code>Range</code>, <code>Color</code> e <code>DamageKeys</code>. Usar uma <em>Blueprint Function Library</em> para aplicar a mesma checagem de distância e disparar <code>GameplayCue</code>.</li>
          <li>Reaproveitar meshes <code>MODEL_*</code> exportadas para <code>.fbx</code> e usá-las em <code>Niagara Mesh Renderer</code> para raios, lasers e efeitos 3D.</li>
          <li>Centralizar o controle em <code>BP_EffectManager</code>, mantendo <code>Object Pool</code> para partículas similares ao array <code>Particles</code>.</li>
        </ol>
        <pre><code>Function SpawnRangeEffect (Origin, Range, Cue)
  → ActorsInRange = SphereOverlapActors(Range)
  → ForEach Alvo válido
        → ApplyGameplayEffectToTarget(Cue)
  → NiagaraComponent.SetVariableFloat("Range", Range)
  → NiagaraComponent.SetVariableLinearColor("Tint", Cue.Color)
  → NiagaraComponent.Activate()
  → AudioComponent.Play()</code></pre>
        <div class="callout">
          <strong>Feedback sonoro:</strong> mantenha o mapeamento das trilhas listadas em <code>Source Main 5.2/source/DSPlaySound.h</code>. No UE5, utilize <code>MetaSounds</code> com a mesma enumeração para sincronizar áudio e partículas.</div>
      </article>
    </section>

    <section id="verificacoes">
      <h2>Painel de Decisão Rápida</h2>
      <div class="timeline">
        <div class="timeline-step">
          <span class="label">Início</span>
          <strong>Importo todos os assets agora?</strong>
          <p>Somente após classificar como <em>Pronto</em>, <em>Precisa Ajustes</em> ou <em>Substituir</em>. Caso contrário, importe um lote pequeno para validar materiais e colisões.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Depois do HUD</span>
          <strong>Recrio a interface antes dos sistemas?</strong>
          <p>Sim. Com HUD + Inventário prontos, você valida feedback instantâneo e detecta falta de dados herdados.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Progresso</span>
          <strong>XP ou Itens primeiro?</strong>
          <p>Inicie pelos itens. XP depende de recompensas, então garanta que o inventário suporte equipar/consumir para depois ajustar a progressão.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Conteúdo</span>
          <strong>Mapas ou Drops antes?</strong>
          <p>Mapas. Estruture navegação e colisões; em seguida distribua inimigos e configure drops conforme layout final.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Final</span>
          <strong>Efeitos visuais no fim?</strong>
          <p>Sim. Após sistemas estáveis, aplique Niagara, som e pós-processo com base no gameplay consolidado.</p>
        </div>
      </div>
      <div class="callout" style="margin-top: 1.75rem;">
        <strong>Dica:</strong> Revise o painel após cada etapa. Se houver bloqueio por falta de asset convertido, mova temporariamente para um placeholder marcado com <em>debug material</em> e siga com a lógica.
      </div>
    </section>

    <section id="cronograma">
      <h2>Cronograma Sugerido (12 Semanas)</h2>
      <div class="timeline">
        <div class="timeline-step">
          <span class="label">Semanas 1–2</span>
          <strong>Auditoria &amp; Setup</strong>
          <ul>
            <li>Converter lote piloto de assets e validar materiais.</li>
            <li>Configurar controle de versão e documentação.</li>
            <li>Definir curvas de XP, lista de itens e mapas prioritários.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 3–5</span>
          <strong>HUD, Inventário e Dados</strong>
          <ul>
            <li>Recriar HUD completo e fluxo de inventário.</li>
            <li>Integrar dados de itens e efeitos básicos.</li>
            <li>Testar persistência e replicação (se multiplayer).</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 6–8</span>
          <strong>Progressão &amp; Loot</strong>
          <ul>
            <li>Implementar XP, níveis, habilidades destraváveis.</li>
            <li>Configurar drops por região e chefes.</li>
            <li>Balancear economia e recompensas.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 9–10</span>
          <strong>Mapas e Conteúdo</strong>
          <ul>
            <li>Migrar mapas restantes com colisão e navegação.</li>
            <li>Adicionar eventos, missões e spawners.</li>
            <li>Testes de performance e correções estruturais.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 11–12</span>
          <strong>Polimento Final</strong>
          <ul>
            <li>Atualizar VFX, trilhas e voice overs.</li>
            <li>QA completo, bug bash e checklist de build.</li>
            <li>Preparar material de entrega e documentação final.</li>
          </ul>
        </div>
      </div>
    </section>
  </main>
  <footer>
    Atualize este guia conforme novas descobertas na migração. Marque o progresso no checklist e use os exemplos de Blueprint como base para acelerar as próximas etapas.
  </footer>
  <script>
    const stageContent = {
      default: {
        titulo: "Ordem ideal sugerida",
        passos: [
          "Finalize auditoria e importação de um lote piloto de assets.",
          "Protótipo completo de HUD + inventário utilizando dados originais.",
          "Implemente itens, XP e drops com Data Tables reaproveitadas.",
          "Migre mapas, spawners e triggers para UE5 com World Partition.",
          "Ajuste efeitos, áudio e iluminação, encerrando com testes finais."
        ]
      },
      asset: {
        titulo: "Quando há muitos assets convertidos",
        passos: [
          "Priorize planilha de estado dos assets e importe somente os aprovados.",
          "Crie um mapa de revisão (Asset Playground) para testar materiais/LODs.",
          "Depois conecte HUD + inventário usando os ícones e meshes já convertidos.",
          "Mantenha assets incompletos marcados como placeholders até a Etapa 4."
        ]
      },
      ui: {
        titulo: "Foco em interface",
        passos: [
          "Migre fontes, ícones e animações UI para UMG.",
          "Implemente HUD modular usando Common UI e reutilizando widgets originais.",
          "Conecte inventário e barras de status aos dados herdados.",
          "Só avance para XP/drops quando HUD responder a todos eventos principais."
        ]
      },
      core: {
        titulo: "Foco em sistemas centrais",
        passos: [
          "Garanta que Data Tables de itens, XP e drops estejam convertidas.",
          "Crie componentes Blueprints (Inventory, Progression, LootSpawner).",
          "Monte mapa de combate de teste para balancear valores reutilizados.",
          "Integre com HUD existente antes de distribuir para mapas completos."
        ]
      },
      maps: {
        titulo: "Entrega rápida de mapas",
        passos: [
          "Importe blocos estruturais (terreno, malhas principais) primeiro.",
          "Configure World Partition e volumes de navegação.",
          "Reaplique iluminação/pós-processo original e valide colisões.",
          "Após mapas estáveis, posicione inimigos e conecte drops e eventos."
        ]
      },
      vfx: {
        titulo: "Foco em efeitos e audiovisual",
        passos: [
          "Organize texturas de partículas e sons legados em pastas Niagara/Audio.",
          "Atualize efeitos críticos (habilidades, feedback de dano) usando Niagara.",
          "Integre MetaSounds para música adaptativa com dados reutilizados.",
          "Finalize com pós-processo e passes de iluminação após mapas prontos."
        ]
      }
    };

    const select = document.getElementById("perfil");
    const output = document.getElementById("saidaPlano");
    document.getElementById("verPlano").addEventListener("click", () => {
      const escolha = stageContent[select.value] || stageContent.default;
      output.innerHTML = `<strong>${escolha.titulo}</strong><ol style="margin-top:0.85rem;">${escolha.passos
        .map((passo) => `<li>${passo}</li>`)
        .join("")}</ol>`;
    });

    const atlasTabs = document.querySelectorAll(".atlas-tab");
    const atlasContents = document.querySelectorAll(".atlas-content");
    atlasTabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        const alvo = tab.dataset.tab;
        atlasTabs.forEach((t) => t.classList.toggle("active", t === tab));
        atlasContents.forEach((content) => {
          content.classList.toggle("active", content.dataset.tab === alvo);
        });
      });
    });

    const conversionButtons = document.querySelectorAll(".conversion-button");
    const conversionPanes = document.querySelectorAll(".conversion-pane");
    conversionButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const target = button.dataset.pane;
        conversionButtons.forEach((b) => b.classList.toggle("active", b === button));
        conversionPanes.forEach((pane) => {
          pane.classList.toggle("active", pane.dataset.pane === target);
        });
      });
    });
  </script>
</body>
</html>
