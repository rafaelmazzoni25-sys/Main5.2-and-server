<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Plano Direcionado para Recriação do Projeto na Unreal Engine 5</title>
  <style>
    :root {
      color-scheme: light;
      --azul-escuro: #123a63;
      --azul: #0c8dd9;
      --azul-claro: #ecf4ff;
      --cinza: #455a74;
      --verde: #35a07e;
      --amarelo: #f6b73c;
      --vermelho: #d9534f;
      --fundo: #f3f6fb;
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.65;
      margin: 0;
      background: var(--fundo);
      color: #1f2a3a;
    }
    header {
      background: linear-gradient(135deg, var(--azul-escuro), var(--azul));
      color: #fff;
      padding: 3rem 1.5rem 2.5rem;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    header::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at top right, rgba(255, 255, 255, 0.28), transparent 55%);
    }
    header h1 {
      margin: 0 auto 0.75rem;
      max-width: 720px;
      font-size: clamp(2.25rem, 2.7vw + 1.1rem, 3.25rem);
    }
    header p {
      margin: 0 auto;
      max-width: 720px;
      font-size: 1.05rem;
      opacity: 0.95;
    }
    main {
      max-width: 1160px;
      margin: -2.75rem auto 4rem;
      padding: 0 1.5rem 4rem;
    }
    section {
      background: #fff;
      margin: 2rem 0;
      padding: 2.5rem 2.25rem;
      border-radius: 20px;
      box-shadow: 0 26px 60px rgba(18, 58, 99, 0.12);
      position: relative;
      overflow: hidden;
    }
    section::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(145deg, rgba(12, 141, 217, 0.05), transparent 60%);
      pointer-events: none;
    }
    h2 {
      margin: 0 0 1.75rem;
      padding-left: 0.85rem;
      border-left: 5px solid var(--azul);
      color: var(--azul-escuro);
      font-size: 1.75rem;
    }
    h3 {
      margin-top: 1.75rem;
      color: var(--cinza);
      font-size: 1.25rem;
    }
    p {
      margin: 0 0 1rem;
    }
    ol, ul {
      margin: 0 0 1.35rem 1.25rem;
    }
    li {
      margin-bottom: 0.45rem;
    }
    strong.badge {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      font-size: 0.85rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      background: rgba(12, 141, 217, 0.14);
      color: var(--azul-escuro);
      border-radius: 999px;
      padding: 0.35rem 0.9rem;
    }
    .grid-3 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.25rem;
      margin-top: 1.5rem;
    }
    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-top: 1.5rem;
    }
    .assurance-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-top: 1.75rem;
    }
    .assurance-card {
      background: #fafdff;
      border: 1px solid #d6e6f9;
      border-radius: 16px;
      padding: 1.35rem 1.25rem;
      display: grid;
      gap: 0.75rem;
    }
    .assurance-card h3 {
      margin: 0;
      font-size: 1.2rem;
      color: var(--azul-escuro);
    }
    .coverage-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-top: 1.75rem;
    }
    .coverage-card {
      background: #fafdff;
      border: 1px solid #d6e6f9;
      border-radius: 16px;
      padding: 1.35rem 1.25rem;
      display: grid;
      gap: 0.75rem;
    }
    .coverage-card h3 {
      margin: 0;
      font-size: 1.2rem;
      color: var(--azul-escuro);
    }
    .coverage-card ul {
      margin: 0 0 0 1.1rem;
    }
    .layout {
      display: grid;
      grid-template-columns: 280px minmax(0, 1fr);
      gap: 2.25rem;
      align-items: flex-start;
    }
    .navigator {
      background: #ffffff;
      border-radius: 18px;
      box-shadow: 0 18px 48px rgba(18, 58, 99, 0.12);
      padding: 1.75rem 1.4rem;
      position: sticky;
      top: 1.75rem;
      display: grid;
      gap: 1.35rem;
      border: 1px solid rgba(12, 141, 217, 0.12);
    }
    .navigator h2 {
      margin: 0;
      font-size: 1.25rem;
      color: var(--azul-escuro);
    }
    .nav-description {
      font-size: 0.95rem;
      color: #425168;
      margin: 0;
    }
    .nav-group {
      border-top: 1px solid rgba(18, 58, 99, 0.08);
      padding-top: 1rem;
      display: grid;
      gap: 0.65rem;
    }
    .nav-group:first-of-type {
      border-top: none;
      padding-top: 0;
    }
    .nav-phase {
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--cinza);
      font-weight: 700;
    }
    .navigator ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 0.45rem;
    }
    .navigator li {
      margin: 0;
    }
    .navigator a {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      font-size: 0.96rem;
      color: #1f2a3a;
      text-decoration: none;
      padding: 0.35rem 0.45rem;
      border-radius: 10px;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .navigator a::before {
      content: "";
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(12, 141, 217, 0.35);
      display: inline-block;
    }
    .navigator a:hover,
    .navigator a:focus {
      background: rgba(12, 141, 217, 0.12);
      color: var(--azul-escuro);
    }
    .content-flow {
      display: grid;
      gap: 2rem;
    }
    .journey-map {
      margin: 2.5rem 0 1rem;
      display: grid;
      gap: 1.2rem;
    }
    .journey-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1rem;
    }
    .journey-card {
      background: rgba(12, 141, 217, 0.06);
      border-radius: 14px;
      padding: 1.1rem 1rem 1.2rem;
      border: 1px solid rgba(12, 141, 217, 0.16);
      display: grid;
      gap: 0.55rem;
    }
    .journey-card strong {
      color: var(--azul-escuro);
      font-size: 0.95rem;
    }
    .journey-card ul {
      margin: 0;
      padding-left: 1rem;
      font-size: 0.9rem;
    }
    .journey-card a {
      color: var(--azul);
      text-decoration: none;
      font-weight: 600;
    }
    .journey-card a:hover,
    .journey-card a:focus {
      text-decoration: underline;
    }
    .status-flag {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.78rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      background: rgba(53, 160, 126, 0.14);
      color: var(--verde);
      border-radius: 999px;
      padding: 0.25rem 0.75rem;
    }
    .matrix {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      background: rgba(12, 141, 217, 0.04);
      border-radius: 16px;
      overflow: hidden;
    }
    .matrix thead {
      background: rgba(12, 141, 217, 0.18);
    }
    .matrix th,
    .matrix td {
      padding: 0.95rem 1rem;
      text-align: left;
      border-bottom: 1px solid rgba(18, 58, 99, 0.12);
      vertical-align: top;
    }
    .matrix tbody tr:last-child td {
      border-bottom: none;
    }
    .matrix strong {
      color: var(--azul-escuro);
    }
    .badge-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.28rem 0.65rem;
      font-size: 0.75rem;
      background: rgba(53, 160, 126, 0.16);
      border-radius: 999px;
      color: var(--verde);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .callout {
      background: rgba(246, 183, 60, 0.16);
      border-left: 4px solid var(--amarelo);
      padding: 1rem 1.25rem;
      border-radius: 12px;
      margin: 1.35rem 0;
    }
    .callout strong {
      color: var(--azul-escuro);
    }
    details.guia {
      background: rgba(12, 141, 217, 0.06);
      border-radius: 14px;
      padding: 1.1rem 1.25rem;
      margin: 1rem 0;
      border: 1px solid rgba(12, 141, 217, 0.12);
      transition: box-shadow 0.3s ease;
    }
    details.guia[open] {
      box-shadow: 0 18px 40px rgba(18, 58, 99, 0.14);
    }
    details.guia summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--azul-escuro);
      list-style: none;
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }
    details.guia summary::before {
      content: "⮟";
      font-size: 1rem;
      transition: transform 0.3s ease;
    }
    details.guia[open] summary::before {
      transform: rotate(-180deg);
    }
    .blueprint-flow {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1rem;
      margin-top: 1.1rem;
    }
    .blueprint-step {
      background: #fff;
      border-radius: 14px;
      border: 1px solid rgba(18, 58, 99, 0.12);
      padding: 1rem 1.15rem;
      box-shadow: 0 12px 32px rgba(18, 58, 99, 0.08);
    }
    .blueprint-step h4 {
      margin: 0 0 0.6rem;
      color: var(--azul-escuro);
      font-size: 1.05rem;
    }
    .code-card {
      background: #0b1f33;
      color: #e8f1ff;
      border-radius: 12px;
      padding: 1rem 1.1rem;
      margin: 1rem 0;
      font-family: "Fira Code", "Consolas", "Courier New", monospace;
      font-size: 0.87rem;
      line-height: 1.5;
      overflow-x: auto;
    }
    .swimlane {
      display: grid;
      grid-template-columns: 160px 1fr;
      gap: 1rem;
      margin: 1.5rem 0;
    }
    .swimlane strong {
      display: block;
      color: var(--azul-escuro);
      margin-bottom: 0.5rem;
    }
    .swimlane ul {
      margin: 0;
      padding-left: 1.1rem;
    }
    .checklist {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0.85rem;
      margin-top: 1.35rem;
    }
    .checklist li {
      list-style: none;
      padding: 0.75rem 0.85rem;
      border-radius: 10px;
      background: rgba(18, 58, 99, 0.06);
      border: 1px solid rgba(18, 58, 99, 0.12);
      display: flex;
      align-items: flex-start;
      gap: 0.55rem;
    }
    .checklist li::before {
      content: "✔";
      color: var(--verde);
      font-weight: 700;
    }
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      font-size: 0.85rem;
      margin: 1rem 0 0.3rem;
    }
    .legend span {
      background: rgba(12, 141, 217, 0.12);
      color: var(--azul-escuro);
      padding: 0.35rem 0.7rem;
      border-radius: 999px;
    }
    .atlas-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin: 1.75rem 0 1.5rem;
    }
    .atlas-tab {
      background: rgba(12, 141, 217, 0.14);
      border: 1px solid rgba(12, 141, 217, 0.35);
      color: var(--azul-escuro);
      border-radius: 999px;
      padding: 0.55rem 1.25rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .atlas-tab.active {
      background: linear-gradient(135deg, var(--azul), #0b6ac1);
      color: #fff;
      box-shadow: 0 12px 24px rgba(12, 141, 217, 0.25);
    }
    .atlas-tab:hover {
      transform: translateY(-2px);
    }
    .atlas-content {
      display: none;
      border-radius: 16px;
      border: 1px solid #d7e5f7;
      background: #fafdff;
      padding: 1.75rem 1.5rem;
      gap: 1.35rem;
    }
    .atlas-content.active {
      display: grid;
    }
    .atlas-content h3 {
      margin-top: 0;
      color: var(--azul-escuro);
    }
    .atlas-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1.15rem;
      font-size: 0.95rem;
    }
    pre {
      background: #0f1e2f;
      color: #d7f5ff;
      padding: 1rem 1.25rem;
      border-radius: 14px;
      overflow-x: auto;
      font-size: 0.92rem;
      line-height: 1.5;
      box-shadow: inset 0 0 0 1px rgba(12, 141, 217, 0.15);
    }
    pre code {
      white-space: pre;
    }
    .conversion-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin: 2rem 0 1.25rem;
    }
    .conversion-button {
      border: 1px solid rgba(12, 141, 217, 0.3);
      background: rgba(12, 141, 217, 0.08);
      color: var(--azul-escuro);
      border-radius: 999px;
      padding: 0.55rem 1.35rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .conversion-button.active {
      background: linear-gradient(135deg, var(--azul), #0b6ac1);
      color: #fff;
      box-shadow: 0 14px 32px rgba(12, 141, 217, 0.28);
      transform: translateY(-1px);
    }
    .conversion-pane {
      display: none;
      border: 1px solid #d6e4f6;
      border-radius: 18px;
      background: #fbfeff;
      padding: 2rem 1.75rem;
      margin-bottom: 1.75rem;
      box-shadow: 0 20px 45px rgba(18, 58, 99, 0.09);
    }
    .conversion-pane.active {
      display: block;
    }
    .conversion-pane h3 {
      margin-top: 0;
      color: var(--azul-escuro);
    }
    .source-card {
      background: rgba(236, 244, 255, 0.65);
      border: 1px solid rgba(12, 141, 217, 0.18);
      border-radius: 16px;
      padding: 1.25rem 1.35rem 1.5rem;
      margin: 1.25rem 0 1.75rem;
      box-shadow: 0 14px 38px rgba(12, 141, 217, 0.12);
    }
    .source-card .source-meta {
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      color: var(--cinza);
      margin-bottom: 0.75rem;
    }
    .layout-map {
      width: 100%;
      max-width: 720px;
      margin: 1.75rem auto;
      display: block;
      border-radius: 12px;
      box-shadow: 0 10px 28px rgba(12, 141, 217, 0.15);
    }
    .layout-map text {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      font-size: 14px;
      fill: #0b2d4a;
      font-weight: 600;
    }
    .layout-map rect {
      fill: rgba(12, 141, 217, 0.18);
      stroke: rgba(12, 141, 217, 0.65);
      stroke-width: 1.5;
    }
    .layout-map rect.asset {
      fill: rgba(53, 160, 126, 0.22);
      stroke: rgba(53, 160, 126, 0.7);
    }
    .conversion-pane ol {
      margin-left: 1.35rem;
    }
    .conversion-pane li {
      margin-bottom: 0.65rem;
    }
    .atlas-table thead {
      background: rgba(12, 141, 217, 0.12);
    }
    .atlas-table th,
    .atlas-table td {
      padding: 0.75rem 0.85rem;
      text-align: left;
      border-bottom: 1px solid #dfe9f7;
      vertical-align: top;
    }
    .atlas-table th {
      color: var(--azul-escuro);
      font-weight: 700;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .atlas-table code {
      background: rgba(12, 141, 217, 0.08);
      color: var(--azul-escuro);
      padding: 0.15rem 0.35rem;
      border-radius: 6px;
      font-size: 0.85rem;
    }
    .atlas-grid {
      display: grid;
      gap: 1.1rem;
    }
    .atlas-highlight {
      border-left: 5px solid var(--azul);
      background: rgba(12, 141, 217, 0.08);
      padding: 1rem 1.15rem;
      border-radius: 12px;
    }
    .atlas-list {
      display: grid;
      gap: 0.55rem;
      margin: 0;
      padding-left: 1.15rem;
    }
    .module-matrix {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1.35rem;
      margin: 2rem 0 1rem;
    }
    .module-category {
      background: rgba(12, 141, 217, 0.06);
      border: 1px solid rgba(12, 141, 217, 0.18);
      border-radius: 16px;
      padding: 1.4rem 1.35rem 1.5rem;
      box-shadow: 0 16px 34px rgba(12, 141, 217, 0.12);
    }
    .module-category h3 {
      margin: 0 0 0.75rem;
      color: var(--azul-escuro);
      font-size: 1.2rem;
    }
    .module-list {
      margin: 0;
      padding-left: 1rem;
      display: grid;
      gap: 0.65rem;
      font-size: 0.95rem;
    }
    .module-list li {
      margin: 0;
    }
    .module-list code {
      background: rgba(18, 58, 99, 0.08);
      border-radius: 6px;
      padding: 0.12rem 0.35rem;
      font-size: 0.85rem;
      color: var(--azul-escuro);
    }
    details.catalog-group {
      border: 1px solid rgba(12, 141, 217, 0.22);
      border-radius: 18px;
      padding: 1.15rem 1.35rem 1.35rem;
      margin: 1.5rem 0;
      background: rgba(12, 141, 217, 0.06);
      box-shadow: 0 18px 42px rgba(18, 58, 99, 0.12);
    }
    details.catalog-group summary {
      font-weight: 700;
      color: var(--azul-escuro);
      font-size: 1.1rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.55rem;
      list-style: none;
    }
    details.catalog-group summary::-webkit-details-marker {
      display: none;
    }
    details.catalog-group summary::before {
      content: "\25B6";
      font-size: 0.85rem;
      transition: transform 0.2s ease;
    }
    details.catalog-group[open] summary::before {
      transform: rotate(90deg);
    }
    details.catalog-group > p {
      margin-top: 0.85rem;
      margin-bottom: 0.85rem;
    }
    .catalog-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.2rem;
      margin-top: 1.25rem;
    }
    .catalog-card {
      background: #ffffff;
      border-radius: 16px;
      border: 1px solid rgba(18, 58, 99, 0.14);
      padding: 1.25rem 1.3rem 1.35rem;
      box-shadow: 0 16px 36px rgba(12, 141, 217, 0.15);
      position: relative;
      display: grid;
      gap: 0.55rem;
    }
    .catalog-card h4 {
      margin: 0;
      font-size: 1.08rem;
      color: var(--azul-escuro);
    }
    .catalog-card .path {
      font-size: 0.9rem;
      color: var(--cinza);
      margin-bottom: 0.2rem;
    }
    .catalog-card .path code {
      background: rgba(12, 141, 217, 0.12);
      padding: 0.12rem 0.4rem;
      border-radius: 6px;
      font-size: 0.82rem;
    }
    .catalog-card strong {
      color: var(--azul-escuro);
    }
    .step-list {
      margin: 0.65rem 0 0.85rem 1.15rem;
      display: grid;
      gap: 0.4rem;
      font-size: 0.95rem;
    }
    .step-list li {
      margin: 0;
    }
    .dependency {
      font-size: 0.9rem;
      color: var(--cinza);
    }
    .directory-map {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1.75rem;
      font-size: 0.95rem;
      background: #fff;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 18px 44px rgba(18, 58, 99, 0.1);
    }
    .directory-map th,
    .directory-map td {
      padding: 0.9rem 1rem;
      border-bottom: 1px solid rgba(12, 141, 217, 0.12);
      text-align: left;
    }
    .directory-map th {
      background: rgba(12, 141, 217, 0.15);
      text-transform: uppercase;
      font-size: 0.85rem;
      letter-spacing: 0.05em;
    }
    .directory-map code {
      background: rgba(12, 141, 217, 0.12);
      padding: 0.12rem 0.35rem;
      border-radius: 6px;
      font-size: 0.85rem;
    }
    .card {
      border-radius: 16px;
      border: 1px solid #d7e5f7;
      background: #fafdff;
      padding: 1.4rem 1.3rem 1.15rem;
      position: relative;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 18px 40px rgba(12, 141, 217, 0.18);
    }
    .card h3 {
      margin-top: 0;
      font-size: 1.2rem;
    }
    .checklist {
      display: grid;
      gap: 0.85rem;
      margin-top: 1.5rem;
    }
    .checklist label {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.75rem;
      align-items: start;
      padding: 1rem 1rem 1rem 1.25rem;
      border-radius: 12px;
      background: #f7fbff;
      border: 1px solid #dce9f9;
    }
    .checklist input[type="checkbox"] {
      width: 1.15rem;
      height: 1.15rem;
      margin-top: 0.35rem;
    }
    .interactive-panel {
      background: var(--azul-escuro);
      color: #fff;
      border-radius: 18px;
      padding: 1.75rem;
      display: grid;
      gap: 1rem;
      position: relative;
      overflow: hidden;
    }
    .interactive-panel::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.22), transparent 58%);
      pointer-events: none;
    }
    .interactive-panel label {
      font-weight: 600;
    }
    .interactive-panel select,
    .interactive-panel button {
      border-radius: 10px;
      border: none;
      padding: 0.7rem 0.85rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .interactive-panel select {
      background: #fff;
      color: var(--azul-escuro);
    }
    .interactive-panel button {
      background: linear-gradient(135deg, var(--azul), #0b6ac1);
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s ease, filter 0.2s ease;
    }
    .interactive-panel button:hover {
      transform: translateY(-1px);
      filter: brightness(1.06);
    }
    .interactive-output {
      background: rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      padding: 1.35rem;
      line-height: 1.55;
      font-size: 0.98rem;
    }
    details {
      background: #f7fbff;
      border-radius: 14px;
      border: 1px solid #d9e7f8;
      margin-top: 1.25rem;
      padding: 1rem 1.25rem 1.15rem;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--azul-escuro);
    }
    details pre {
      background: #0b2038;
      color: #d9e9ff;
      padding: 1.1rem 1.25rem;
      border-radius: 12px;
      overflow-x: auto;
      margin-top: 1rem;
      font-size: 0.92rem;
      line-height: 1.45;
    }
    .timeline {
      display: grid;
      gap: 1.25rem;
    }
    .timeline-step {
      background: #fafdff;
      border: 1px solid #d6e6f9;
      border-radius: 14px;
      padding: 1.35rem 1.2rem 1.25rem;
      display: grid;
      gap: 0.75rem;
      position: relative;
    }
    .timeline-step strong {
      color: var(--azul-escuro);
    }
    .timeline-step .label {
      position: absolute;
      top: -12px;
      right: 16px;
      background: var(--amarelo);
      color: #fff;
      font-weight: 700;
      border-radius: 999px;
      padding: 0.25rem 0.75rem;
      letter-spacing: 0.02em;
    }
    .callout {
      border-left: 5px solid var(--verde);
      background: #f0f9f4;
      padding: 1.1rem 1.35rem;
      border-radius: 12px;
      margin-top: 1.5rem;
    }
    .warning {
      border-left-color: var(--vermelho);
      background: #fff1f1;
    }
    footer {
      text-align: center;
      padding: 2rem 1rem 4rem;
      color: #60718b;
      font-size: 0.95rem;
    }
    @media (max-width: 1180px) {
      .layout {
        grid-template-columns: 1fr;
      }
      .navigator {
        position: static;
        order: -1;
      }
    }
    @media (max-width: 720px) {
      section {
        padding: 2.1rem 1.6rem;
      }
      .interactive-panel {
        padding: 1.3rem 1.2rem;
      }
      .navigator {
        padding: 1.25rem 1rem;
      }
      .journey-row {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Guia de Recriação Total do Projeto na Unreal Engine 5</h1>
    <p>
      Este documento interativo indica a ordem ideal para reconstruir o projeto na UE5 reaproveitando assets originais.
      Cada etapa traz instruções práticas, checklist de prontidão, exemplos em Blueprint e pontos de verificação antes de avançar.
    </p>
  </header>
  <main>
    <div class="layout">
      <aside class="navigator" id="navigator">
        <div>
          <h2>Mapa de Navegação</h2>
          <p class="nav-description">
            Avance pelas fases na ordem sugerida e abra as seções principais com um clique. Use este painel como guia rápido
            para alternar entre frontend, backend e conteúdo avançado.
          </p>
        </div>
        <div class="nav-group">
          <span class="nav-phase">Fase 0 · Kick-off</span>
          <ul>
            <li><a href="#resumo">Sequência recomendada</a></li>
            <li><a href="#roadmap-integrado">Linha do tempo integrada</a></li>
            <li><a href="#cronograma">Cronograma de 16 semanas</a></li>
          </ul>
        </div>
        <div class="nav-group">
          <span class="nav-phase">Fase 1 · Mapeamento legado</span>
          <ul>
            <li><a href="#atlas">Atlas completo</a></li>
            <li><a href="#paridade">Verificação de paridade</a></li>
            <li><a href="#codigo-main-muserver">Estudo das fontes</a></li>
            <li><a href="#catalogo-modulos">Catálogo de módulos</a></li>
          </ul>
        </div>
        <div class="nav-group">
          <span class="nav-phase">Fase 2 · Fundamentos jogáveis</span>
          <ul>
            <li><a href="#etapas">Etapas de reconstrução</a></li>
            <li><a href="#guias-frontend">Interfaces &amp; HUD</a></li>
            <li><a href="#item-system-encyclopedia">Sistema de itens</a></li>
            <li><a href="#mob-system-atlas">Sistemas de mobs</a></li>
            <li><a href="#skill-system-guide">Sistemas de skills</a></li>
            <li><a href="#blueprints">Blueprints essenciais</a></li>
          </ul>
        </div>
        <div class="nav-group">
          <span class="nav-phase">Fase 3 · Integração técnica</span>
          <ul>
            <li><a href="#frontend-backend">Gateway UE5 ⇄ Serviços</a></li>
            <li><a href="#backend">Serviços modernos</a></li>
            <li><a href="#codigo-detalhado">Código legado detalhado</a></li>
            <li><a href="#modulos-expandido">Matriz de módulos</a></li>
          </ul>
        </div>
        <div class="nav-group">
          <span class="nav-phase">Fase 4 · Conteúdo avançado</span>
          <ul>
            <li><a href="#social-guildas">Social, guildas &amp; gens</a></li>
            <li><a href="#economia-lojas">Economia e lojas</a></li>
            <li><a href="#eventos-liveops">Eventos &amp; live ops</a></li>
            <li><a href="#crafting-refino">Crafting e reforço</a></li>
            <li><a href="#montarias-pets">Montarias e pets</a></li>
            <li><a href="#missoes_eventos">Missões &amp; rankings</a></li>
            <li><a href="#pvp-arenas">PvP, arenas e guerras</a></li>
            <li><a href="#operacoes_avancadas">Operações avançadas</a></li>
            <li><a href="#comandos-seguranca">Comandos e segurança</a></li>
          </ul>
        </div>
        <div class="nav-group">
          <span class="nav-phase">Fase 5 · Garantia &amp; operação</span>
          <ul>
            <li><a href="#cobertura-total">Cobertura Front + Back</a></li>
            <li><a href="#garantia-funcionamento">Garantia UE5</a></li>
            <li><a href="#verificacoes">Checklist de validação</a></li>
            <li><a href="#qa-operacoes">QA &amp; operações</a></li>
          </ul>
        </div>
      </aside>
      <div class="content-flow">
        <section id="resumo">
      <h2>Sequência Recomendada de Implementação</h2>
      <p>
        Foque em <strong>importação controlada dos assets</strong>, seguido de uma <strong>base funcional de interface e inventário</strong>,
        antes de expandir para sistemas de progressão, drops, mapas e efeitos. Esta ordem reduz retrabalho e mantém o jogo jogável rapidamente.
      </p>
      <div class="interactive-panel">
        <div>
          <label for="perfil">Selecione seu foco atual:</label>
          <select id="perfil">
            <option value="default">Quero seguir a ordem ideal sugerida</option>
            <option value="asset">Tenho muitos assets convertidos e quero validar se posso usá-los</option>
            <option value="ui">Preciso reconstruir a interface o quanto antes</option>
            <option value="core">Quero priorizar sistemas centrais (itens, XP, drops)</option>
            <option value="maps">Preciso entregar mapas jogáveis rápido</option>
            <option value="vfx">Necessito atualizar efeitos e feedback audiovisual</option>
          </select>
        </div>
        <button type="button" id="verPlano">Ver ordem sugerida</button>
        <div class="interactive-output" id="saidaPlano">
          Selecione um foco e clique em <strong>Ver ordem sugerida</strong> para receber um roteiro imediato.
        </div>
      </div>
      <div class="journey-map">
        <div class="journey-row">
          <div class="journey-card">
            <strong>Fase 0 · Kick-off</strong>
            <ul>
              <li><a href="#resumo">Checklist inicial</a></li>
              <li><a href="#roadmap-integrado">Roadmap integrado</a></li>
              <li><a href="#cronograma">Cronograma detalhado</a></li>
            </ul>
          </div>
          <div class="journey-card">
            <strong>Fase 1 · Mapeamento</strong>
            <ul>
              <li><a href="#atlas">Atlas do cliente e servidor</a></li>
              <li><a href="#paridade">Tabela de paridade</a></li>
              <li><a href="#codigo-main-muserver">Referências de código</a></li>
            </ul>
          </div>
          <div class="journey-card">
            <strong>Fase 2 · Fundamentos jogáveis</strong>
            <ul>
              <li><a href="#etapas">Ordem das etapas</a></li>
              <li><a href="#item-system-encyclopedia">Itens &amp; inventário</a></li>
              <li><a href="#mob-system-atlas">Mobs e progressão</a></li>
            </ul>
          </div>
        </div>
        <div class="journey-row">
          <div class="journey-card">
            <strong>Fase 3 · Integração técnica</strong>
            <ul>
              <li><a href="#frontend-backend">Gateway cliente ⇄ servidor</a></li>
              <li><a href="#backend">Serviços modernos</a></li>
              <li><a href="#codigo-detalhado">Protocolos e pacotes</a></li>
            </ul>
          </div>
          <div class="journey-card">
            <strong>Fase 4 · Conteúdo avançado</strong>
            <ul>
              <li><a href="#social-guildas">Social e guildas</a></li>
              <li><a href="#economia-lojas">Economia &amp; lojas</a></li>
              <li><a href="#pvp-arenas">PvP e eventos especiais</a></li>
            </ul>
          </div>
          <div class="journey-card">
            <strong>Fase 5 · Garantia &amp; operações</strong>
            <ul>
              <li><a href="#garantia-funcionamento">Matriz de testes</a></li>
              <li><a href="#verificacoes">Checklists finais</a></li>
              <li><a href="#qa-operacoes">Telemetria e suporte</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="grid-3" style="margin-top: 2rem;">
        <div class="card">
          <h3><span class="badge">1º</span> Fase de Validação</h3>
          <ul>
            <li>Auditoria de assets originais e conversão para UE5.</li>
            <li>Configuração de projeto, plugins e convenções.</li>
            <li>Protótipo básico de HUD + inventário navegável.</li>
          </ul>
        </div>
        <div class="card">
          <h3><span class="badge">2º</span> Fase Sistêmica</h3>
          <ul>
            <li>Recriação de itens, XP e drops com dados reaproveitados.</li>
            <li>Estruturação de mapas com spawners, colisões e navegação.</li>
            <li>Validação de rede/multiplayer (se aplicável).</li>
          </ul>
        </div>
        <div class="card">
          <h3><span class="badge">3º</span> Fase Sensorial</h3>
          <ul>
            <li>Atualização de efeitos visuais, sonoros e UI final.</li>
            <li>Polimento de performance, LODs, iluminação e pós-processo.</li>
            <li>Testes completos, correções finais e empacotamento.</li>
          </ul>
        </div>
      </div>
      <div class="checklist">
        <label>
          <input type="checkbox" />
          <span><strong>Inventariou todos os assets reutilizáveis</strong> (modelos, animações, sons, UI, dados) e marcou os que precisam de retrabalho.</span>
        </label>
        <label>
          <input type="checkbox" />
          <span><strong>Definiu a meta de FPS/plataformas alvo</strong> para orientar decisões de LOD, textura e iluminação.</span>
        </label>
        <label>
          <input type="checkbox" />
          <span><strong>Configurou controle de versão</strong> (Perforce, Git LFS ou similar) e separou branch para migração.</span>
        </label>
      </div>
    </section>

    <section id="atlas">
      <h2>Atlas Completo do Projeto Original</h2>
      <p>
        Utilize este atlas para rastrear onde cada funcionalidade do cliente e do servidor reside no projeto legado.
        Ele indica arquivos, diretórios e binários essenciais para orientar a migração 1:1 para a Unreal Engine 5,
        contemplando tanto o frontend (cliente) quanto o backend (servidores e bancos de dados).
      </p>
      <div class="callout">
        <strong>Mapeamento de diretórios reais:</strong>
        <ul>
          <li>Assets do cliente (texturas, sprites, BMD): <code>Source Main 5.2/bin/Data/&lt;Subpasta&gt;</code>.</li>
          <li>Código do cliente: <code>Source Main 5.2/source</code>; código do servidor: <code>Source MuServer Update 15/GameServer/GameServer</code>.</li>
          <li>Tabelas e scripts de configuração do backend: <code>MuServer_Season_5_Update_15/Data/&lt;Categoria&gt;</code> e <code>MuServer_Season_5_Update_15/ScriptSql</code>.</li>
        </ul>
        <p>Qualquer referência simplificada a <code>Data/...</code> neste guia usa estes caminhos como base para localizar rapidamente os arquivos originais.</p>
      </div>
      <div class="atlas-tabs">
        <button class="atlas-tab active" data-tab="frontend">Cliente (Front-end)</button>
        <button class="atlas-tab" data-tab="backend">Servidor (Back-end)</button>
        <button class="atlas-tab" data-tab="dados">Dados &amp; Scripts Compartilhados</button>
        <button class="atlas-tab" data-tab="pipeline">Integração UE5 (Front + Back)</button>
      </div>

      <div class="atlas-content active" data-tab="frontend">
        <h3>Arquitetura do Cliente Original <small>(pasta <code>Source Main 5.2/source</code>)</small></h3>
        <table class="atlas-table">
          <thead>
            <tr>
              <th>Área</th>
              <th>Arquivos/Diretórios Originais</th>
              <th>Responsabilidade Atual</th>
              <th>Adaptação Recomendada na UE5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Boot &amp; Loop</td>
              <td><code>Winmain.cpp</code>, <code>Winmain.h</code>, <code>Builder.cpp</code></td>
              <td>Cria janela OpenGL, inicializa subsistemas, roda loop de mensagens.</td>
              <td>Recriar fluxo em <code>UGameInstance</code> + <code>AGameModeBase</code>, migrando inicialização para <code>Subsystems</code> e <code>Game Feature Plugins</code>.</td>
            </tr>
            <tr>
              <td>Gestão de UI</td>
              <td><code>UIManager.cpp</code>, <code>NewUIManager.cpp</code>, <code>NewUIMainFrameWindow.cpp</code></td>
              <td>Orquestra HUD legado, troca de janelas e renderização 2D.</td>
              <td>Mapear widgets para <code>UMG</code>/<code>Common UI</code>; criar <code>BP_UIRoot</code> que instancia subwidgets e responde a <code>Gameplay Tags</code>.</td>
            </tr>
            <tr>
              <td>Inventário &amp; Itens</td>
              <td><code>NewUIMyInventory.cpp</code>, <code>ZzzInventory.cpp</code>, <code>ItemManager.cpp</code></td>
              <td>Renderiza slots, valida equipáveis, consulta dados de itens.</td>
              <td>Usar <code>Data Assets</code> e <code>Data Tables</code> em UE5; criar componentes <code>BP_InventoryManager</code> e <code>BP_ItemInstance</code> com replicação opcional.</td>
            </tr>
            <tr>
              <td>Progressão &amp; Personagem</td>
              <td><code>CharacterManager.cpp</code>, <code>QuestMng.cpp</code>, <code>GM3rdChangeUp.cpp</code></td>
              <td>Controla atributos, quests, classes avançadas e desbloqueios.</td>
              <td>Implementar em <code>Actor Components</code> (ex.: <code>BP_ProgressionComponent</code>) e <code>Gameplay Ability System</code> para buffs/skills.</td>
            </tr>
            <tr>
              <td>Mapas &amp; Mundo</td>
              <td><code>MapManager.cpp</code>, <code>w_MapProcess.cpp</code>, diretório <code>Time/</code></td>
              <td>Carrega dados de mapas, portais, horários de eventos e colisões.</td>
              <td>Converter layouts em <code>Level Streaming</code> / <code>World Partition</code>; migrar triggers para <code>Blueprint Actors</code> reutilizando CSVs como <code>Data Tables</code>.</td>
            </tr>
            <tr>
              <td>Efeitos &amp; Renderização</td>
              <td><code>ZzzEffect.cpp</code>, <code>SkillEffectMgr.cpp</code>, <code>GlobalBitmap.cpp</code>, <code>TextureScript.cpp</code></td>
              <td>Gera partículas, animações de habilidades e gerencia texturas legacy.</td>
              <td>Transformar assets em sistemas Niagara/Material Functions; migrar tabelas de efeitos para <code>Curve</code> e <code>Data Assets</code>.</td>
            </tr>
            <tr>
              <td>Rede &amp; Protocolos</td>
              <td><code>ProtocolSend.cpp</code>, <code>SocketSystem.cpp</code>, <code>WSclient.cpp</code></td>
              <td>Empacota mensagens, gerencia sockets TCP, interpreta respostas do servidor.</td>
              <td>Substituir por camadas HTTP/WebSocket/GRPC via <code>FHttpModule</code> ou plugins; definir <code>BP_ServerGateway</code> para traduzir mensagens.</td>
            </tr>
            <tr>
              <td>Localização &amp; Texto</td>
              <td><code>GlobalText.h</code>, <code>MultiLanguage.cpp</code>, <code>Local.cpp</code></td>
              <td>Carrega arquivos de texto, alterna idiomas e strings dinâmicas.</td>
              <td>Importar para <code>Localization Dashboard</code> da UE5; usar <code>FText</code> com <code>String Tables</code> para manter suporte multi-idioma.</td>
            </tr>
            <tr>
              <td>Social (Guildas &amp; Party)</td>
              <td><code>GuildManager.cpp</code>, <code>GuildCache.cpp</code>, <code>PartyManager.cpp</code>, <code>NewUIPartyInfoWindow.cpp</code></td>
              <td>Administra guildas, alianças, convites e visões de grupo no cliente.</td>
              <td>Criar <code>Subsystems</code> dedicados (ex.: <code>UGuildSubsystem</code>) e widgets de guild/party em <code>Common UI</code>, usando replicação via <code>Gameplay Message Router</code>.</td>
            </tr>
            <tr>
              <td>Chat &amp; Mensageria</td>
              <td><code>NewUIChatInputBox.cpp</code>, <code>NewUIChatLogWindow.cpp</code>, <code>MsgWin.cpp</code></td>
              <td>Renderiza canais de chat, histórico e mensagens do servidor.</td>
              <td>Reescrever em Widgets UMG com <code>ListView</code> virtualizada + camada de transporte WebSocket (ou EOS Voice/Text) encapsulada em <code>BP_ChatGateway</code>.</td>
            </tr>
            <tr>
              <td>Eventos PvE/PvP</td>
              <td><code>CSChaosCastle.cpp</code>, <code>NewUIBloodCastleEnter.cpp</code>, <code>GMDoppelGanger1.cpp</code>-<code>4.cpp</code>, <code>NewUISiegeWarBase.cpp</code></td>
              <td>Coordena regras de entrada, UI e feedback dos eventos especiais.</td>
              <td>Utilizar <code>Game Feature Plugins</code> modulares com <code>Gameplay Ability System</code> e <code>Data Assets</code> por evento, habilitando/desabilitando features por temporada.</td>
            </tr>
            <tr>
              <td>Pets &amp; Companheiros</td>
              <td><code>CSPetSystem.cpp</code>, <code>SummonSystem.cpp</code>, diretório <code>w_PetAction*</code></td>
              <td>Gerencia invocação, IA simplificada e ações de mascotes.</td>
              <td>Converter para <code>Actor Components</code> (PetController, PetInventory) com <code>Behavior Trees</code>/<code>EQs</code> e animações reutilizadas dos arquivos originais.</td>
            </tr>
            <tr>
              <td>Comércio &amp; Mercado</td>
              <td><code>NewUITrade.cpp</code>, <code>NewUIUnitedMarketPlaceWindow.cpp</code>, <code>PersonalShopTitleImp.cpp</code>, <code>NewUIMyShopInventory.cpp</code></td>
              <td>Abre troca direta, loja pessoal e mercado global.</td>
              <td>Implementar widgets de negociação com <code>UMG</code>/<code>CommonUI</code> e replicação transacional via backend; usar <code>Data Tables</code> de itens + <code>Gameplay Tags</code> para validar restrições.</td>
            </tr>
            <tr>
              <td>Lançador &amp; Segurança</td>
              <td><code>LauncherHelper.cpp</code>, <code>ProtectSysKey.cpp</code>, <code>GCCertification.cpp</code></td>
              <td>Executa verificações de integridade e rotinas do launcher.</td>
              <td>Substituir por patcher moderno (ex.: EOS Patch Tool) e validações anti-tamper integradas à pipeline de distribuição, expondo status no HUD via <code>Subsystem</code>.</td>
            </tr>
          </tbody>
        </table>
        <div class="atlas-highlight">
          <strong>Checklist Frontend:</strong>
          <ul class="atlas-list">
            <li>Revisar dependências OpenGL/Win32 em <code>Winmain.cpp</code> para substituição por módulos UE5.</li>
            <li>Gerar inventário de widgets <code>NewUI*</code> e mapear cada um para um <em>Widget Blueprint</em> equivalente.</li>
            <li>Converter dados lidos via <code>LoadData.cpp</code> em <code>Data Tables</code> para compartilhar com o backend.</li>
          </ul>
        </div>
      </div>

      <div class="atlas-content" data-tab="backend">
        <h3>Arquitetura dos Servidores <small>(pasta <code>MuServer_Season_5_Update_15</code>)</small></h3>
        <table class="atlas-table">
          <thead>
            <tr>
              <th>Componente</th>
              <th>Localização</th>
              <th>Função</th>
              <th>Pontos para Migração</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>ConnectServer</td>
              <td><code>ConnectServer/</code></td>
              <td>Autenticação inicial, direciona clientes para <em>JoinServer</em>.</td>
              <td>Planeje endpoint REST/WebSocket para handshake; mantenha lista de shards/configuração.</td>
            </tr>
            <tr>
              <td>JoinServer</td>
              <td><code>JoinServer/</code></td>
              <td>Gerencia login de contas, seleção de servidor e fila.</td>
              <td>Converter lógica para serviço de identidade (OAuth/JWT) integrado a banco atual.</td>
            </tr>
            <tr>
              <td>DataServer</td>
              <td><code>DataServer/</code></td>
              <td>Centraliza persistência de personagens, inventário e XP.</td>
              <td>Modelar APIs de persistência (REST/GraphQL) + camada de acesso a dados moderna (ORM ou microserviço).</td>
            </tr>
            <tr>
              <td>GameServer</td>
              <td><code>GameServer/</code> + <code>GameServer/DATA</code></td>
              <td>Executa lógica em tempo real, eventos, drops, skills.</td>
              <td>Planejar reescrita em engine servidor (C++/C#/Go) consumindo mesmas tabelas que UE5; migrar scripts <code>*.dat</code> e <code>.txt</code> para base comum.</td>
            </tr>
            <tr>
              <td>Configurações GameServerInfo</td>
              <td><code>GameServer/DATA/GameServerInfo - *.dat</code></td>
              <td>Parametriza XP, comandos, eventos e limites do servidor em arquivos separados.</td>
              <td>Transformar em serviço de configuração central (ex.: <code>Config Server</code>) com versionamento e deploy contínuo; expor endpoints para leitura pelas Blueprints.</td>
            </tr>
            <tr>
              <td>Eventos &amp; Tabelas de Drop</td>
              <td><code>Data/Event/</code>, <code>Data/EventItemBag/</code>, <code>Data/Custom/Event</code></td>
              <td>Define horários de eventos, bosses e lotes de recompensas (bags).</td>
              <td>Converter para <code>Data Tables</code>/<code>JSON</code> versionado e serviços de loot; integrar validação automática com o sistema de mobs e itens na UE5.</td>
            </tr>
            <tr>
              <td>Economia &amp; Cash Shop</td>
              <td><code>Data/CashShop/</code>, <code>Data/Item/</code>, <code>CashShop/</code></td>
              <td>Gerencia catálogo da loja, pacotes e valores de moeda premium.</td>
              <td>Criar microserviço de vitrine/checkout; sincronizar ícones/descrições com Widgets UE5 usando a mesma fonte de dados.</td>
            </tr>
            <tr>
              <td>Orquestração de StartUp</td>
              <td><code>StartUp/</code></td>
              <td>Scripts/batch que iniciam todos os executáveis na ordem correta.</td>
              <td>Documentar dependências e substituir por orquestração automatizada (Docker Compose, Kubernetes, CI/CD) com health-checks expostos ao cliente.</td>
            </tr>
            <tr>
              <td>GameServerCS</td>
              <td><code>GameServerCS/</code></td>
              <td>Instância dedicada a Castle Siege e eventos PvP massivos.</td>
              <td>Separar serviços escaláveis (matchmaking/eventos) e sincronizar com UE5 via filas ou serviços em nuvem.</td>
            </tr>
            <tr>
              <td>MHPServer</td>
              <td><code>MHPServer/</code></td>
              <td>Proteção/anticheat legado com monitoramento de pacotes.</td>
              <td>Substituir por solução anti-cheat compatível com UE5 (EOS, Easy Anti-Cheat, VAC) ou criar validações server-side.</td>
            </tr>
            <tr>
              <td>Banco de Dados</td>
              <td><code>DB/</code>, <code>ScriptSql/</code></td>
              <td>Scripts SQL de criação, procedures e seeds.</td>
              <td>Revisar tabelas para normalização; gerar modelos ER atualizados para migração.</td>
            </tr>
            <tr>
              <td>Ferramentas</td>
              <td><code>Tools/</code></td>
              <td>Utilitários de manutenção (ex.: reset, monitoramento de eventos).</td>
              <td>Identificar ferramentas imprescindíveis e recriar painéis Web/CLI com APIs modernas.</td>
            </tr>
          </tbody>
        </table>
        <div class="atlas-highlight">
          <strong>Checklist Backend:</strong>
          <ul class="atlas-list">
            <li>Mapear dependências entre executáveis (ordem de inicialização em <code>StartUp/</code>).</li>
            <li>Catalogar arquivos <code>GameServerInfo - *.dat</code> para definir configurações que devem virar serviços de configuração.</li>
            <li>Exportar procedures críticas do diretório <code>ScriptSql</code> para documentação e refatoração.</li>
          </ul>
        </div>
      </div>

      <div class="atlas-content" data-tab="dados">
        <h3>Dados Compartilhados Entre Cliente e Servidor</h3>
        <div class="atlas-grid">
          <div>
            <strong>Diretório <code>MuServer_Season_5_Update_15/Data</code></strong>
            <ul class="atlas-list">
              <li><code>Item/</code>: tabelas <code>Item.txt</code>, <code>ItemDrop.txt</code>, <code>ItemOption.txt</code>, <code>ItemValue.txt</code> — base para inventário, drops e economia.</li>
              <li><code>Event/</code>: arquivos <code>BloodCastle.dat</code>, <code>DevilSquare.dat</code>, <code>ImperialGuardian.dat</code> descrevendo horários, bosses, recompensas.</li>
              <li><code>Custom/</code>: ajustes proprietários (ex.: <code>CustomCombo.txt</code>, <code>CustomMix.txt</code>, <code>CustomJewel.txt</code>) a serem refletidos em sistemas UE5.</li>
              <li><code>Character/</code>: limites de atributos, taxas de XP e configurações de classes.</li>
              <li>Arquivos globais (<code>Command.txt</code>, <code>Effect.txt</code>, <code>ItemMove.txt</code>) mapeiam comandos e efeitos utilizados tanto no cliente quanto no servidor.</li>
            </ul>
          </div>
          <div>
            <strong>Cliente <code>Source Main 5.2/source</code></strong>
            <ul class="atlas-list">
              <li><code>LoadData.cpp</code> &amp; <code>ReadScript.h</code>: rotinas de parsing de arquivos <code>.txt</code>/<code>.dat</code>.</li>
              <li><code>QuestInfo.cpp</code> e <code>QuestMng.cpp</code>: interpretam scripts de quests armazenados no servidor.</li>
              <li><code>GlobalText.h</code> + <code>Local.cpp</code>: strings compartilhadas com base nos mesmos IDs dos bancos de dados.</li>
            </ul>
          </div>
        </div>
        <div class="atlas-highlight">
          <strong>Práticas Recomendadas:</strong>
          <ul class="atlas-list">
            <li>Centralizar arquivos <code>.txt/.dat</code> em um repositório de dados versionado (Git LFS) e convertê-los para <code>JSON</code> ou <code>CSV</code> padronizado.</li>
            <li>Gerar <em>schemas</em> para cada tabela reutilizada, garantindo compatibilidade entre UE5 e backend moderno.</li>
            <li>Automatizar importação com scripts Python/C# que populam <code>Data Tables</code> na UE5 e alimentam o banco novo.</li>
          </ul>
        </div>
      </div>

      <div class="atlas-content" data-tab="pipeline">
        <h3>Pipeline Integrado Front + Back para Recriação na UE5</h3>
        <ol>
          <li><strong>Inventário de Assets</strong>: classifique meshes, texturas, ícones e sons oriundos do cliente e relacione com tabelas de itens (<code>Data/Item</code>).</li>
          <li><strong>Modelagem de APIs</strong>: transforme processos do <code>GameServer</code> em endpoints (login, load player, salvar inventário, rolagem de drop).</li>
          <li><strong>Sincronização de Dados</strong>: estabeleça formato único (ex.: <code>JSON</code>) e gere conversores a partir dos scripts originais (<code>LoadData.cpp</code>, <code>GameServerInfo - *.dat</code>).</li>
          <li><strong>Blueprint Gateway</strong>: crie <code>BP_ServerGateway</code> para consumir APIs (Login, CharacterLoad, ItemUpdate) com <code>Async Action</code> + <code>HTTP Request</code>.</li>
          <li><strong>Testes Integrados</strong>: para cada sprint, valide uma cadeia completa (ex.: login → carregar inventário → spawn mapa → evento → drop → salvar).</li>
        </ol>
        <div class="atlas-highlight">
          <strong>Ferramentas de Apoio:</strong>
          <ul class="atlas-list">
            <li>Scripts SQL do diretório <code>ScriptSql</code> como referência para modelar migrations modernas.</li>
            <li>Executáveis legados para capturar pacotes (útil ao recriar protocolos em UE5 via <code>Packet Capture</code>).</li>
            <li>Planilhas de estado de assets e dados compartilhados para acompanhar o progresso da migração.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="paridade">
      <h2>Paridade Validada com o Código Legado</h2>
      <p>
        Esta seção confirma que as instruções de recriação fazem referência direta ao código existente
        no repositório. Para cada subsistema crítico, o quadro abaixo destaca os arquivos originais,
        valores relevantes e como replicá-los fielmente na Unreal Engine 5.
      </p>
      <table class="matrix">
        <thead>
          <tr>
            <th>Subsistema</th>
            <th>Referência Legada</th>
            <th>Comportamento/Valores Originais</th>
            <th>Adaptação na UE5</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Login &amp; Launcher</td>
            <td><code>LoginWin.cpp</code> (<code>CLoginWin::Create</code>, <code>SetPosition</code>)</td>
            <td>Janela 329×245; campos deslocados +109/+106 e +109/+131; botões OK/Cancel em +150/+178 e +211/+178.</td>
            <td>Crie <code>WBP_Login</code> com Canvas 640×480 e widgets posicionados com <code>Anchors</code> absolutos. Reproduza sons <code>SOUND_CLICK01</code> e <code>SOUND_FAIL</code> via <code>PlaySound2D</code>.</td>
          </tr>
          <tr>
            <td>Seleção de Personagem</td>
            <td><code>CharSelMainWin.cpp</code> (<code>Create</code>, <code>SetPosition</code>)</td>
            <td>Botões 54×30; <code>m_asprBack[CSMW_SPR_INFO]</code> alinhado à direita; botões Connect/Delete deslocados para o final do painel.</td>
            <td>Use <code>Overlay</code> + <code>Horizontal Box</code> para replicar a régua de botões em <code>WBP_CharacterSelect</code>, preservando espaçamentos definidos em <code>SetPosition</code>.</td>
          </tr>
          <tr>
            <td>HUD Principal</td>
            <td><code>NewUIMainFrameWindow.cpp</code> (<code>RenderFrame</code>, <code>RenderLifeMana</code>)</td>
            <td>HUD renderizada em 480px de altura; barras de HP/MP ocupam 45×39px a partir do eixo Y=480−48; imagens <code>IMAGE_MENU_1..3</code> compõem a base.</td>
            <td>Configure <code>WBP_HUDRoot</code> com Canvas 960×540 (scale box) e barras dimensionadas 45×39px, usando <code>MaterialInstanceDynamic</code> para animar preenchimento conforme cálculo de <code>fLife</code>/<code>fMana</code>.</td>
          </tr>
          <tr>
            <td>Inventário &amp; Drag/Drop</td>
            <td><code>NewUIInventoryCtrl.cpp</code> (<code>CNewUIPickedItem</code>, <code>GetTargetPos</code>)</td>
            <td>Slots usam múltiplos de <code>INVENTORY_SQUARE_WIDTH</code>; posição do item segue o cursor com correção pelo tamanho do item e validação em <code>GetSquarePosAtPt</code>.</td>
            <td>Implemente <code>UniformGrid</code> com células 20×20 (valor de <code>INVENTORY_SQUARE_WIDTH</code>) e calcule célula-alvo aplicando mesma correção de largura/altura antes de efetivar <em>drop</em> no Blueprint.</td>
          </tr>
          <tr>
            <td>Drop de Itens</td>
            <td><code>ItemManager.cpp</code> (<code>CGItemDropRecv</code>)</td>
            <td>Validação inclui estado de morte, interfaces ativas, transações e <code>INVENTORY_FULL_RANGE</code>. Mensagem <code>0x23</code> confirma êxito ou falha.</td>
            <td>O endpoint <code>/inventory/drop</code> deve reproduzir todas as verificações antes de autorizar o spawn. Retorne o estado atualizado para sincronizar o widget na UE5.</td>
          </tr>
          <tr>
            <td>Spawn de Mobs</td>
            <td><code>MonsterSetBase.cpp</code> (<code>CMonsterSetBase::Load</code>)</td>
            <td>Parser lê seções, classe do monstro, mapa, distância, coordenadas X/Y e flags adicionais. Estrutura <code>MONSTER_SET_BASE_INFO</code> limita quantidade de registros.</td>
            <td>Converta cada linha em <code>DT_MobSpawn</code> (MapID, SpotRadius, SpawnCount, Direction). <code>BP_MobSpawner</code> deve respeitar os mesmos limites e tempos de respawn.</td>
          </tr>
          <tr>
            <td>Habilidades</td>
            <td><code>SkillManager.cpp</code> (<code>Load</code>) &amp; <code>SkillInfo.cpp</code></td>
            <td>Arquivos lidos via <code>CMemScript</code> definem consumo de mana, alcance, requisito de combo e efeitos aplicados.</td>
            <td>Armazene dados em <code>Data Tables</code> e use <code>Gameplay Ability System</code> para aplicar custos/efeitos idênticos aos do parsing legado.</td>
          </tr>
        </tbody>
      </table>
      <details class="guia" open>
        <summary>LoginWin.cpp ➝ WBP_Login</summary>
        <div class="code-card"><pre><code>CWin::Create(329, 245, BITMAP_LOG_IN + 7);
m_asprInputBox[LIW_ACCOUNT].SetPosition(nXCoord + 109, nYCoord + 106);
m_asprInputBox[LIW_PASSWORD].SetPosition(nXCoord + 109, nYCoord + 131);
m_aBtn[LIW_OK].SetPosition(nXCoord + 150, nYCoord + 178);
m_aBtn[LIW_CANCEL].SetPosition(nXCoord + 211, nYCoord + 178);</code></pre></div>
        <ul>
          <li>Defina um <code>Canvas Panel</code> 640×480 na UE5 e posicione campos usando os mesmos offsets absolutos.</li>
          <li>Mapeie os sons <code>SOUND_CLICK01</code>/<code>SOUND_FAIL</code> para <code>USoundCue</code> reaproveitando os arquivos originais.</li>
        </ul>
      </details>
      <details class="guia" open>
        <summary>CharSelMainWin.cpp ➝ WBP_CharacterSelect</summary>
        <div class="code-card"><pre><code>m_aBtn[CSMW_BTN_CREATE].Create(54, 30, BITMAP_LOG_IN+3, 4, 2, 1, 3);
m_aBtn[CSMW_BTN_MENU].SetPosition(nXCoord + nBtnWidth + 1, nYCoord);
m_asprBack[CSMW_SPR_INFO].SetPosition(m_aBtn[CSMW_BTN_MENU].GetXPos() + nBtnWidth + 2, nYCoord + 5);
m_aBtn[CSMW_BTN_CONNECT].SetPosition(nWinRPosX - (nBtnWidth * 2 + 1), nYCoord);
m_aBtn[CSMW_BTN_DELETE].SetPosition(nWinRPosX - nBtnWidth, nYCoord);</code></pre></div>
        <ul>
          <li>Crie uma <code>Horizontal Box</code> para botões e ajuste espaçamentos (1px/2px) através de <code>Padding</code> customizado.</li>
          <li>Reposicione o painel de informações à direita replicando o deslocamento calculado em relação ao botão “Menu”.</li>
        </ul>
      </details>
      <details class="guia" open>
        <summary>NewUIMainFrameWindow.cpp ➝ WBP_HUDRoot</summary>
        <div class="code-card"><pre><code>width = 256.f; height = 51.f;
x = 0.f; y = 480.f - height;
RenderImage(IMAGE_MENU_1, x, y, width, height);
...
width = 45.f; x = 158.f; height = 39.f; y = 480.f - 48.f;
RenderBitmap(IMAGE_GAUGE_RED, x, fY, width, fH, ...);</code></pre></div>
        <ul>
          <li>Monte a base da HUD com três imagens alinhadas na parte inferior, mantendo largura total de 640px.</li>
          <li>Aplique materiais com coordenadas UV recortadas para simular o preenchimento vertical das barras de HP/MP.</li>
        </ul>
      </details>
      <details class="guia" open>
        <summary>NewUIInventoryCtrl.cpp ➝ WBP_Inventory</summary>
        <div class="code-card"><pre><code>m_Size.cx = pItemAttr->Width * INVENTORY_SQUARE_WIDTH;
m_Size.cy = pItemAttr->Height * INVENTORY_SQUARE_HEIGHT;
int iPickedItemX = MouseX - ((pItemAttr->Width - 1) * INVENTORY_SQUARE_WIDTH / 2);
return pDest->GetSquarePosAtPt(iPickedItemX, iPickedItemY, iTargetColumnX, iTargetRowY);</code></pre></div>
        <ul>
          <li>Antes de completar o <em>drop</em>, converta coordenadas do mouse em colunas/linhas exatamente como no método legado.</li>
          <li>Guarde largura/altura de cada item na <code>Data Table</code> derivada de <code>Item.txt</code> para validar sobreposição.</li>
        </ul>
      </details>
      <details class="guia" open>
        <summary>ItemManager.cpp ➝ Serviço /inventory/drop</summary>
        <div class="code-card"><pre><code>pMsg.header.set(0x23, sizeof(pMsg));
if(lpObj->Interface.use != 0 && lpObj->Interface.type != INTERFACE_SHOP) return;
if(lpObj->Transaction == 1) return;
if(INVENTORY_FULL_RANGE(lpMsg->slot) == 0) return;</code></pre></div>
        <ul>
          <li>Replique cada condição antes de gerar o loot. Falhas devem retornar códigos equivalentes ao <code>pMsg.result</code>.</li>
          <li>Logue requisições inválidas para auditoria, assim como o servidor original utiliza <code>LogAddTD</code>.</li>
        </ul>
      </details>
      <details class="guia" open>
        <summary>MonsterSetBase.cpp ➝ BP_MobSpawner</summary>
        <div class="code-card"><pre><code>info.MonsterClass = lpMemScript->GetNumber();
info.Map = lpMemScript->GetAsNumber();
info.Dis = lpMemScript->GetAsNumber();
info.X = lpMemScript->GetAsNumber();
info.Y = lpMemScript->GetAsNumber();</code></pre></div>
        <ul>
          <li>Crie estruturas UE5 com os mesmos campos (Classe, Mapa, Raio, Coordenadas) para instanciar spawners.</li>
          <li>Implemente timers de respawn que respeitam <code>info.Dis</code> e quantidade máxima calculada no loader legado.</li>
        </ul>
      </details>
    </section>

    <section id="codigo-main-muserver">
      <h2>Estudo Profundo das Fontes Main 5.2 e MuServer</h2>
      <p>
        As instruções desta etapa foram auditadas diretamente contra o código em
        <code>Source Main 5.2/source</code> e
        <code>Source MuServer Update 15/GameServer/GameServer</code>. Utilize os
        quadros a seguir para alinhar Blueprints, serviços e tabelas de dados à
        implementação original antes de expandir funcionalidades na Unreal
        Engine 5.
      </p>

      <article class="module-category">
        <h3>Sistema Completo de Itens (Interface, Tooltips, Drops e Persistência)</h3>
        <table class="matrix">
          <thead>
            <tr>
              <th>Foco</th>
              <th>Referência Legada</th>
              <th>Comportamento Observado</th>
              <th>Adaptação UE5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Grid, slots e offsets</td>
              <td>
                <code>CNewUIMyInventory::Create</code> e
                <code>CNewUIInventoryCtrl</code>
              </td>
              <td>
                Inventário inicia em <code>x+15</code>/<code>y+200</code> com
                grade 8×8 e células 20×20 definidas em
                <code>INVENTORY_SQUARE_WIDTH</code>.
              </td>
              <td>
                Configure um <code>UniformGridPanel</code> 8×8 e traduza o
                deslocamento (15, 200) para o <code>Canvas Panel</code> da UE5
                antes de propagar eventos de arrasto.
              </td>
            </tr>
            <tr>
              <td>Tooltips multi-resolução</td>
              <td>
                <code>CNewUIItemExplanationWindow::Render</code>
              </td>
              <td>
                Larguras e espaçamentos variam por
                <code>WindowWidth</code>; cada categoria (espadas, staffs,
                armaduras) reposiciona colunas e tabulações.
              </td>
              <td>
                Crie um <code>WidgetSwitcher</code> com estilos por resolução e
                ajuste margens conforme os fatores de tabulação originais antes
                de preencher descrições no UMG.
              </td>
            </tr>
            <tr>
              <td>Restrições de drop</td>
              <td>
                <code>ZzzInventory.cpp</code> → <code>IsDropBan</code>
              </td>
              <td>
                Bloqueia poções específicas, helpers e itens de evento mesmo
                fora do período (<code>bPeriodItem</code>) para impedir drops
                indevidos.
              </td>
              <td>
                Valide tipos proibidos na Blueprint<br />
                <code>BP_Inventario_DropItem</code> antes de enviar a requisição
                ao backend e informe feedback igual ao cliente legado.
              </td>
            </tr>
            <tr>
              <td>Tabelas de drop</td>
              <td>
                <code>CItemDrop::Load</code> e <code>CustomEventDrop.txt</code>
              </td>
              <td>
                Parser lê índices, nível, opções 0–6, mapa, classe do monstro e
                taxa de drop diretamente do arquivo de configuração.
              </td>
              <td>
                Carregue o mesmo CSV em uma <code>DataTable</code> e exponha a
                estrutura via <code>USTRUCT</code> para o serviço HTTP
                <code>/drops/roll</code>, preservando o pipeline de opções.
              </td>
            </tr>
            <tr>
              <td>Spawn físico de loot</td>
              <td>
                <code>CItemDrop::DropItem</code> e
                <code>CMapItem::CreateItem</code>
              </td>
              <td>
                Seleção ponderada por <code>DropRate</code> e timers de loot
                baseados em <code>gServerInfo.m_ItemDropTime</code> definem vida
                útil e bloqueio inicial do item.
              </td>
              <td>
                Replique temporizadores com <code>FTimerHandle</code> e atributos
                de <code>GameplayTag</code> para o estado “reservado” até o fim
                do <em>loot time</em>, sincronizando com o backend via WebSocket.
              </td>
            </tr>
            <tr>
              <td>Dados brutos</td>
              <td>
                <code>Data/Item/Item.txt</code>
              </td>
              <td>
                Define dimensões X/Y de cada item, requisitos e nomes usados por
                tooltips e validação de slots.
              </td>
              <td>
                Gere <code>Data Tables</code> derivadas do arquivo legado para
                alimentar validações de tamanho, requisitos e ícones na UE5.
              </td>
            </tr>
          </tbody>
        </table>

        <details class="guia" open>
          <summary>Passo a passo UE5 — Inventário, Drop e Tooltips</summary>
          <ol>
            <li>
              Recrie <code>WBP_MyInventory</code> com um
              <code>Canvas Panel</code> ancorado e posicione o grid em
              (15, 200) replicando a chamada de criação do controle legado.
            </li>
            <li>
              No <code>OnDragDetected</code>, calcule célula alvo aplicando a
              mesma correção usada em <code>CNewUIPickedItem::GetTargetPos</code>
              (metade do tamanho do item) antes de chamar o backend.
            </li>
            <li>
              Sincronize as regras de <code>IsDropBan</code> e do arquivo
              <code>CustomEventDrop.txt</code> no microserviço
              <code>InventoryService</code>, retornando códigos de erro
              equivalentes aos estados do cliente original.
            </li>
            <li>
              Renderize tooltips usando um <code>WidgetSwitcher</code> para cada
              resolução suportada e aplique os fatores de tabulação capturados em
              <code>Render</code> para manter alinhamento com o legado.
            </li>
            <li>
              Quando o backend confirmar a criação do item
              (<code>GDCreateItemSend</code> no código original), instancie um
              <code>BP_WorldItem</code> com o mesmo tempo de expiração calculado
              a partir de <code>m_ItemDropTime</code>.
            </li>
          </ol>
        </details>
      </article>

      <article class="module-category">
        <h3>Spawns de Mobs, Respawn e Progressão de Experiência</h3>
        <table class="matrix">
          <thead>
            <tr>
              <th>Foco</th>
              <th>Referência Legada</th>
              <th>Comportamento Observado</th>
              <th>Adaptação UE5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Carregamento de spawn</td>
              <td>
                <code>CMonsterSetBase::Load</code>
              </td>
              <td>
                Parser lê seções, mapa, raio, coordenadas e quantidade a partir
                do arquivo de texto antes de preencher
                <code>m_MonsterSetBaseInfo</code>.
              </td>
              <td>
                Monte um <code>DataTable</code> <em>DT_MonsterSpawn</em> com os
                mesmos campos e alimente um <code>Subsystem</code> que instancia
                <code>BP_MobSpawner</code> por mapa.
              </td>
            </tr>
            <tr>
              <td>Seleção de posição</td>
              <td>
                <code>CMonsterSetBase::GetBoxPosition</code>
              </td>
              <td>
                Gera até 100 tentativas aleatórias dentro do retângulo e valida
                atributos do mapa antes de permitir o spawn.
              </td>
              <td>
                Replique o algoritmo com <code>RandomStream</code> e checagem de
                <code>NavigationSystem</code> para evitar colisões antes do
                <code>SpawnActor</code> em UE5.
              </td>
            </tr>
            <tr>
              <td>Dados de referência</td>
              <td>
                <code>Data/Monster/MonsterSetBase.txt</code>
              </td>
              <td>
                Lista NPCs e monstros por mapa, incluindo comentários úteis para
                identificar cada spot.</td>
              <td>
                Utilize o mesmo arquivo para validar coordenadas e gerar gizmos
                de depuração dentro do editor da UE5.
              </td>
            </tr>
            <tr>
              <td>Tabela dinâmica de XP</td>
              <td>
                <code>CExperienceTable::Load</code> e
                <code>ExperienceTable.txt</code>
              </td>
              <td>
                Permite taxas diferenciadas por nível, reset e master reset,
                retornando 100% por padrão.</td>
              <td>
                Alimente um <code>Data Asset</code> utilizado pelo
                <code>ExperienceSubsystem</code> e habilite overrides por mapa ou
                evento via <code>Gameplay Tags</code>.
              </td>
            </tr>
            <tr>
              <td>Curva base de experiência</td>
              <td>
                <code>gObjSetExperienceTable</code> em <code>User.cpp</code>
              </td>
              <td>
                Calcula <code>gLevelExperience[n]</code> com fórmula cúbica e
                bônus adicional a partir do nível 256.</td>
              <td>
                Use a mesma curva em um <code>CurveFloat</code> e aplique o
                incremento extra após o nível 255 em Blueprint ou C++ para manter
                paridade com o servidor.</td>
            </tr>
          </tbody>
        </table>

        <details class="guia" open>
          <summary>Passo a passo UE5 — Spawns, Respawn e XP</summary>
          <ol>
            <li>
              Gere <code>Data Tables</code> a partir de
              <code>MonsterSetBase.txt</code> e atribua-as a um
              <code>Subsystem</code> responsável por criar spawners persistentes
              em <code>BeginPlay</code>.
            </li>
            <li>
              Dentro de cada spawner, execute a mesma rotina de tentativa de
              posição (<code>GetBoxPosition</code>) com checagem de navegação
              antes de instanciar o blueprint do mob.
            </li>
            <li>
              Exponha tempos de respawn e limites de população iguais aos
              parâmetros originais e sincronize mortes via WebSocket com o
              backend.</li>
            <li>
              Carregue <code>ExperienceTable.txt</code> no backend para calcular
              multiplicadores e envie-os junto à resposta de kill; a UE5 aplica a
              curva base <code>gLevelExperience</code> para atualizar a barra de
              XP.
            </li>
          </ol>
        </details>
      </article>

      <article class="module-category">
        <h3>Sistema de Skills, Hitboxes e Consumo de Recursos</h3>
        <table class="matrix">
          <thead>
            <tr>
              <th>Foco</th>
              <th>Referência Legada</th>
              <th>Comportamento Observado</th>
              <th>Adaptação UE5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Metadados de skills</td>
              <td>
                <code>CSkillManager::Load</code> e <code>Data/Skill/Skill.txt</code>
              </td>
              <td>
                Cada linha define dano, mana, BP, alcance, atraso, efeito e
                requisitos por classe.</td>
              <td>
                Converta para <code>Gameplay Ability Data Assets</code> e gere
                <code>FGameplayAbilitySpec</code> com os mesmos custos e tags de
                requisito.
              </td>
            </tr>
            <tr>
              <td>Hitboxes direcionais</td>
              <td>
                <code>CSkillHitBox::Load</code> e <code>SkillElect.hit</code>
              </td>
              <td>
                Arquivo binário 36×21×21 que mapeia impactos por direção e
                deslocamento relativo.</td>
              <td>
                Importe como <code>Data Asset</code> ou <code>CurveTable</code>
                e utilize para construir <code>Trace</code> múltiplos na UE5 em
                vez de colisões genéricas.</td>
            </tr>
            <tr>
              <td>Execução de skills</td>
              <td>
                <code>CSkillManager::GetSkillDamage</code>/<code>GetSkillMana</code>
              </td>
              <td>
                Recupera custos e danos diretamente da tabela carregada; falha
                retorna <code>-1</code>.</td>
              <td>
                Garanta verificação prévia no Ability System aplicando os mesmos
                retornos (por exemplo, status “SkillUnavailable”) quando o índice
                não existir.</td>
            </tr>
          </tbody>
        </table>

        <details class="guia" open>
          <summary>Passo a passo UE5 — Blueprints de Skills</summary>
          <ol>
            <li>
              Gere um <code>PrimaryDataAsset</code> por skill contendo dano,
              custo e tags de requisito extraídos de <code>Skill.txt</code>.
            </li>
            <li>
              No <code>UGameplayAbility</code>, carregue a matriz de hitbox e
              execute <code>SphereTraceMulti</code> seguindo o padrão de
              <code>HitCheck</code> (ajuste de 10 unidades para centro).
            </li>
            <li>
              Mapeie os efeitos visuais originais usando o mesmo índice de
              <code>info.Effect</code> para selecionar Niagara Systems ou Meshes
              já migrados.
            </li>
            <li>
              Concilie com o backend expondo endpoints de cast que consomem mana
              e BP conforme <code>GetSkillMana</code>/<code>GetSkillBP</code> e
              registram cooldowns iguais ao campo <code>Delay</code>.
            </li>
          </ol>
        </details>
      </article>

      <article class="module-category">
        <h3>Economia, NPCs e Lojas (NPC/Cash/Personal)</h3>
        <table class="matrix">
          <thead>
            <tr>
              <th>Foco</th>
              <th>Referência Legada</th>
              <th>Comportamento Observado</th>
              <th>Adaptação UE5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Layout da vitrine NPC</td>
              <td><code>CNewUINPCShop::Create</code></td>
              <td>Instancia <code>CNewUIInventoryCtrl</code> com offset <code>x+15</code>/<code>y+50</code>, grade 8×15 e <code>LockInventory()</code> ativo.</td>
              <td>Modele <code>WBP_NPCShop</code> com <code>Canvas Panel</code> deslocado 15/50px e <code>UniformGridPanel</code> 8×15 bloqueado para arrasto externo.</td>
            </tr>
            <tr>
              <td>Interação e compra</td>
              <td><code>CNewUINPCShop::UpdateMouseEvent</code>, <code>InventoryProcess()</code></td>
              <td>Calcula índice via <code>(pItem-&gt;y * columns) + pItem-&gt;x</code>, diferencia lojas Gamble e envia <code>SendRequestBuy</code> quando <code>BuyCost</code> é zero.</td>
              <td>Implemente em Blueprint a mesma fórmula de índice, suporte alternância Gamble e bloqueie cliques enquanto <code>InventoryProcess</code> retorna ativo.</td>
            </tr>
            <tr>
              <td>Catálogo backend</td>
              <td><code>CShopManager::Load</code>, <code>LoadShop</code></td>
              <td>Lê <code>Shop\*.txt</code>, associa <code>Index</code>, <code>MonsterClass</code>, <code>Map/X/Y</code> e recarrega lista com <code>GCShopItemListSendByIndex</code>.</td>
              <td>Construa serviço <code>ShopGateway</code> que expõe catálogo filtrado por NPC/mapa e replica resposta JSON para o widget UE5.</td>
            </tr>
            <tr>
              <td>Pacotes Cash Shop</td>
              <td><code>CCashShop::LoadPackage</code>, <code>LoadProduct</code></td>
              <td>Define <code>Category</code>, <code>CoinIndex</code>, bônus GP e arrays <code>ProductBaseIndex/MainIndex</code> para cada pacote.</td>
              <td>Converta <code>CashShopPackage.txt</code>/<code>Product.txt</code> em <code>PrimaryDataAssets</code> UE5 e sincronize compras via endpoint seguro.</td>
            </tr>
            <tr>
              <td>Loja pessoal e trocas</td>
              <td><code>CPersonalShop::CheckPersonalShop</code>, <code>CTrade::CGTradeRequestRecv</code></td>
              <td>Loja pessoal confirma slots/preços antes de abrir e trocas validam interface, distância e status antes de chamar <code>gObjInventoryCommit</code>.</td>
              <td>Implemente atores <code>BP_PersonalShop</code>/<code>BP_TradeSession</code> replicados com as mesmas verificações e commits atômicos.</td>
            </tr>
          </tbody>
        </table>

        <details class="guia" open>
          <summary>Passo a passo UE5 — Lojas NPC e Cash</summary>
          <ol>
            <li>Construa <code>WBP_NPCShop</code> e <code>WBP_CashShop</code> com <code>Canvas</code> reproduzindo offsets 15/50px e grade 8×15.</li>
            <li>Mapeie botões de compra/venda para chamar <code>ShopGateway</code>, convertendo o índice igual ao cliente legado.</li>
            <li>Implemente <code>Data Table</code> para <code>Shop</code> e <code>Cash Shop</code> geradas dos arquivos originais e injete-as via <code>Subsystem</code>.</li>
            <li>Sincronize feedback visual (mensagens, travas) reutilizando os mesmos códigos de resultado (ex.: “NotEnoughZen”).</li>
          </ol>
        </details>

        <details class="guia">
          <summary>Backend — Sincronização de Inventário e Transações</summary>
          <ul>
            <li>Replique <code>CShopManager::ReloadShopInterface</code> com endpoint <code>POST /shop/reload</code> para atualizar UIs conectadas.</li>
            <li>Movimente Zen, Cash e itens usando filas transacionais inspiradas em <code>PersonalShop::GCShopResultSend</code>.</li>
            <li>Implemente auditoria de compra/venda seguindo <code>LogAddTD</code> do legado.</li>
          </ul>
        </details>
      </article>

      <article class="module-category">
        <h3>Eventos Clássicos, Instâncias e Bosses</h3>
        <table class="matrix">
          <thead>
            <tr>
              <th>Foco</th>
              <th>Referência Legada</th>
              <th>Comportamento Observado</th>
              <th>Adaptação UE5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Blood Castle</td>
              <td><code>CBloodCastle::Init</code>, <code>Load</code></td>
              <td>Estados <code>BC_STATE_*</code> controlam entrada, tempo restante, ponte e NPCs carregados de <code>MonsterSetBase</code>.</td>
              <td>Crie <code>ABP_BloodCastleController</code> que usa <code>State Machine</code> idêntica e ativa sequências/cutscenes via <em>Level Blueprint</em>.</td>
            </tr>
            <tr>
              <td>Devil/Chaos Castle</td>
              <td><code>CDevilSquare::SetState</code>, <code>CChaosCastle::ProcState_*</code></td>
              <td>Rotinas alternam spawn waves, recompensas e expulsão usando timers do <code>gQueueTimer</code>.</td>
              <td>Implemente <code>World Partition Level Instances</code> com timers equivalentes e atualize HUD via mensagens replicadas.</td>
            </tr>
            <tr>
              <td>Kanturu &amp; Raklion</td>
              <td><code>CKanturuBattleOfMaya</code>, <code>CRaklionBattleUserMng</code></td>
              <td>Gerenciam fases sequenciais, spawn de bosses e checkpoints com <code>SetState</code> e estruturas de usuário ativo.</td>
              <td>Construa componentes de estado (fase atual, contadores) que dirigem <em>Level Streaming</em> e triggers de boss fights.</td>
            </tr>
            <tr>
              <td>Illusion Temple &amp; Imperial Guardian</td>
              <td><code>CIllusionTemple::Init</code>, <code>CImperialGuardian::Run</code></td>
              <td>Lê scripts <code>Event/*.txt</code>, sincroniza times e entradas por party, aplicando recompensas específicas.</td>
              <td>Use <code>Data Assets</code> para configurar objetivos e crie <code>UMG</code> de placar compartilhado sincronizado via backend.</td>
            </tr>
            <tr>
              <td>Crywolf</td>
              <td><code>Crywolf.cpp</code>, <code>CrywolfAltar.cpp</code>, <code>CrywolfStatue.cpp</code></td>
              <td>Estados <code>CRYWOLF_STATE_*</code> controlam altar, estátuas e buffs defensivos. O cliente habilita o HUD dedicado (<code>NewUICryWolf.cpp</code>).</td>
              <td>Implemente <code>BP_CrywolfController</code> com <em>state machine</em> equivalente, Data Table para altares/estátuas e widget UMG replicando o layout original.</td>
            </tr>
            <tr>
              <td>Castle Siege &amp; Land of Trials</td>
              <td><code>CastleSiege.cpp</code>, <code>CastleSiegeSync.cpp</code>, <code>CastleSiegeCrown.cpp</code></td>
              <td>Máquina de estados controla registro, batalha, <em>switch</em> da coroa e ocupação; Land of Trials habilita drops especiais via <code>gCastleSiegeSync</code>.</td>
              <td>Construa <code>BP_CastleSiegeDirector</code> que atualiza fases, controla <em>capture points</em> e replica buffs/tributos. Use níveis dedicados para sala do trono e Land of Trials.</td>
            </tr>
            <tr>
              <td>Arca Battle &amp; Double Goer</td>
              <td><code>ArcaBattle.cpp</code>, <code>DoubleGoer.cpp</code>, <code>EventInventory.cpp</code></td>
              <td>Carregam rotinas de pré-inscrição, combinam times automáticos, consomem itens-chave e gerenciam ranking via <code>EventInventory</code>.</td>
              <td>Crie <code>BP_ArcaBattleService</code>/<code>BP_DoubleGoerService</code> que validam inscrições via backend, aplicam matchmaking equivalente e atualizam placares UMG sincronizados.</td>
            </tr>
          </tbody>
        </table>

        <details class="guia" open>
          <summary>Passo a passo UE5 — Eventos Instanciados</summary>
          <ol>
            <li>Converta scripts <code>Data/Event/*.txt</code> para <code>Data Tables</code> e carregue-os em um <code>EventSubsystem</code>.</li>
            <li>Implemente controladores de evento com <code>State Machine</code> equivalentes aos enumeradores <code>STATE_*</code>.</li>
            <li>Replique drops e recompensas conforme <code>ItemBagManager</code> e <code>BonusManager</code> para manter loot tabelas originais.</li>
            <li>Sincronize entrada/saída de jogadores via backend REST/WebSocket usando os mesmos limites de party e nível.</li>
          </ol>
        </details>
      </article>

      <article class="module-category">
        <h3>Sistemas Avançados: Muun, Pentagrama, Helper e PcPoint</h3>
        <table class="matrix">
          <thead>
            <tr>
              <th>Foco</th>
              <th>Referência Legada</th>
              <th>Comportamento Observado</th>
              <th>Adaptação UE5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Companheiros Muun</td>
              <td>
                <code>MuunSystem.cpp</code>, <code>User.cpp</code>, <code>Attack.cpp</code>,<br />
                <code>ServerInfo.cpp</code> (carga de <code>Item\\MuunOption.txt</code>)
              </td>
              <td>
                <code>CMuunSystem::Load</code> popula <code>m_MuunSystemInfo</code> e opções adicionais,
                <code>gMuunSystem.MainProc()</code> é chamado no <code>User.cpp</code> para atualizar buffs,
                e <code>Attack.cpp</code> aplica sprites via <code>MuunSprite</code> quando um pet está ativo.
              </td>
              <td>
                Converter <code>Item/MuunOption.txt</code> em <code>Data Tables</code>, criar
                <code>BP_MuunComponent</code> que lê evoluções/ranqueamento e atualizar HUD com os ícones
                originais (<code>NewUIPetInfoWindow.cpp</code> ➝ <code>Interface\\newui_pet_*.tga</code>).
              </td>
            </tr>
            <tr>
              <td>Pentagrama &amp; Joias Elementais</td>
              <td>
                <code>PentagramSystem.cpp</code>, <code>Item.cpp</code>, <code>ServerInfo.cpp</code>
                (cargas de <code>Item\\Pentagram*.txt</code>)
              </td>
              <td>
                <code>CPentagramSystem::Load</code> carrega tipos, opções e ranks; <code>CItem::IsPentagramItem</code>
                e <code>::IsPentagramJewel</code> consultam o sistema para validar equipáveis e joias elementais.
              </td>
              <td>
                Criar <code>DT_PentagramTypes</code>/<code>DT_PentagramJewels</code>, um <code>BP_PentagramComponent</code>
                que processa slots elementais e UI dedicada reutilizando o layout de <code>NewUIItemMng</code>.
              </td>
            </tr>
            <tr>
              <td>Mu Helper / Auto-caça</td>
              <td>
                <code>Helper.cpp</code>, <code>ServerInfo.cpp</code> (<code>HelperSwitch</code>, <code>HelperActiveMoney*</code>),
                <code>NewUIMoveCommandWindow.cpp</code>
              </td>
              <td>
                <code>CHelper::MainProc</code> debita Zen periodicamente, valida mapas permitidos e envia
                <code>GCHelperStartSend</code>; o cliente habilita toggles no menu de comandos (Move Command Window).
              </td>
              <td>
                Expor <code>BP_HelperSubsystem</code> com estados e custos sincronizados via REST/WebSocket,
                reconstruir o painel com os botões originais (texturas <code>Interface\\newui_command.jpg</code>) e automatizar
                comportamentos usando <code>Behavior Trees</code> equivalentes.
              </td>
            </tr>
            <tr>
              <td>Pontos PcPoint &amp; Loja de Fidelidade</td>
              <td>
                <code>PcPoint.cpp</code>, <code>CashShop.cpp</code>, <code>ServerInfo.cpp</code>
                (carga de <code>PcPoint.txt</code>), <code>NewUIPurchaseShopInventory.cpp</code>
              </td>
              <td>
                <code>CPcPoint::Load</code> converte itens em recompensas com sockets/opções; compra via
                <code>CGPcPointItemBuyRecv</code> valida saldo e chama <code>GDPcPointAddPointSaveSend</code> para persistir.
              </td>
              <td>
                Recriar catálogos em <code>DT_PcPointShop</code>, implementar <code>PcPointService</code> que replica as mesmas
                validações antes de consumir saldo e montar um widget UMG inspirado em <code>NewUIPurchaseShopInventory</code>.
              </td>
            </tr>
          </tbody>
        </table>

        <details class="guia" open>
          <summary>Passo a passo — Muun e Pentagrama</summary>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/MuunSystem.cpp</code></div>
            <pre><code>info.Index = lpMemScript->GetNumber();
info.Type = lpMemScript->GetAsNumber();
info.Rank = lpMemScript->GetAsNumber();
info.OptionIndex = lpMemScript->GetAsNumber();
info.EvolutionItemIndex = lpMemScript->GetAsNumber();
this->m_MuunSystemInfo.insert(std::make_pair(info.Index, info));</code></pre>
          </div>
          <ol>
            <li>Extrair <code>Item/MuunOption.txt</code> e <code>Item/MuunEvolution.txt</code> (se disponível) com o script do diretório <code>tools/</code> gerando CSVs preservando <em>Index</em>, <em>Rank</em>, <em>OptionIndex</em>.</li>
            <li>Importar para a UE5 como <code>Primary Data Assets</code> (<code>FMuunDefinition</code>) e criar <code>BP_MuunComponent</code> anexado ao personagem; ler os dados no <code>BeginPlay</code> para spawnar companions usando <code>Niagara</code> equivalente a <code>MuunSprite</code>.</li>
            <li>Converter texturas de <code>NewUIPetInfoWindow::LoadImages()</code> (<code>Interface\\newui_pet_lifebar01.jpg</code>, <code>newui_item_table*.tga</code>) para <code>.png</code> e posicionar num <code>WBP_MuunPanel</code> com o mesmo offset <code>(x+12, y+48)</code>.</li>
            <li>No backend, mapear endpoints <code>/companion/equip</code>, <code>/companion/feed</code> replicando as validações de <code>MuunSystem.cpp</code> (mapas permitidos, evolução por <code>EvolutionItemIndex</code>).</li>
          </ol>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/PentagramSystem.cpp</code></div>
            <pre><code>gPentagramSystem.Load(gPath.GetFullPath("Item\\PentagramOption.txt"));
gPentagramSystem.LoadJewel(gPath.GetFullPath("Item\\PentagramJewelOption.txt"));
gPentagramSystem.LoadMixRate(gPath.GetFullPath("Item\\PentagramJewelMixRate.txt"));</code></pre>
          </div>
          <ol>
            <li>Gerar <code>DT_PentagramOption</code> e <code>DT_PentagramJewel</code> com colunas idênticas às seções 0/1 do script original (Type, Rank, Level, OptionValue).</li>
            <li>Na UE5, criar um <code>BP_PentagramInventory</code> com <code>Array</code> de <code>FPentagramSlot</code> (Elemento, Nível, Rank) e UI que permite inserir joias com <em>Drag &amp; Drop</em> baseado em <code>CNewUIInventoryCtrl</code>.</li>
            <li>O backend deve validar combinações utilizando as mesmas tabelas carregadas por <code>CPentagramSystem</code>, calculando taxas de sucesso conforme <code>PentagramJewelMixRate.txt</code>.</li>
            <li>Reproduzir o dano elemental chamando <code>ApplyGameplayEffect</code> usando os multiplicadores retornados pelo serviço, assim como o servidor legado consulta <code>GetPentagramDamage()</code>.</li>
          </ol>
        </details>

        <details class="guia">
          <summary>Passo a passo — Helper e PcPoint</summary>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/Helper.cpp</code></div>
            <pre><code>if((GetTickCount()-lpObj->HelperDelayTime) >= gServerInfo.m_HelperActiveDelay*60000)
{
        lpObj->Money -= (lpObj->Level+lpObj->MasterLevel)*gServerInfo.m_HelperActiveMoney[HelperStage];
        GCMoneySend(lpObj->Index,lpObj->Money);
        this->GCHelperStartSend(lpObj->Index,((GetTickCount()-lpObj->HelperTotalTime)/60000), ...);
}</code></pre>
          </div>
          <ol>
            <li>Mapear para <code>Config/ServerInfo.ini</code> os mesmos parâmetros <code>HelperSwitch</code>, <code>HelperActiveLevel</code> e <code>HelperActiveMoney*</code>. O microserviço UE5 deve aplicar os débitos e limites de mapa antes de habilitar o modo automático.</li>
            <li>Construir <code>WBP_HelperPanel</code> inspirado em <code>NewUIMoveCommandWindow.cpp</code> reutilizando <code>Interface\\newui_command.jpg</code>; os toggles disparam eventos em <code>BP_HelperSubsystem</code> para iniciar/parar rotinas de IA (<code>Behavior Tree</code> customizado).</li>
            <li>Reaproveitar <code>gServerInfo.m_HelperActiveMoney</code> para exibir o custo em Zen por estágio, atualizando via WebSocket quando o servidor enviar <code>HelperStart</code>/<code>HelperStop</code>.</li>
            <li>Para PcPoint, carregar <code>PcPoint.txt</code> e reconstruir a vitrine com <code>WBP_PcPointShop</code> refletindo a grade de <code>NewUIPurchaseShopInventory</code> (slots 8x4 em <code>(x+16, y+90)</code>).</li>
          </ol>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/PcPoint.cpp</code></div>
            <pre><code>int ItemIndex = SafeGetItem(GET_ITEM(lpMemScript->GetNumber(),lpMemScript->GetAsNumber()));
int Socket1 = lpMemScript->GetAsNumber();
...
this->InsertItemNew(ItemIndex, ItemLevel, ItemDurability, ..., Socket5, ItemValue);</code></pre>
          </div>
          <ol>
            <li>Criar um conversor que transforme cada linha de <code>PcPoint.txt</code> em <code>FPcPointItemRow</code> (ItemIndex, Level, Options, Value) preservando sockets e opções excelentes.</li>
            <li>No backend, implementar <code>POST /pcpoint/buy</code> validando estoque, custo e chamando <code>GDPcPointAddPointSaveSend</code> equivalente antes de inserir o item na fila de entregas.</li>
            <li>Atualizar o HUD exibindo saldo PcPoint ao lado do Zen (use <code>g_pRenderText</code> como referência de posicionamento).</li>
            <li>Registrar logs espelhando <code>LogAddTD</code> para auditoria de compras e recompensas online.</li>
          </ol>
        </details>

      </article>

      <article class="module-category">
        <h3>Sistemas Avançados: Muun, Pentagrama, Helper e PcPoint</h3>
        <table class="matrix">
          <thead>
            <tr>
              <th>Foco</th>
              <th>Referência Legada</th>
              <th>Comportamento Observado</th>
              <th>Adaptação UE5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Companheiros Muun</td>
              <td>
                <code>MuunSystem.cpp</code>, <code>User.cpp</code>, <code>Attack.cpp</code>,<br />
                <code>ServerInfo.cpp</code> (carga de <code>Item\MuunOption.txt</code>)
              </td>
              <td>
                <code>CMuunSystem::Load</code> popula <code>m_MuunSystemInfo</code> e opções adicionais,
                <code>gMuunSystem.MainProc()</code> é chamado no <code>User.cpp</code> para atualizar buffs,
                e <code>Attack.cpp</code> aplica sprites via <code>MuunSprite</code> quando um pet está ativo.
              </td>
              <td>
                Converter <code>Item/MuunOption.txt</code> em <code>Data Tables</code>, criar
                <code>BP_MuunComponent</code> que lê evoluções/ranqueamento e atualizar HUD com os ícones
                originais (<code>NewUIPetInfoWindow.cpp</code> ➝ <code>Interface\newui_pet_*.tga</code>).
              </td>
            </tr>
            <tr>
              <td>Pentagrama &amp; Joias Elementais</td>
              <td>
                <code>PentagramSystem.cpp</code>, <code>Item.cpp</code>, <code>ServerInfo.cpp</code>
                (cargas de <code>Item\Pentagram*.txt</code>)
              </td>
              <td>
                <code>CPentagramSystem::Load</code> carrega tipos, opções e ranks; <code>CItem::IsPentagramItem</code>
                e <code>::IsPentagramJewel</code> consultam o sistema para validar equipáveis e joias elementais.
              </td>
              <td>
                Criar <code>DT_PentagramTypes</code>/<code>DT_PentagramJewels</code>, um <code>BP_PentagramComponent</code>
                que processa slots elementais e UI dedicada reutilizando o layout de <code>NewUIItemMng</code>.
              </td>
            </tr>
            <tr>
              <td>Mu Helper / Auto-caça</td>
              <td>
                <code>Helper.cpp</code>, <code>ServerInfo.cpp</code> (<code>HelperSwitch</code>, <code>HelperActiveMoney*</code>),
                <code>NewUIMoveCommandWindow.cpp</code>
              </td>
              <td>
                <code>CHelper::MainProc</code> debita Zen periodicamente, valida mapas permitidos e envia
                <code>GCHelperStartSend</code>; o cliente habilita toggles no menu de comandos (Move Command Window).
              </td>
              <td>
                Expor <code>BP_HelperSubsystem</code> com estados e custos sincronizados via REST/WebSocket,
                reconstruir o painel com os botões originais (texturas <code>Interface\newui_command.jpg</code>) e automatizar
                comportamentos usando <code>Behavior Trees</code> equivalentes.
              </td>
            </tr>
            <tr>
              <td>Pontos PcPoint &amp; Loja de Fidelidade</td>
              <td>
                <code>PcPoint.cpp</code>, <code>CashShop.cpp</code>, <code>ServerInfo.cpp</code>
                (carga de <code>PcPoint.txt</code>), <code>NewUIPurchaseShopInventory.cpp</code>
              </td>
              <td>
                <code>CPcPoint::Load</code> converte itens em recompensas com sockets/opções; compra via
                <code>CGPcPointItemBuyRecv</code> valida saldo e chama <code>GDPcPointAddPointSaveSend</code> para persistir.
              </td>
              <td>
                Recriar catálogos em <code>DT_PcPointShop</code>, implementar <code>PcPointService</code> que replica as mesmas
                validações antes de consumir saldo e montar um widget UMG inspirado em <code>NewUIPurchaseShopInventory</code>.
              </td>
            </tr>
          </tbody>
        </table>

        <details class="guia" open>
          <summary>Passo a passo — Muun e Pentagrama</summary>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/MuunSystem.cpp</code></div>
            <pre><code>info.Index = lpMemScript->GetNumber();
info.Type = lpMemScript->GetAsNumber();
info.Rank = lpMemScript->GetAsNumber();
info.OptionIndex = lpMemScript->GetAsNumber();
info.EvolutionItemIndex = lpMemScript->GetAsNumber();
this->m_MuunSystemInfo.insert(std::make_pair(info.Index, info));</code></pre>
          </div>
          <ol>
            <li>Extrair <code>Item/MuunOption.txt</code> e <code>Item/MuunEvolution.txt</code> (se disponível) com o script do diretório <code>tools/</code> gerando CSVs preservando <em>Index</em>, <em>Rank</em>, <em>OptionIndex</em>.</li>
            <li>Importar para a UE5 como <code>Primary Data Assets</code> (<code>FMuunDefinition</code>) e criar <code>BP_MuunComponent</code> anexado ao personagem; ler os dados no <code>BeginPlay</code> para spawnar companions usando <code>Niagara</code> equivalente a <code>MuunSprite</code>.</li>
            <li>Converter texturas de <code>NewUIPetInfoWindow::LoadImages()</code> (<code>Interface\newui_pet_lifebar01.jpg</code>, <code>newui_item_table*.tga</code>) para <code>.png</code> e posicionar num <code>WBP_MuunPanel</code> com o mesmo offset <code>(x+12, y+48)</code>.</li>
            <li>No backend, mapear endpoints <code>/companion/equip</code>, <code>/companion/feed</code> replicando as validações de <code>MuunSystem.cpp</code> (mapas permitidos, evolução por <code>EvolutionItemIndex</code>).</li>
          </ol>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/PentagramSystem.cpp</code></div>
            <pre><code>gPentagramSystem.Load(gPath.GetFullPath("Item\PentagramOption.txt"));
gPentagramSystem.LoadJewel(gPath.GetFullPath("Item\PentagramJewelOption.txt"));
gPentagramSystem.LoadMixRate(gPath.GetFullPath("Item\PentagramJewelMixRate.txt"));</code></pre>
          </div>
          <ol>
            <li>Gerar <code>DT_PentagramOption</code> e <code>DT_PentagramJewel</code> com colunas idênticas às seções 0/1 do script original (Type, Rank, Level, OptionValue).</li>
            <li>Na UE5, criar um <code>BP_PentagramInventory</code> com <code>Array</code> de <code>FPentagramSlot</code> (Elemento, Nível, Rank) e UI que permite inserir joias com <em>Drag &amp; Drop</em> baseado em <code>CNewUIInventoryCtrl</code>.</li>
            <li>O backend deve validar combinações utilizando as mesmas tabelas carregadas por <code>CPentagramSystem</code>, calculando taxas de sucesso conforme <code>PentagramJewelMixRate.txt</code>.</li>
            <li>Reproduzir o dano elemental chamando <code>ApplyGameplayEffect</code> usando os multiplicadores retornados pelo serviço, assim como o servidor legado consulta <code>GetPentagramDamage()</code>.</li>
          </ol>
        </details>

        <details class="guia">
          <summary>Passo a passo — Helper e PcPoint</summary>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/Helper.cpp</code></div>
            <pre><code>if((GetTickCount()-lpObj->HelperDelayTime) >= gServerInfo.m_HelperActiveDelay*60000)
{
        lpObj->Money -= (lpObj->Level+lpObj->MasterLevel)*gServerInfo.m_HelperActiveMoney[HelperStage];
        GCMoneySend(lpObj->Index,lpObj->Money);
        this->GCHelperStartSend(lpObj->Index,((GetTickCount()-lpObj->HelperTotalTime)/60000), ...);
}</code></pre>
          </div>
          <ol>
            <li>Mapear para <code>Config/ServerInfo.ini</code> os mesmos parâmetros <code>HelperSwitch</code>, <code>HelperActiveLevel</code> e <code>HelperActiveMoney*</code>. O microserviço UE5 deve aplicar os débitos e limites de mapa antes de habilitar o modo automático.</li>
            <li>Construir <code>WBP_HelperPanel</code> inspirado em <code>NewUIMoveCommandWindow.cpp</code> reutilizando <code>Interface\newui_command.jpg</code>; os toggles disparam eventos em <code>BP_HelperSubsystem</code> para iniciar/parar rotinas de IA (<code>Behavior Tree</code> customizado).</li>
            <li>Reaproveitar <code>gServerInfo.m_HelperActiveMoney</code> para exibir o custo em Zen por estágio, atualizando via WebSocket quando o servidor enviar <code>HelperStart</code>/<code>HelperStop</code>.</li>
            <li>Para PcPoint, carregar <code>PcPoint.txt</code> e reconstruir a vitrine com <code>WBP_PcPointShop</code> refletindo a grade de <code>NewUIPurchaseShopInventory</code> (slots 8x4 em <code>(x+16, y+90)</code>).</li>
          </ol>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/PcPoint.cpp</code></div>
            <pre><code>int ItemIndex = SafeGetItem(GET_ITEM(lpMemScript->GetNumber(),lpMemScript->GetAsNumber()));
int Socket1 = lpMemScript->GetAsNumber();
...
this->InsertItemNew(ItemIndex, ItemLevel, ItemDurability, ..., Socket5, ItemValue);</code></pre>
          </div>
          <ol>
            <li>Criar um conversor que transforme cada linha de <code>PcPoint.txt</code> em <code>FPcPointItemRow</code> (ItemIndex, Level, Options, Value) preservando sockets e opções excelentes.</li>
            <li>No backend, implementar <code>POST /pcpoint/buy</code> validando estoque, custo e chamando <code>GDPcPointAddPointSaveSend</code> equivalente antes de inserir o item na fila de entregas.</li>
            <li>Atualizar o HUD exibindo saldo PcPoint ao lado do Zen (use <code>g_pRenderText</code> como referência de posicionamento).</li>
            <li>Registrar logs espelhando <code>LogAddTD</code> para auditoria de compras e recompensas online.</li>
          </ol>
        </details>
      </article>

      <article class="module-category">
        <h3>Infraestrutura de Servidores MuServer</h3>
        <table class="matrix">
          <thead>
            <tr>
              <th>Componente</th>
              <th>Referência Legada</th>
              <th>Responsabilidade</th>
              <th>Estratégia de Adaptação</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>ConnectServer</td>
              <td><code>ConnectServer/ConnectServer.cpp</code></td>
              <td>Inicia sockets TCP/UDP, lê <code>ConnectServer.ini</code>, autentica via <code>gProtect.StartAuth</code> e divulga <code>ServerList.dat</code>.</td>
              <td>Implemente serviço gateway HTTP/UDP que carrega lista de shards do banco e distribui tokens de sessão para o cliente UE5.</td>
            </tr>
            <tr>
              <td>JoinServer</td>
              <td><code>JoinServer/JoinServer.cpp</code></td>
              <td>Valida conta com ODBC, sincroniza com ConnectServer e respeita <code>CaseSensitive</code>/<code>MD5Encryption</code>.</td>
              <td>Crie microserviço de autenticação que reutiliza hash legado e retorna <code>sessionId</code> + lista de personagens.</td>
            </tr>
            <tr>
              <td>DataServer</td>
              <td><code>DataServer/DataServer.cpp</code>, <code>QueryManager</code></td>
              <td>Abre conexão ODBC, carrega <code>AllowableIpList</code>, processa guilds, armazenando dados persistentes.</td>
              <td>Substitua por API persistente (ex.: gRPC/REST) com pool de conexões e whitelist IP equivalente.</td>
            </tr>
            <tr>
              <td>GameServer</td>
              <td><code>GameServer/GameServer.cpp</code>, <code>GameMain.cpp</code></td>
              <td>Carrega configurações, conecta a Join/Data, cria timers (<code>gQueueTimer</code>) para AI, eventos e matchmaking.</td>
              <td>Modele <code>GameCoordinator</code> que agenda jobs (AI/Event) em fila de tarefas e expõe WebSocket/HTTP para o cliente UE5.</td>
            </tr>
            <tr>
              <td>Protocolos</td>
              <td><code>Protocol.cpp</code>, <code>JSProtocol.cpp</code>, <code>DSProtocol.cpp</code></td>
              <td>Define pacotes binários, IDs (0xF1, 0x23 etc.) e roteia mensagens entre camadas.</td>
              <td>Documente contratos REST/WebSocket equivalentes mantendo códigos/estados legados para minimizar reimplementação no cliente.</td>
            </tr>
          </tbody>
        </table>

        <details class="guia" open>
          <summary>Sequência de Login Recomendada</summary>
          <ol>
            <li><strong>UE5 ➝ Gateway:</strong> solicita lista de servidores (ConnectServer) e recebe <code>sessionToken</code>.</li>
            <li><strong>UE5 ➝ Auth:</strong> envia credenciais; microserviço reproduz validação <code>MD5Encryption</code>/<code>CaseSensitive</code> e retorna <code>accountId</code>.</li>
            <li><strong>UE5 ➝ GameCoordinator:</strong> inicia handshake WebSocket inspirado em <code>Protocol.cpp</code> e recebe personagens.</li>
            <li><strong>Persistência:</strong> operações de inventário, quest e guild vão ao serviço equivalente ao DataServer garantindo transações ACID.</li>
          </ol>
        </details>
      </article>
    </section>

    <section id="modulos-expandido">
      <h2>Matriz Expandida de Módulos para Migração UE5</h2>
      <p>
        O levantamento a seguir complementa o atlas principal com módulos adicionais identificados no
        cliente (<code>Source Main 5.2/source</code>) e nos servidores
        (<code>MuServer_Season_5_Update_15</code>). Use esta matriz para aprofundar o estudo do projeto
        original e planejar Blueprints, serviços e dados necessários durante a recriação completa na
        Unreal Engine 5.
      </p>
      <div class="module-matrix">
        <article class="module-category">
          <h3>Social &amp; Progressão Cooperativa</h3>
          <ul class="module-list">
            <li>
              <strong>Guildas e Diplomacia</strong> — <code>GuildManager.cpp</code>, <code>GuildCache.cpp</code>,
              <code>NewUIGuildInfoWindow.cpp</code>, <code>UISenatus.cpp</code>.
              Estruture um <code>UGuildSubsystem</code> com replicação de dados e widgets UMG para gestão
              de emblemas, ranks e guerra de guildas.
            </li>
            <li>
              <strong>Party &amp; Amigos</strong> — <code>PartyManager.cpp</code>, <code>NewUIPartyListWindow.cpp</code>,
              <code>NewUIPartyInfoWindow.cpp</code>, <code>NewUIFriendWindow.cpp</code>.
              Replique convites e quick-actions usando o <code>Gameplay Message Router</code> e crie
              Blueprints de notificação reutilizando ícones originais.
            </li>
            <li>
              <strong>Gens &amp; Rivalidade</strong> — <code>GensSystem.cpp</code>, <code>Viewport.cpp</code>
              (<code>GCViewportGensSystemSend</code>), <code>Guild.cpp</code>, <code>NpcTalk.cpp</code>
              (stewards Duprian/Varnert) e widgets <code>NewUIGensRanking.cpp</code>.
              Garanta Data Tables com contribuições, ranks e bloqueios de guild/party conforme
              <code>ServerInfo.h</code> (<code>m_GensSystem*</code>) para que o backend UE5 aplique
              recompensas equivalentes.
            </li>
            <li>
              <strong>Rankings &amp; Competitivo</strong> — <code>NewUIGensRanking.cpp</code>,
              <code>NewUIBattleSoccerScore.cpp</code>, <code>GMBattleCastle.cpp</code>.
              Modele serviços de leaderboard (REST/GraphQL) e widgets de ranking com atualizações
              periódicas em <code>Tick</code> ou timers assíncronos.
            </li>
          </ul>
        </article>
        <article class="module-category">
          <h3>Eventos &amp; Conteúdo Sazonal</h3>
          <ul class="module-list">
            <li>
              <strong>Castelos &amp; Dungeons</strong> — <code>CSChaosCastle.cpp</code>, <code>NewUIBloodCastleEnter.cpp</code>,
              <code>NewUICryWolf.cpp</code>, <code>GMEmpireGuardian1.cpp</code>-<code>4.cpp</code>.
              Separe lógica em <code>Game Feature Plugins</code> com tabelas de regras vindas de
              <code>Data/Event</code> e <code>GameServerInfo - Event.dat</code>.
            </li>
            <li>
              <strong>Instâncias Temporais</strong> — <code>GMDoppelGanger1.cpp</code>-<code>4.cpp</code>,
              <code>NewUICursedTempleSystem.cpp</code>, <code>NewUIDoppelGangerWindow.cpp</code>.
              Crie mapas dedicados com <code>Level Streaming</code> e controladores configurados via <code>Data Tables</code> de horário.
            </li>
            <li>
              <strong>Scripts de Evento</strong> — diretórios <code>Data/Event/</code>, <code>Data/EventItemBag/</code>,
              <code>Data/Custom/Event</code>.
              Automatize a conversão destes arquivos para <code>JSON</code>/<code>CSV</code> e gere testes que validem
              drops antes de publicar patches.
            </li>
          </ul>
        </article>
        <article class="module-category">
          <h3>Habilidades, Buffs &amp; Efeitos</h3>
          <ul class="module-list">
            <li>
              <strong>Dados de Habilidades</strong> — <code>SkillManager.cpp</code>, <code>SkillInfo.cpp</code>,
              <code>SkillEffectMgr.cpp</code>, <code>GameServer/DATA/GameServerInfo - Skill.dat</code>.
              Migre para o <code>Gameplay Ability System</code> com <code>Data Assets</code> descrevendo custo,
              cooldown e efeitos visuais Niagara.
            </li>
            <li>
              <strong>Sistema de Buffs</strong> — <code>w_BuffStateSystem.cpp</code>, <code>w_BuffTimeControl.cpp</code>,
              <code>NewUIBuffWindow.cpp</code>.
              Converta em <code>Attribute Sets</code> + <code>Gameplay Effects</code> e widgets reativos usando o mesmo
              layout da HUD original.
            </li>
            <li>
              <strong>Interface de Comandos</strong> — <code>NewUICommandWindow.cpp</code>, <code>NewUIHotKey.cpp</code>,
              <code>Slider.cpp</code>.
              Utilize <code>Enhanced Input</code> e <code>Input Mapping Contexts</code> para permitir rebinds de skills
              preservando a disposição do layout legado.
            </li>
          </ul>
        </article>
        <article class="module-category">
          <h3>Pets, Montarias &amp; Summons</h3>
          <ul class="module-list">
            <li>
              <strong>Controle de Mascotes</strong> — <code>CSPetSystem.cpp</code>, <code>SummonSystem.cpp</code>,
              arquivos <code>w_PetAction*.cpp</code>.
              Estruture <code>Actor Components</code> para comportamento, HUD dedicada e IA usando
              <code>Behavior Trees</code> reutilizando animações originais (.bmd).
            </li>
            <li>
              <strong>Interface de Pets</strong> — <code>NewUIPetInfoWindow.cpp</code>, <code>NewUIHeroPositionInfo.cpp</code>.
              Refaça em UMG com bindings para atributos provenientes do backend e indicadores de buffs.
            </li>
            <li>
              <strong>Itens de Evolução</strong> — <code>MixMgr.cpp</code>, <code>NewUIMixInventory.cpp</code>,
              <code>Data/Item/</code> (mix, evoluções).
              Planeje <code>Blueprint Function Libraries</code> para combinações e verificação de materiais.
            </li>
          </ul>
        </article>
        <article class="module-category">
          <h3>Economia, Trade &amp; Serviços</h3>
          <ul class="module-list">
            <li>
              <strong>Troca Direta</strong> — <code>NewUITrade.cpp</code>, <code>NewUIWindowMenu.cpp</code>,
              <code>ProtocolSend.cpp</code> (pacotes de trade).
              Modelar API transacional com confirmações em duas etapas e validar itens usando <code>Gameplay Tags</code>.
            </li>
            <li>
              <strong>Loja Pessoal &amp; Cash</strong> — <code>NewUIMyShopInventory.cpp</code>,
              <code>NewUIPurchaseShopInventory.cpp</code>, <code>PersonalShopTitleImp.cpp</code>, diretório <code>Data/CashShop/</code>.
              Recrie vitrines em UMG e conecte a serviços de pagamento seguros, incluindo pré-visualização 3D.
            </li>
            <li>
              <strong>Serviços de NPC</strong> — <code>NpcTalk.cpp</code>, <code>Shop.cpp</code>,
              <code>QuestWorld.cpp</code>, planilhas em <code>Data/Shop/</code>, <code>Data/Quest/</code> e <code>Data/QuestWorld/</code>.
              Reconstrua diálogos, listas de itens e requisitos convertendo estas tabelas para <code>Data Tables</code>
              e conectando widgets UMG a microserviço de NPC.</li>
            <li>
              <strong>Ferramentas de Administração</strong> — <code>Tools/MuEditor MuEmu</code>, scripts <code>ScriptSql/</code>,
              logs em <code>GameServer/LOG</code>.
              Planeje painéis web ou dashboards no Unreal Insights para monitorar economia e ajustar tabelas sem downtime.
            </li>
          </ul>
        </article>
        <article class="module-category">
          <h3>Infraestrutura &amp; Segurança</h3>
          <ul class="module-list">
            <li>
              <strong>Anticheat &amp; Monitoramento</strong> — <code>MHPServer/</code>, <code>Hack/</code>,
              <code>ProtectSysKey.cpp</code>.
              Substitua por serviços modernos de monitoramento, registrando telemetria via <code>Gameplay Event Router</code>.
            </li>
            <li>
              <strong>Painel de Opções</strong> — <code>NewUIOptionWindow.cpp</code>, <code>NewUIHotKey.cpp</code>,
              <code>NewUIMoveCommandWindow.cpp</code>.
              Migre sliders, toggles e atalhos para Common UI + <code>Enhanced Input</code>, persistindo valores
              com <code>USaveGame</code> e replicando limites de câmera/som.</li>
            <li>
              <strong>Comandos Slash</strong> — <code>CommandManager.cpp</code>, <code>Command.cpp</code>,
              <code>Data/Command.txt</code>.
              Recrie <code>ChatCommandService</code> validando níveis de permissão (GM, master, party leader)
              e exponha eventos blueprint para macros e automações.</li>
            <li>
              <strong>Certificação &amp; Launcher</strong> — <code>GCCertification.cpp</code>, <code>LauncherHelper.cpp</code>.
              Integre verificação de build com pipeline CI/CD e exponha status no menu inicial UE5.
            </li>
            <li>
              <strong>Scripts de Inicialização</strong> — diretório <code>StartUp/</code>, arquivos <code>*.bat</code>.
              Converta para automações (Docker/PowerShell) e registre dependências em documentação viva.
            </li>
          </ul>
        </article>
      </div>
    </section>

    <section id="catalogo-modulos">
      <h2>Catálogo Completo de Módulos Legados e Estratégia de Migração UE5</h2>
      <p>
        Utilize este catálogo como checklist central. Cada cartão resume onde localizar o código ou dado
        original, qual responsabilidade o módulo cobre e quais passos seguir para reconstruí-lo no
        ecossistema UE5 reaproveitando os assets. A ordem recomendada acompanha o fluxo natural de um
        jogador: autenticar, escolher personagens, entrar no mundo, interagir com sistemas e consumir
        serviços de backend.
      </p>

      <details class="catalog-group" open>
        <summary>Frontend — Interfaces Essenciais (UMG, CommonUI)</summary>
        <p>
          Foque primeiro em telas que sustentam a jornada do usuário. As etapas abaixo descrevem como
          reciclar fundos, tipografia e scripts originais enquanto se integra ao gateway HTTP/JSON já
          planejado neste guia.
        </p>
        <div class="catalog-grid">
          <div class="catalog-card">
            <h4>Tela de Login &amp; Launcher</h4>
            <p class="path"><strong>Legado:</strong> <code>LoginMainWin.cpp</code>, <code>LoginWin.cpp</code>, <code>GCCertification.cpp</code>, <code>LauncherHelper.cpp</code>, assets em <code>Source Main 5.2/bin/Data/Interface/Login</code>.</p>
            <p><strong>Objetivo:</strong> Autenticar contas reaproveitando o layout clássico e validando versão/patch antes de liberar acesso.</p>
            <ol class="step-list">
              <li>Extraia fundos (.jpg/.ozj) e botões originais, convertendo-os para <code>.uasset</code> via <em>Import as Slate Brush</em>.</li>
              <li>Construa <code>WBP_Login</code> com <code>Canvas Panel</code> usando as coordenadas antigas; fixe campos de conta/senha com <code>Retainer Box</code> para suavizar fontes.</li>
              <li>Implemente <code>UBlueprintFunctionLibrary::SendLogin</code> chamando o serviço <code>ConnectServer</code> &rarr; <code>JoinServer</code> através do gateway HTTP criado na seção de backend.</li>
              <li>Valide status de patch comparando o hash em <code>resource.rc</code> com a versão publicada pelo backend antes de habilitar o botão “Jogar”.</li>
              <li>Encapsule mensagens de erro em <code>CommonUI::UCommonBorder</code> para reaproveitar ícones de aviso originais.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>ConnectServer</code> (handshake), tabela <code>Data/Connect.ini</code>, endpoints REST <code>/auth/login</code> e <code>/patch/status</code>.</p>
          </div>
          <div class="catalog-card">
            <h4>Seleção &amp; Criação de Personagem</h4>
            <p class="path"><strong>Legado:</strong> <code>CharSelMainWin.cpp</code>, <code>CharMakeWin.cpp</code>, <code>ServerSelWin.cpp</code>, <code>CharacterManager.cpp</code>.</p>
            <p><strong>Objetivo:</strong> Replicar o carrossel 3D, limites por classe e slots adicionais.</p>
            <ol class="step-list">
              <li>Converta o cenário estático da seleção (BMD/TGA) para <code>Level Sequence</code> curto com luzes originais.</li>
              <li>Monte <code>WBP_CharacterSelect</code> com <code>CommonTabList</code> para alternar entre personagens e <code>Viewport</code> exibindo <code>BP_CharacterPreview</code>.</li>
              <li>Consuma o endpoint <code>/characters/list</code> (JoinServer) preenchendo slots com dados recebidos.</li>
              <li>Para criação, importe silhuetas (<code>CharMakeWin</code>) e construa formulários validando nome/ocupação com as listas definidas em <code>DataServer/CharacterCreate.sql</code>.</li>
              <li>Sincronize animações idles originais via <code>Animation Blueprint</code> dedicado, garantindo que cada classe carregue a mesma pose do cliente legado.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>JoinServer</code> (lista de personagens), <code>GameServer</code> (slots extras), assets BMD convertidos para <code>SK_</code>.</p>
          </div>
          <div class="catalog-card">
            <h4>HUD Principal &amp; Barra de Status</h4>
            <p class="path"><strong>Legado:</strong> <code>NewUIMainFrameWindow.cpp</code>, <code>CGFxMainUi.cpp</code>, <code>GaugeBar.cpp</code>, <code>NewUIRenderNumber.cpp</code>.</p>
            <p><strong>Objetivo:</strong> Recriar a HUD com barras de HP/MP/AG, mini-status e slots rápidos.</p>
            <ol class="step-list">
              <li>Importe texturas da HUD (sprites em <code>Source Main 5.2/bin/Data/Interface/MainUI</code>) como <code>Texture Atlas</code> e configure <code>UPaperSprite</code> para indicadores.</li>
              <li>Crie <code>WBP_HUDRoot</code> com <code>Canvas Panel</code>; posicione elementos usando coordenadas da matriz de HUD anexada anteriormente.</li>
              <li>Implemente <code>UPlayerAttributeComponent</code> para expor HP/MP/AG/SD e utilize <code>Binding</code> ou <code>Field Notify</code> em widgets.</li>
              <li>Reaplique efeitos numéricos com <code>UMaterialInstanceDynamic</code> replicando <code>NewUIRenderNumber</code>.</li>
              <li>Integre barra de experiência mestre com dados do endpoint <code>/progress/master</code> conforme lógica de <code>NewUIMasterLevel.cpp</code>.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> Componentes de atributos do player, <code>Gameplay Ability System</code>, fluxos de XP documentados na etapa de progressão.</p>
          </div>
          <div class="catalog-card">
            <h4>Inventário, Equipamentos &amp; Tooltips</h4>
            <p class="path"><strong>Legado:</strong> <code>NewUIMyInventory.cpp</code>, <code>NewUIInventoryCtrl.cpp</code>, <code>NewUIItemExplanationWindow.cpp</code>, <code>NewUIItemEnduranceInfo.cpp</code>.</p>
            <p><strong>Objetivo:</strong> Permitir arrastar/soltar itens, visualizar atributos e integrar sockets.</p>
            <ol class="step-list">
              <li>Transfira sprites de slots (<code>Source Main 5.2/bin/Data/Interface/Inventory</code>) e defina <code>Size Box</code> correspondentes a 20x20px conforme <code>INVENTORY_SQUARE_WIDTH</code>/<code>HEIGHT</code>.</li>
              <li>Monte <code>WBP_Inventory</code> com <code>UniformGridPanel</code>; configure mapeamento de índices baseado nos offsets de <code>NewUIInventoryCtrl</code>.</li>
              <li>Implemente <code>BP_ItemDrag</code> derivado de <code>CommonActivatableWidget</code> para suportar drag/drop com verificação de colisão via <code>Blueprint Function Library</code>.</li>
              <li>Renderize tooltips reutilizando a lógica convertida em “Sistema Completo de Itens” (seção anterior) para combinar dados de <code>ItemInfo.cpp</code> e <code>ItemAddOptioninfo.cpp</code>.</li>
              <li>Sincronize persistência chamando <code>/inventory/sync</code> no backend após cada alteração e armazenando em <code>Gameplay Save Game</code> em caso offline.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>ItemManager.cpp</code>, tabelas <code>Data/Item/*.txt</code>, endpoints <code>GameServer</code> para inventário.</p>
          </div>
          <div class="catalog-card">
            <h4>Chat, Social &amp; Notificações</h4>
            <p class="path"><strong>Legado:</strong> <code>NewUIChatLogWindow.cpp</code>, <code>NewUIChatInputBox.cpp</code>, <code>NewUIFriendWindow.cpp</code>, <code>NewUICommandWindow.cpp</code>.</p>
            <p><strong>Objetivo:</strong> Restaurar chat global, party, guild e atalhos de comando.</p>
            <ol class="step-list">
              <li>Importe ícones de canais e fontes definidas em <code>GlobalText.h</code>, convertendo-as para <code>Composite Font Assets</code>.</li>
              <li>Crie <code>WBP_ChatDock</code> com abas (<code>CommonTabList</code>) para canalizar mensagens.</li>
              <li>Implemente serviço WebSocket em <code>UGameInstanceSubsystem</code> ouvindo <code>GameServer</code> &rarr; <code>ChatService</code>.</li>
              <li>Mapeie comandos (ex: <code>/move</code>, <code>/post</code>) em tabela <code>Data/Commands.csv</code> e execute via <code>Gameplay Message Router</code>.</li>
              <li>Exiba notificações usando <code>CommonNotificationQueue</code> reaproveitando sons <code>DSplaysound.cpp</code>.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> Serviços de chat em <code>GameServer/Protocols</code>, <code>PartyManager.cpp</code>, <code>GuildManager.cpp</code>.</p>
          </div>
          <div class="catalog-card">
            <h4>MiniMapa &amp; Guias de Navegação</h4>
            <p class="path"><strong>Legado:</strong> <code>NewUIMiniMap.cpp</code>, <code>MapManager.cpp</code>, <code>NewUIMapName.cpp</code>, recursos <code>Data/Map</code>.</p>
            <p><strong>Objetivo:</strong> Reproduzir minimapa, nomes de regiões e marcadores de eventos.</p>
            <ol class="step-list">
              <li>Converta texturas <code>.ozb</code> dos mapas para <code>.png</code> e importe como <code>UMaterialInstance</code> para um <code>RetainerBox</code>.</li>
              <li>Implemente <code>BP_MinimapController</code> lendo offsets de <code>MapManager</code> e aplicando-os ao <code>Canvas</code>.</li>
              <li>Crie sistema de marcadores (party, NPC, objetivos) utilizando <code>Slate Vector Image</code> com assets originais.</li>
              <li>Integre com <code>Level Streaming</code> para mostrar nomes de subzonas usando <code>Data Table</code> derivada de <code>MapManager.h</code>.</li>
              <li>Sincronize eventos (boss, invasões) através de <code>Gameplay Tags</code> enviados pelo backend de eventos.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>CSMapServer.cpp</code>, arquivos <code>Data/EventMap/*.txt</code>, serviço de eventos do <code>GameServer</code>.</p>
          </div>
        </div>
      </details>

      <details class="catalog-group">
        <summary>Frontend — Sistemas de Jogo (Blueprints &amp; Data Assets)</summary>
        <p>
          Depois das interfaces, alinhe sistemas de jogabilidade reutilizando dados de <code>Item</code>,
          <code>Skill</code> e <code>Event</code>. Cada item abaixo aponta para scripts legados e descreve o
          passo a passo para erguê-los com <code>Gameplay Ability System</code>, <code>Actor Components</code> e
          <code>Data Tables</code> em UE5.
        </p>
        <div class="catalog-grid">
          <div class="catalog-card">
            <h4>Sistema de Itens &amp; Opções</h4>
            <p class="path"><strong>Legado:</strong> <code>ItemManager.cpp</code>, <code>ItemInfo.cpp</code>, <code>ItemAddOptioninfo.cpp</code>, <code>NewUISetItemExplanation.cpp</code>.</p>
            <p><strong>Objetivo:</strong> Unificar base de dados e lógicas de combinação/opções excelentes.</p>
            <ol class="step-list">
              <li>Converter <code>Item.txt</code>, <code>ItemOption.txt</code> em <code>Data Tables</code> (Struct derivada de <code>FItemDefinition</code>).</li>
              <li>Construir <code>BP_ItemDefinition</code> (Data Asset) contendo meshes, materiais convertidos de <code>Data/ItemBMD</code>.</li>
              <li>Recriar lógica de opções excelentes em <code>Gameplay Effects</code> aplicados durante a equipação.</li>
              <li>Implementar Blueprint <code>BP_ItemFactory</code> que referencia <code>ItemManager</code> convertido, garantindo atributos padrão, durabilidade e socket.</li>
              <li>Validar combinações com unit tests em <code>Functional Testing</code> usando cenários do legado (<code>MixMgr.cpp</code>).</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> Banco de dados <code>Data/Item</code>, endpoints <code>/items/search</code>, blueprint de inventário.</p>
          </div>
          <div class="catalog-card">
            <h4>Drop, Colisão &amp; Loot</h4>
            <p class="path"><strong>Legado:</strong> <code>ZzzCharacter.cpp</code>, <code>ZzzAI.cpp</code>, <code>MapManager.cpp</code>, <code>EventItemBag</code>.</p>
            <p><strong>Objetivo:</strong> Manter taxas de drop e regras de colisão originais.</p>
            <ol class="step-list">
              <li>Converta tabelas <code>ItemBag</code>/<code>MonsterItemDrop</code> em <code>Curve Tables</code> para controlar probabilidades.</li>
              <li>Configure <code>BP_LootActor</code> com <code>Sphere Collision</code> igual ao raio definido em <code>MapManager</code>.</li>
              <li>Implemente <code>Gameplay Cue</code> para efeitos de drop reutilizando <code>ZzzEffect.cpp</code>.</li>
              <li>Sincronize coleta com backend via <code>/drop/pick</code>, respeitando validações do <code>GameServer</code>.</li>
              <li>Automatize testes de taxa rodando simulações (PIE) com 1.000 kills comparando com valores originais.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>GameServer/ItemDrop.cpp</code>, tabelas <code>Data/EventItemBag</code>, blueprint de inventário.</p>
          </div>
          <div class="catalog-card">
            <h4>Progressão, XP &amp; Quests</h4>
            <p class="path"><strong>Legado:</strong> <code>NewUIMasterLevel.cpp</code>, <code>QuestMng.cpp</code>, <code>Event.cpp</code>, <code>CharacterManager.cpp</code>.</p>
            <p><strong>Objetivo:</strong> Reproduzir XP base, mestre, quests e recompensas.</p>
            <ol class="step-list">
              <li>Importe <code>Data/ExperienceTable.txt</code> e <code>Data/MasterTable.txt</code> para <code>CurveFloat</code> controlando XP.</li>
              <li>Crie <code>UGameplayAbility_LevelUp</code> aplicando atributos e desbloqueios com base em <code>QuestMng</code>.</li>
              <li>Implemente <code>QuestSubsystem</code> que consome <code>Data/Quest/*.txt</code> convertidos para <code>Data Assets</code>.</li>
              <li>Reaproveite animações de level up (sons em <code>DSPlaySound</code>) via <code>Gameplay Cue</code>.</li>
              <li>Sincronize com backend (<code>/progress/update</code>) enviando XP, Master XP e estado de quests.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>GameServer/CharacterSystem</code>, endpoints de progressão, HUD principal.</p>
          </div>
          <div class="catalog-card">
            <h4>IA de Mobs &amp; Spawners</h4>
            <p class="path"><strong>Legado:</strong> <code>ZzzAI.cpp</code>, <code>ZzzCharacter.cpp</code>, <code>MonsterAIElement.cpp</code>, <code>Data/Monster</code>, scripts <code>GameServer/Monster</code>.</p>
            <p><strong>Objetivo:</strong> Garantir comportamento, respawn e drops específicos.</p>
            <ol class="step-list">
              <li>Converta <code>Monster.txt</code>, <code>MonsterSetBase.txt</code> em <code>Data Tables</code> definindo stats e mapas.</li>
              <li>Implemente <code>BP_MobSpawner</code> usando <code>Environment Query System</code> replicando áreas <code>MonsterSetBase</code>.</li>
              <li>Crie <code>Behavior Tree</code> baseado em <code>ZzzAI</code> (Idle &rarr; Chase &rarr; Attack &rarr; Return).</li>
              <li>Adapte respawn timer conforme <code>GameServer/MonsterRespawn.cpp</code>, sincronizando com backend via <code>/mob/spawn</code>.</li>
              <li>Integre tabelas de drop configuradas no cartão “Drop, Colisão &amp; Loot”.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>GameServer/Monster</code>, <code>Data/MonsterAI</code>, efeitos de skill.</p>
          </div>
          <div class="catalog-card">
            <h4>Skills, Buffs &amp; Efeitos</h4>
            <p class="path"><strong>Legado:</strong> <code>SkillManager.cpp</code>, <code>SkillInfo.cpp</code>, <code>SkillEffectMgr.cpp</code>, <code>w_BuffStateSystem.cpp</code>, <code>ZzzEffectMagicSkill.cpp</code>.</p>
            <p><strong>Objetivo:</strong> Portar habilidades ativas/passivas e buffs temporários.</p>
            <ol class="step-list">
              <li>Gerar <code>Gameplay Ability</code> por skill usando dados de custo/cooldown convertidos de <code>Skill.dat</code>.</li>
              <li>Configurar <code>Attribute Sets</code> para stats afetados (força, agilidade, velocidade) replicando <code>w_BuffStateSystem</code>.</li>
              <li>Portar efeitos Niagara a partir de <code>ZzzEffect</code> e <code>SkillEffectMgr</code> mantendo cores originais.</li>
              <li>Implementar <code>SkillComboComponent</code> para sequências (ex: combos Blade) usando a lógica de <code>SkillManager</code>.</li>
              <li>Sincronizar aplicação de buffs com backend via <code>/skills/apply</code> para consistência em PvP.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>GameServer/SkillSystem</code>, dados de buff (<code>w_Buff*</code>), HUD para exibir ícones.</p>
          </div>
          <div class="catalog-card">
            <h4>Pets, Montarias &amp; Summons</h4>
            <p class="path"><strong>Legado:</strong> <code>CSPetSystem.cpp</code>, <code>SummonSystem.cpp</code>, <code>w_PetAction*.cpp</code>, <code>NewUIPetInfoWindow.cpp</code>.</p>
            <p><strong>Objetivo:</strong> Restaurar mascotes de suporte, evolução e buffs atrelados.</p>
            <ol class="step-list">
              <li>Converter modelos BMD para <code>SK_</code> com animações originais, configurando <code>AnimBP</code> específico.</li>
              <li>Crie <code>BP_PetComponent</code> que lê dados de <code>Pet.txt</code> convertidos para <code>Data Table</code>.</li>
              <li>Implemente comandos (ataque, coletar, modo automático) com <code>Behavior Tree</code> e <code>Blackboard</code>.</li>
              <li>Recrie janela de status (<code>WBP_PetStatus</code>) exibindo fidelidade, XP e buffs como no legado.</li>
              <li>Persistir estado via <code>/pet/update</code>, respeitando validações de evolução do backend.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>GameServer/PetSystem</code>, inventário, efeitos de skill.</p>
          </div>
          <div class="catalog-card">
            <h4>Eventos, Dungeons &amp; Sistemas Sazonais</h4>
            <p class="path"><strong>Legado:</strong> <code>CSChaosCastle.cpp</code>, <code>NewUIBloodCastleEnter.cpp</code>, <code>GMEmpireGuardian*.cpp</code>, diretório <code>Data/Event</code>.</p>
            <p><strong>Objetivo:</strong> Preservar regras de acesso, timers e recompensas especiais.</p>
            <ol class="step-list">
              <li>Carregue regras de entrada a partir de <code>Event*.txt</code> para <code>Primary Data Assets</code>.</li>
              <li>Crie <code>Game Feature Plugin</code> por evento (Blood Castle, Devil Square, etc.) ativando níveis dedicados.</li>
              <li>Implemente portais com <code>Level Instance</code> e verificações via <code>Gameplay Ability</code> (ticket, nível mínimo).</li>
              <li>Registre cronogramas em <code>Subsystem</code> que consulta <code>/events/schedule</code>.</li>
              <li>Sincronize recompensas utilizando pipeline do inventário para garantir drops corretos.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>GameServer/EventManager</code>, tabelas <code>EventItemBag</code>, HUD para status de evento.</p>
          </div>
        </div>
      </details>

      <details class="catalog-group">
        <summary>Backend — Serviços, Redes &amp; Persistência</summary>
        <p>
          A reconstrução do backend deve manter compatibilidade lógica com os executáveis originais. Use os
          cartões para guiar a criação de microsserviços REST/WebSocket que substituam os servidores
          legados, preservando scripts SQL e verificações críticas.
        </p>
        <div class="catalog-grid">
          <div class="catalog-card">
            <h4>ConnectServer</h4>
            <p class="path"><strong>Legado:</strong> diretório <code>MuServer_Season_5_Update_15/ConnectServer</code>, arquivo <code>ConnectServer.ini</code>.</p>
            <p><strong>Objetivo:</strong> Validar versão e distribuir jogadores entre JoinServers.</p>
            <ol class="step-list">
              <li>Documente endpoints originais (porta 44405) e reimplemente como serviço REST <code>/auth/handshake</code>.</li>
              <li>Implemente verificação de IP, limiar de conexões e mensagens customizadas de versão.</li>
              <li>Sincronize lista de JoinServers via <code>ConfigService</code> central (consumindo <code>ConnectServer_List.dat</code>).</li>
              <li>Expose métricas (latência, capacidade) para o launcher UE5 exibir antes do login.</li>
              <li>Automatize testes com <code>IntegrationTest</code> simulando múltiplas conexões simultâneas.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>StartUp/ConnectServer.bat</code>, banco <code>MuOnline</code> (tabela <code>MEMB_INFO</code>).</p>
          </div>
          <div class="catalog-card">
            <h4>JoinServer &amp; Autenticação</h4>
            <p class="path"><strong>Legado:</strong> <code>MuServer_Season_5_Update_15/JoinServer</code>, <code>JoinServer.cfg</code>, <code>Protocol</code> no cliente (<code>ProtocolSend.cpp</code>).</p>
            <p><strong>Objetivo:</strong> Gerenciar sessão, login simultâneo e seleção de servidor.</p>
            <ol class="step-list">
              <li>Mapeie rotinas de pacote do legado e converta em endpoints <code>/session/start</code>, <code>/session/select-server</code>.</li>
              <li>Implemente geração de token JWT curto substituindo o <em>session key</em> original.</li>
              <li>Armazene sessões em Redis reproduzindo limites definidos em <code>JoinServer.cfg</code>.</li>
              <li>Integre verificação de bloqueio de conta/IP com dados de <code>MEMB_BLOK</code>.</li>
              <li>Notifique GameServers via fila (RabbitMQ/Kafka) imitando <code>JoinServer &rarr; GameServer</code> handshake.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> <code>ConnectServer</code>, banco <code>MuOnline</code>, tabelas de bloqueio.</p>
          </div>
          <div class="catalog-card">
            <h4>GameServer Core</h4>
            <p class="path"><strong>Legado:</strong> <code>MuServer_Season_5_Update_15/GameServer</code> (pastas <code>GameServerInfo</code>, <code>Data</code>), módulos <code>GameServer.cpp</code>, <code>ItemDrop.cpp</code>, <code>SkillSystem</code>.</p>
            <p><strong>Objetivo:</strong> Hospedar lógica de mundo, combate, drops, party e eventos.</p>
            <ol class="step-list">
              <li>Separe responsabilidades em serviços (Combat, Drop, Quest, Event) mantendo esquema de dados original.</li>
              <li>Expose APIs <code>/world/state</code>, <code>/combat/apply</code>, <code>/drops/spawn</code> consumidas por Blueprints.</li>
              <li>Implemente broadcast em tempo real via WebSocket replicando pacotes <code>ProtocolSend</code>.</li>
              <li>Automatize scripts de configuração convertendo arquivos <code>GameServerInfo - *.dat</code> para JSON.</li>
              <li>Incorpore testes de regressão comparando log de dano/drops com arquivos <code>LOG/GameServer</code>.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> JoinServer tokens, banco <code>MuOnline</code>, tabelas <code>GameServerInfo</code>.</p>
          </div>
          <div class="catalog-card">
            <h4>GameServerCS (Castle Siege)</h4>
            <p class="path"><strong>Legado:</strong> diretório <code>GameServerCS</code>, scripts <code>GameServerCS.ini</code>, módulos <code>NewUICastleWindow.cpp</code>.</p>
            <p><strong>Objetivo:</strong> Manter regras específicas de Castle Siege e mercado de registros.</p>
            <ol class="step-list">
              <li>Crie serviço dedicado <code>siege-service</code> sincronizando com banco de guildas.</li>
              <li>Implemente endpoints <code>/siege/register</code>, <code>/siege/status</code>, <code>/siege/rewards</code>.</li>
              <li>Integre com Blueprint <code>BP_SiegeController</code> para ativar portas, traps e horários.</li>
              <li>Mantenha logs de auditoria compatíveis com <code>GameServerCS/LOG</code>.</li>
              <li>Automatize resets semanais seguindo <code>GameServerCS.ini</code>.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> GuildManager, dados de castelo (<code>MuCastle_DATA</code>), eventos.</p>
          </div>
          <div class="catalog-card">
            <h4>DataServer &amp; Banco de Dados</h4>
            <p class="path"><strong>Legado:</strong> <code>MuServer_Season_5_Update_15/DataServer</code>, scripts em <code>DB</code>, <code>ScriptSql</code>.</p>
            <p><strong>Objetivo:</strong> Persistir personagens, inventário, rankings e log de transações.</p>
            <ol class="step-list">
              <li>Normalizar tabelas SQL legadas para esquemas modernos mantendo nomes originais para rastreabilidade.</li>
              <li>Expose repositórios (<code>CharacterRepository</code>, <code>ItemRepository</code>) consumidos por serviços.</li>
              <li>Implemente <code>Change Data Capture</code> para replicar atualizações em tempo real (Kafka/EventBridge).</li>
              <li>Automatize migração inicial executando scripts em <code>ScriptSql</code> via pipeline CI.</li>
              <li>Documente índices críticos (ex: <code>warehouse</code>, <code>Character</code>) para manter performance.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> Banco SQL Server/compatível, ferramentas <code>tools/</code>, endpoints de inventário e progresso.</p>
          </div>
          <div class="catalog-card">
            <h4>MHPServer &amp; Segurança</h4>
            <p class="path"><strong>Legado:</strong> pasta <code>MHPServer</code>, arquivos de configuração <code>MHPServer.ini</code>, código cliente <code>ProtectSysKey.cpp</code>.</p>
            <p><strong>Objetivo:</strong> Substituir anti-hack legado por telemetria moderna.</p>
            <ol class="step-list">
              <li>Catalogar checks existentes (integridade de arquivos, assinatura de memória).</li>
              <li>Implementar serviço <code>security-service</code> expondo <code>/integrity/report</code> consumido por UE5 via <code>HTTP</code>.</li>
              <li>Registrar eventos suspeitos em pipeline de observabilidade (Elastic, Datadog).</li>
              <li>Sincronizar banimentos automáticos com JoinServer/DB replicando ações do legado.</li>
              <li>Disponibilizar dashboards para QA monitorar falsos positivos durante migração.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> Client launcher, JoinServer, tabelas de bloqueio.</p>
          </div>
        </div>
      </details>

      <details class="catalog-group">
        <summary>Dados, Ferramentas &amp; Utilidades de Suporte</summary>
        <p>
          Garanta que os recursos de dados e ferramentas legadas estejam catalogados antes de iniciar
          conversões em massa. Estes cartões orientam a transformação de scripts, assets e utilitários
          para pipelines automatizados compatíveis com UE5.
        </p>
        <div class="catalog-grid">
          <div class="catalog-card">
            <h4>Tabelas &amp; Scripts de Configuração</h4>
            <p class="path"><strong>Legado:</strong> diretório <code>MuServer_Season_5_Update_15/Data</code>, arquivos <code>*.txt</code>, <code>*.xml</code>, <code>*.dat</code>.</p>
            <p><strong>Objetivo:</strong> Centralizar dados de itens, monstros, eventos e economia.</p>
            <ol class="step-list">
              <li>Crie pipeline (Python/Node) que converta cada arquivo em <code>CSV</code>/<code>JSON</code> validando cabeçalhos.</li>
              <li>Versione arquivos convertidos em repositório <code>/DataMigration</code> com testes automatizados.</li>
              <li>Gere <code>Data Tables</code> UE5 automaticamente a partir do JSON usando <code>Editor Utility Widgets</code>.</li>
              <li>Implemente diff automático comparando valores com scripts originais para detectar regressões.</li>
              <li>Documente o mapeamento final no Confluence/Notion compartilhado com equipes.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> Serviços backend (Drop, Skill), Blueprints (Itens, Mobs).</p>
          </div>
          <div class="catalog-card">
            <h4>Scripts SQL &amp; Migração de Banco</h4>
            <p class="path"><strong>Legado:</strong> diretório <code>MuServer_Season_5_Update_15/ScriptSql</code>, pasta <code>DB</code>.</p>
            <p><strong>Objetivo:</strong> Replicar estrutura do banco e dados de referência.</p>
            <ol class="step-list">
              <li>Classifique scripts por domínio (contas, personagens, ranking, loja) e registre dependências.</li>
              <li>Traduza-os para migrações (Flyway/Liquibase) preservando comentários.</li>
              <li>Gere <code>Seed</code> automatizado para dados iniciais (NPC shops, event timers).</li>
              <li>Implemente testes de consistência cruzando contagens com o legado após importação.</li>
              <li>Publicar documentação de colunas críticas para desenvolvedores UE5 consumirem.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> DataServer, GameServer, ferramentas administrativas.</p>
          </div>
          <div class="catalog-card">
            <h4>Ferramentas Internas &amp; Utilitários</h4>
            <p class="path"><strong>Legado:</strong> pasta <code>tools/</code>, <code>Tools/MuEditor MuEmu</code>, clientes de administração.</p>
            <p><strong>Objetivo:</strong> Reaproveitar lógica de edição para suporte UE5.</p>
            <ol class="step-list">
              <li>Inventarie ferramentas que geram scripts (ex: edição de mapa, drop editor).</li>
              <li>Portar as funcionalidades críticas para <code>Editor Utility Widgets</code> ou aplicações web auxiliares.</li>
              <li>Automatizar exportação de assets (ex: sprites) diretamente para o projeto UE5 via <code>Python Editor Scripting</code>.</li>
              <li>Centralizar logs de edição em pipeline Git para rastrear alterações de dados.</li>
              <li>Treinar equipe em novos fluxos assegurando paridade com funcionalidades legadas.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> Equipe de conteúdo, Data Tables, repos de automação.</p>
          </div>
          <div class="catalog-card">
            <h4>Assets 2D/3D &amp; Conversão Técnica</h4>
            <p class="path"><strong>Legado:</strong> <code>Source Main 5.2/source</code> (texturas, BMD), diretório <code>GlobalBitmap</code>, <code>TextureScript.cpp</code>.</p>
            <p><strong>Objetivo:</strong> Converter modelos, animações e sprites mantendo fidelidade.</p>
            <ol class="step-list">
              <li>Mapeie cada asset BMD e associe ao catálogo <code>GlobalBitmap</code> para identificar localização na HUD.</li>
              <li>Use ferramentas (BMD → FBX) garantindo escala correta; aplique materiais equivalentes no UE5.</li>
              <li>Automatize a importação usando <code>Editor Utility</code> que preenche <code>Import Data</code> com coordenadas originais.</li>
              <li>Revise colisões de modelos convertidos comparando com <code>PhysicsManager.cpp</code>.</li>
              <li>Documente assets problemáticos (sem normal map, alpha premultiplicado) e registre soluções.</li>
            </ol>
            <p class="dependency"><strong>Dependências:</strong> HUD, mobs, inventário, eventos visuais.</p>
          </div>
        </div>
      </details>

      <table class="directory-map">
        <thead>
          <tr>
            <th>Diretório / Executável</th>
            <th>Conteúdo Principal</th>
            <th>Plano de Conversão UE5</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>Source Main 5.2/source</code></td>
            <td>UI legacy, controle de inventário, HUD, sistemas de skill, física de cliente.</td>
            <td>Converter para UMG, Actor Components e Gameplay Ability System conforme cartões de Frontend.</td>
          </tr>
          <tr>
            <td><code>MuServer_Season_5_Update_15/GameServer</code></td>
            <td>Lógica de mundo, drops, eventos, IA de monstros.</td>
            <td>Dividir em microsserviços Combat/Drop/Event e expor APIs consumidas pelos Blueprints.</td>
          </tr>
          <tr>
            <td><code>MuServer_Season_5_Update_15/GameServerCS</code></td>
            <td>Castle Siege, rankings especiais, registro de guildas.</td>
            <td>Criar serviço Siege dedicado sincronizado com widgets e fluxos de evento.</td>
          </tr>
          <tr>
            <td><code>MuServer_Season_5_Update_15/DataServer</code></td>
            <td>Persistência SQL, inventário e dados de conta.</td>
            <td>Substituir por camada ORM/Repository com migrações automatizadas.</td>
          </tr>
          <tr>
            <td><code>MuServer_Season_5_Update_15/ConnectServer</code> &amp; <code>JoinServer</code></td>
            <td>Handshakes, autenticação, controle de sessões.</td>
            <td>Migrar para serviços Auth/Session com tokens e escalabilidade horizontal.</td>
          </tr>
          <tr>
            <td><code>MuServer_Season_5_Update_15/MHPServer</code></td>
            <td>Proteção, anti-hack, verificação de cliente.</td>
            <td>Implementar telemetria, integridade e alertas em pipeline moderno de segurança.</td>
          </tr>
          <tr>
            <td><code>MuServer_Season_5_Update_15/Data</code></td>
            <td>Tabelas de monstros, itens, eventos, shops, drop rates.</td>
            <td>Converter para Data Tables/Curve Tables e sincronizar com backend &amp; Blueprints.</td>
          </tr>
          <tr>
            <td><code>MuServer_Season_5_Update_15/ScriptSql</code></td>
            <td>Scripts de criação/população de banco.</td>
            <td>Transformar em migrações versionadas com testes automatizados.</td>
          </tr>
          <tr>
            <td><code>MuServer_Season_5_Update_15/Tools</code></td>
            <td>Utilitários administrativos, editores de dados.</td>
            <td>Portar funcionalidades-chave para Editor Utility Widgets e pipelines CI.</td>
          </tr>
          <tr>
            <td><code>StartUp/*.bat</code></td>
            <td>Ordem de inicialização dos servidores legados.</td>
            <td>Recriar em scripts de infraestrutura (Docker/Compose) documentando dependências.</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="etapas">
      <h2>Etapas Detalhadas e Critérios de Saída</h2>
      <article>
        <h3>Etapa 0 – Preparação e Auditoria</h3>
        <p><strong>Objetivo:</strong> Garantir que o ambiente esteja pronto e todos os assets tenham status definido antes da migração.</p>
        <ul>
          <li>Configurar projeto UE5 (Game Feature Plugins conforme necessidade, Subsystems, Common UI).</li>
          <li>Importar assets de teste para validar pipelines (1 personagem, 1 arma, 1 HUD, 1 mapa pequeno).</li>
          <li>Criar planilha com origem &gt; destino (texturas, materiais, animações, sons, dados CSV/JSON).</li>
          <li>Montar pasta <code>/Game/LegacyImports</code> e subpastas por categoria (Characters, UI, FX...).</li>
          <li>Estabelecer nomeação consistente (prefixos BP_, SK_, UI_, FX_...).</li>
        </ul>
        <div class="callout warning">
          <strong>Atenção:</strong> Se o asset exigir conversão (por exemplo, materiais antigos), documente o esforço estimado antes de prosseguir para evitar gargalos no meio da recriação dos sistemas.
        </div>
      </article>
      <article>
        <h3>Etapa 1 – Núcleo Jogável (HUD + Inventário)</h3>
        <p><strong>Objetivo:</strong> Viabilizar uma experiência jogável mínima com interface responsiva.</p>
        <ol>
          <li><strong>HUD Modular:</strong> converter elementos UI legados em Widgets UMG separados (barra de vida, mana, XP, minimapa).</li>
          <li><strong>Inventário Base:</strong> criar <em>Data Assets</em> ou tabelas de dados com itens originais; gerar Blueprint <code>BP_InventoryManager</code>.</li>
          <li><strong>Input/UI:</strong> utilizar Enhanced Input + Common UI para navegação com teclado/mouse e controle.</li>
          <li><strong>Persistência:</strong> estruturar salvamento temporário em <code>UGameInstance</code> ou <code>USaveGame</code>.</li>
          <li><strong>Verificação:</strong> jogador consegue abrir HUD, equipar, consumir item e ver feedback visual.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Build jogável onde é possível iniciar partida, visualizar HUD completo e manipular inventário sem falhas.
        </div>
      </article>
      <article>
        <h3>Etapa 2 – Sistemas de Progressão (Itens, XP, Drops)</h3>
        <p><strong>Objetivo:</strong> Reimplementar lógica central reaproveitando dados e comportamento já existente.</p>
        <ol>
          <li><strong>Itens:</strong> Criar <code>BP_ItemBase</code> com metadados (tipo, raridade, efeitos) alimentado por <code>Item.txt</code> e <code>ItemOption.txt</code>; gerar <code>WBP_ItemTooltip</code> reproduzindo cores e textos originais.</li>
          <li><strong>Colisão/Renderização:</strong> Implementar <code>BP_ItemInstance</code> com <code>Box Collision</code> e lógica de <em>line trace</em> para repouso seguro, replicando <code>CheckStandAttr</code> do servidor.</li>
          <li><strong>Drops:</strong> Configurar <code>Data Table</code> com tabelas de loot legadas e componente <code>BP_LootSpawner</code>, validando restrições (Lucky, Periodic, mapas especiais) antes de spawnar pickups.</li>
          <li><strong>XP/Nível:</strong> Montar curva de XP (<code>CurveFloat</code>) ou tabela. Implementar <code>BP_ProgressionComponent</code>.</li>
          <li><strong>Balanceamento:</strong> Criar mapa de teste com inimigos representativos e ajustar probabilidades.</li>
          <li><strong>Economia:</strong> Validar integração com moeda/loja se aplicável.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Inimigos derrotados dropam itens corretos, XP sobe conforme curva e jogador atinge nível alvo sem inconsistências.
        </div>
      </article>
      <article>
        <h3>Etapa 3 – Mapas e Conteúdo Jogável</h3>
        <p><strong>Objetivo:</strong> Migrar mapas mantendo navegação, colisões e atmosferas originais.</p>
        <ol>
          <li><strong>Layout:</strong> Usar Level Partitioning/World Composition para mapas extensos. Importar malhas estáticas e colisões personalizadas.</li>
          <li><strong>Navegação:</strong> Regerar NavMesh, volumes de bloqueio, triggers e volumes de respawn.</li>
          <li><strong>Streaming:</strong> Configurar <code>World Partition</code> ou subníveis para iluminação e som.</li>
          <li><strong>Scripts:</strong> Migrar lógica de missões/eventos para <code>Level Blueprint</code> ou <code>Actor Components</code>.</li>
          <li><strong>Testes:</strong> Percorrer cada mapa verificando colisão, iluminação e performance.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Todos os mapas carregam em 30s, sem luzes quebradas, sem buracos de colisão e com triggers funcionais.
        </div>
      </article>
      <article>
        <h3>Etapa 4 – Efeitos, Áudio e Polimento</h3>
        <p><strong>Objetivo:</strong> Restaurar feedback audiovisual e preparar build final.</p>
        <ol>
          <li><strong>VFX:</strong> Atualizar partículas no Niagara reaproveitando texturas/meshes antigos.</li>
          <li><strong>SFX:</strong> Conectar trilhas e sons via <code>MetaSounds</code> ou Sound Cues.</li>
          <li><strong>Iluminação:</strong> Ajustar Lumen, pós-processo e exposição. Validar escalas de lightmaps.</li>
          <li><strong>Performance:</strong> Verificar <em>GPU Visualizer</em>, profiler e ativar LODs/streaming.</li>
          <li><strong>Entrega:</strong> Empacotar build, rodar smoke tests e criar checklist final.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Build final com áudio/visual coerentes, rodando estável dentro das metas de performance definidas na preparação.
        </div>
      </article>
    </section>

    <section id="item-system-encyclopedia">
      <h2>Enciclopédia do Sistema de Itens</h2>
      <p>
        Esta enciclopédia consolida tudo que envolve itens: dados, colisão, drops, exibição na interface,
        sincronização com backend e efeitos associados. Use-a como checklist central para não esquecer
        nenhuma dependência ao migrar para a Unreal Engine 5.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>Fontes de Dados</h3>
          <ul>
            <li><code>Data/Item/Item.txt</code>: definição base (tamanho, tipo, requisitos, dano, durabilidade).</li>
            <li><code>Data/Item/ItemOption.txt</code>, <code>ItemValue.txt</code>, <code>ItemDrop.txt</code>: opções extras, preços e tabelas de drop.</li>
            <li><code>Source Main 5.2/source/ReadScript.h</code>: padrões de parsing para converter em <code>Data Tables</code> UE5.</li>
            <li><code>Source MuServer Update 15/GameServer/Data/</code>: espelha as mesmas informações usadas pelo backend.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Gameplay &amp; Colisão</h3>
          <ul>
            <li><code>Map.cpp</code> (<code>CheckStandAttr</code>, <code>SetAttr</code>): regras para impedir drops em áreas bloqueadas.</li>
            <li><code>ItemManager.cpp</code>: validação de <em>Lucky</em>, periódicos, pets e sockets antes do drop.</li>
            <li><code>MoveCommand.txt</code> e <code>ItemMove.txt</code>: restrições de movimentação (por exemplo, se um item pode ir para o cofre).</li>
            <li>Componentes UE5: <code>BP_LootSpawner</code>, <code>BP_ItemInstance</code>, <code>BP_ItemPickupZone</code> (gatilhos).</li>
          </ul>
        </div>
        <div class="card">
          <h3>Interface &amp; Feedback</h3>
          <ul>
            <li><code>NewUIMyInventory.cpp</code>, <code>NewUIInventoryCtrl.cpp</code>: layout de slots, tooltips, arrasto.</li>
            <li><code>NewUIShop.cpp</code>, <code>NewUIRepair.cpp</code>: reuso de tooltips em loja e reparo.</li>
            <li>Widgets UE5: <code>WBP_Inventory</code>, <code>WBP_ItemTooltip</code>, <code>WBP_ItemSlot</code>, <code>WBP_ItemGhost</code>.</li>
            <li>Áudio/VFX: <code>Item/ItemSound.bmd</code> &rarr; <code>MetaSounds</code>, <code>FX_ItemPickup.uasset</code> adaptado de partículas originais.</li>
          </ul>
        </div>
      </div>
      <h3>Fluxo Integrado</h3>
      <ol>
        <li><strong>Carregar Dados:</strong> Converter arquivos <code>.txt</code> via script Python/C# que gera <code>CSV</code> e importa em <code>DT_ItemDefinitions</code> e <code>DT_ItemDropTables</code>.</li>
        <li><strong>Sincronizar Backend:</strong> Endpoints <code>/items</code> e <code>/loot-tables</code> retornam hash + conteúdo. UE5 guarda <em>cache</em> e solicita apenas se o hash diferir.</li>
        <li><strong>Instanciar Mundo:</strong> <code>BP_LootSpawner</code> escolhe entrada de drop, verifica colisão (line trace + <code>Gameplay Tags</code>) e instancia <code>BP_ItemInstance</code>.</li>
        <li><strong>Atualizar Inventário:</strong> <code>BP_InventoryComponent</code> recebe resposta do servidor, atualiza slots, dispara eventos de UI e registra histórico para <code>WBP_Log</code>.</li>
        <li><strong>Tooltips &amp; Visual:</strong> Widgets renderizam dados formatados, aplicando máscaras originais, ícones e efeitos de raridade.</li>
        <li><strong>Persistir:</strong> Backend confirma operações (drop, pickup, uso, venda) e envia snapshots para <code>POST /inventory/sync</code> garantindo consistência.</li>
      </ol>
      <div class="callout warning">
        <strong>Pontos de Atenção:</strong>
        <ul>
          <li>Itens temporários (<code>m_PeriodicItemTime</code>) precisam de contagem regressiva em ambos os lados; crie <code>FTimerHandle</code> no cliente para feedback visual.</li>
          <li>Itens empilháveis devem respeitar <code>MaxStack</code> dos dados originais. Implemente validação tanto no <code>BP_InventoryComponent</code> quanto no endpoint.</li>
          <li>Itens com sockets/ancient exigem camadas extras de tooltip; prepare <code>Widget Switcher</code> para essas seções.</li>
          <li>Colisão com o cenário: gere <em>heightmaps</em> ou use <code>Runtime Virtual Textures</code> para alinhar pickups a terrenos complexos.</li>
        </ul>
      </div>
      <h3>Checklist de Testes do Sistema de Itens</h3>
      <ul>
        <li>Simular drop massivo em mapas diferentes (cidade, dungeon, evento) e verificar colisão + respawn após timeout.</li>
        <li>Verificar tooltips em diferentes idiomas (usar <code>GlobalText.h</code> &rarr; <code>LocRes</code> no UE5).</li>
        <li>Executar testes automatizados de inventário (Blueprint <code>Functional Tests</code>) movendo, dividindo e combinando stacks.</li>
        <li>Forçar perda de conexão durante pickup para validar recuperação de estado via <code>/inventory/sync</code>.</li>
      </ul>
    </section>

    <section id="mob-system-atlas">
      <h2>Atlas Completo do Sistema de Mobs</h2>
      <p>
        Este atlas organiza todas as informações necessárias para reconstruir o ecossistema de mobs na Unreal Engine 5,
        incluindo spawn, movimentação, IA, drops, distribuição de XP e sincronização com o backend. Os dados legados
        do cliente e do servidor permanecem a fonte de verdade e devem ser convertidos em estruturas UE5 seguindo os
        passos abaixo.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>Fontes de Dados Legadas</h3>
          <ul>
            <li><code>Data/Monster/Monster.txt</code> e <code>MonsterSetBase.txt</code>: estatísticas base e pontos de spawn.</li>
            <li><code>Source MuServer Update 15/GameServer/GameServer/MonsterSetBase.cpp</code>: parsing de respawn, delays e limites.</li>
            <li><code>Source MuServer Update 15/GameServer/GameServer/MonsterAI.cpp</code>, <code>MonsterAIState.cpp</code>: estados de IA e mudança de comportamento.</li>
            <li><code>Source Main 5.2/source/ZzzInterface.cpp</code> (<code>CreateMonster</code>): expectativas de apresentação no cliente original.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Componentes UE5 Recomendados</h3>
          <ul>
            <li><code>BP_MobSpawner</code> (Actor) alimentado por <code>DT_MobSpawn</code> com dados convertidos de <code>MonsterSetBase</code>.</li>
            <li><code>BP_MobCharacter</code> (Child de <code>Character</code>) com <code>CharacterMovement</code> configurado para valores originais de velocidade.</li>
            <li><code>BP_MobAIController</code> + <code>Behavior Tree</code> replicando tabelas de estado de <code>MonsterAI</code>.</li>
            <li><code>BP_MobDropComponent</code> e <code>BP_MobXPComponent</code> para acionar loot/XP de forma sincronizada com o servidor.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Sincronização Cliente &amp; Servidor</h3>
          <ul>
            <li><code>GameServer/GameServer/MonsterManager.cpp</code>: lógica oficial de criação e respawn; serve como blueprint do backend moderno.</li>
            <li>Endpoints REST/WebSocket sugeridos: <code>POST /world/spawn</code>, <code>POST /world/mob/{id}/state</code>, <code>POST /world/mob/{id}/death</code>.</li>
            <li>Eventos replicados via <code>Gameplay Message Subsystem</code> no cliente para atualizar HUD, log de combate e inventário.</li>
            <li>Persistência de drops alinhada com <code>ItemDrop.cpp</code> e <code>MapItem.cpp</code>, garantindo regras idênticas às do servidor.</li>
          </ul>
        </div>
      </div>
      <h3>Pipeline de Spawn e Respawn</h3>
      <ol>
        <li><strong>Converter pontos:</strong> exporte <code>MonsterSetBase.txt</code> para <code>DT_MobSpawn</code> com campos <em>MapID</em>, <em>SpawnPoint</em> (X, Y), <em>Direction</em>, <em>RespawnTime</em>, <em>MobClass</em>, <em>Quantity</em>.</li>
        <li><strong>Instanciar spawner:</strong> posicione <code>BP_MobSpawner</code> no nível e associe a linha correspondente do data table.</li>
        <li><strong>Solicitar backend:</strong> ao carregar o nível, envie <code>POST /world/spawn</code> com o identificador do spawner. O servidor responde com <em>MobInstanceIDs</em> e atributos finais (HP, tipo de drop extra, buffs).</li>
        <li><strong>Spawn local:</strong> <code>BP_MobSpawner</code> cria <code>BP_MobCharacter</code> usando meshes/animações originais convertidas. Use <code>SetActorLocation</code> com as coordenadas convertidas (multiplique por <code>TERRAIN_SCALE</code> para manter proporção).</li>
        <li><strong>Respawn:</strong> ao receber evento <code>MobRespawnScheduled</code> do servidor (calculado por <code>MonsterManager::RespawnMonster</code>), iniciar <code>FTimerHandle</code> no spawner para recriar o mob no tempo indicado.</li>
      </ol>
      <pre><code>Event InitializeSpawner (SpawnerRow)
  → Set DataTableRow = SpawnerRow
  → For Index 0 .. SpawnerRow.Quantity-1
        → Send HTTP (POST /world/spawn) com { SpawnerId, Index }
        → OnSuccess → SpawnMobLocal(Response.Payload)

Function SpawnMobLocal (Payload)
  → SpawnActor BP_MobCharacter at Payload.WorldLocation/Rotation
  → Set MobInstanceID = Payload.InstanceId
  → MobCharacter.ApplyStats(Payload.Stats)
  → MobCharacter.StartBehaviorTree(Payload.BehaviorProfile)</code></pre>
      <h3>Movimentação, Ameaça e Habilidades</h3>
      <p>
        A movimentação no legado é definida pelos estados em <code>MonsterAIState.cpp</code> e regras de perseguição de <code>MonsterAI.cpp</code>.
        No UE5, utilize Behavior Trees com <em>Blackboard</em> contendo chaves <code>TargetActor</code>, <code>PatrolRoute</code>, <code>CurrentState</code>.
      </p>
      <details open>
        <summary>Padrões de comportamento</summary>
        <ol>
          <li><strong>Idle/Patrulha:</strong> converter rotas de <code>MonsterAIMovePath.cpp</code> para <code>DT_MobPatrol</code> e alimentar <code>Simple Move To</code> no AI Controller.</li>
          <li><strong>Perseguição:</strong> replicar cálculo de distância (<code>gObjCheckAttackArea</code>) usando <code>EQSTestingPawn</code> ou <code>Environment Query</code>.</li>
          <li><strong>Ataque:</strong> chamar habilidades mapeadas em <code>MonsterSkillManager.cpp</code>; cada entrada vira uma <code>Gameplay Ability</code> ou <code>Anim Montage</code> no UE5.</li>
          <li><strong>Fuga/Reset:</strong> observar <code>MonsterAIState::AI_PATH_RETURN</code>. Configure <code>Nav Link Proxy</code> para retornos rápidos e dispare evento de reset para limpar ameaças.</li>
        </ol>
        <pre><code>Behavior Tree Resumo
Root
 └─ Selector (Combate)
     ├─ Sequence (Tem Alvo?)
     │    ├─ Blackboard Check (TargetActor)
     │    ├─ Task Attack (usa SkillProfile atual)
     └─ Sequence (Procurar Jogador)
          ├─ Task Run EQS (Ameaça)
          └─ Task Move To (Resultado EQS)

Service AtualizarAmeaça (a cada 0.5s)
  → Para cada jogador em range (Data do backend)
        Atualiza AggroMap replicando <code>MonsterAIAgro.cpp</code>
  → Define TargetActor = Maior Threat</code></pre>
      </details>
      <h3>Drops, XP e Eventos Pós-Morte</h3>
      <ul>
        <li><strong>Drop:</strong> use o mesmo fluxo do painel de itens. <code>BP_MobDropComponent</code> requisita <code>/world/mob/{id}/death</code>, que retorna lista de <em>LootEntries</em> conforme <code>MonsterSetBase</code> + <code>ItemBagManager.cpp</code>.</li>
        <li><strong>XP:</strong> backend calcula via <code>ExperienceTable.cpp</code>. O cliente apenas reproduz o evento <code>OnExperienceReceived</code> para cada participante, distribuindo por party/guild segundo a resposta.</li>
        <li><strong>Eventos:</strong> bosses e invasões utilizam scripts dedicados (<code>InvasionManager.cpp</code>, <code>RaklionBattleOfSelupan.cpp</code>). No UE5, mantenha <code>BP_EventDirector</code> responsável por spawnar mobs especiais e emitir <code>Gameplay Tags</code> como <code>Event.Raklion.Active</code>.</li>
      </ul>
      <div class="callout">
        <strong>Checklist de QA:</strong>
        <ul>
          <li>Conferir se os tempos de respawn respeitam tolerância de ±1s em relação ao servidor legado.</li>
          <li>Validar movimentação em terrenos convertidos: usar <code>NavMesh Invokers</code> para mapas extensos.</li>
          <li>Testar queda de conexão durante combate; mobs devem congelar estado até receber confirmação do backend.</li>
          <li>Monitorar performance: Behavior Trees complexos devem usar <code>Logic Update Interval</code> adaptativo.</li>
        </ul>
      </div>
    </section>

    <section id="skill-system-guide">
      <h2>Compêndio do Sistema de Skills</h2>
      <p>
        Esta seção explica como mapear o sistema de skills original para Blueprints e, quando necessário, C++ na UE5,
        mantendo efeitos visuais, custos, cooldowns e interações com o backend. Inclui a adaptação de skills de personagem,
        master skills e habilidades de mobs.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>Arquivos e Código Originais</h3>
          <ul>
            <li><code>Data/Skill/Skill.txt</code>, <code>SkillSkill_*.txt</code>, <code>MasterSkillTree.txt</code>: atributos, custos, requisitos.</li>
            <li><code>Source MuServer Update 15/GameServer/GameServer/SkillManager.cpp</code>: aplicação de dano, mana, cooldown.</li>
            <li><code>SkillDamage.cpp</code>, <code>SkillHitBox.cpp</code>: fórmulas e alcance.</li>
            <li><code>Source Main 5.2/source/SkillManager.cpp</code>, <code>SkillEffectMgr.cpp</code>, <code>ZzzEffectMagicSkill.cpp</code>: efeitos visuais e sons no cliente.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Estrutura UE5 Recomendada</h3>
          <ul>
            <li><code>BP_SkillComponent</code> (Actor Component) com arrays <code>KnownSkills</code> e <code>ActiveBuffs</code>.</li>
            <li><code>DT_SkillCatalog</code> contendo <code>FSKillDefinition</code> (ID, Nome, Classe, Custos, Efeito, Cooldown, AnimMontage, FX).</li>
            <li><code>Gameplay Ability System</code> opcional: cada skill vira uma <code>UGameplayAbility</code> com <code>GameplayEffect</code> replicando buffs.</li>
            <li><code>WBP_SkillBar</code>, <code>WBP_SkillTooltip</code> e <code>WBP_SkillTree</code> para interface.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Integração com Backend</h3>
          <ul>
            <li>Endpoints: <code>POST /skills/cast</code>, <code>POST /skills/equip</code>, <code>GET /characters/{id}/skills</code>, <code>POST /skills/master-tree</code>.</li>
            <li>Converter <code>SkillManager::CGSkillAttackRecv</code> para API moderna que valida requisitos antes de confirmar casting.</li>
            <li>Persistir builds de master skill conforme estrutura de <code>MasterSkillTree.cpp</code>, retornando nós adquiridos.</li>
            <li>Enviar logs de combate (dano aplicado, status) para analítica, mantendo compatibilidade com <code>SkillDamage</code>.</li>
          </ul>
        </div>
      </div>
      <h3>Processo de Conversão</h3>
      <ol>
        <li><strong>Normalizar dados:</strong> criar script que lê <code>Skill.txt</code> e gera <code>DT_SkillCatalog</code> com campos extras (classe permitida, target type, min/max range, consumo de mana e stamina).</li>
        <li><strong>Importar efeitos:</strong> converter texturas/sons citados em <code>ZzzEffect.cpp</code> e <code>SkillEffect.bmd</code> para <code>Niagara</code>/<code>MetaSounds</code>.</li>
        <li><strong>Configurar componente:</strong> <code>BP_SkillComponent</code> lê <code>DT_SkillCatalog</code> na inicialização e popula slots ativos conforme retorno do backend (<code>GET /characters/{id}/skills</code>).</li>
        <li><strong>Implementar casting:</strong> cada habilidade chama <code>POST /skills/cast</code>, aguarda confirmação (para validação anti-cheat) e, em seguida, executa o efeito local.</li>
        <li><strong>Sincronizar cooldown:</strong> backend devolve timestamp e duração. O cliente utiliza <code>FTimerManager</code> para bloquear inputs até o término.</li>
      </ol>
      <h3>Blueprint de Casting Genérico</h3>
      <pre><code>Function TryCastSkill (SkillID)
  → Data = DT_SkillCatalog[SkillID]
  → Se ManaAtual &lt; Data.ManaCost → HUD.Log("Mana insuficiente")
  → Send HTTP (POST /skills/cast)
        Body = { SkillID, TargetId, Position, Rotation }
  → OnSuccess:
        ApplySkillLocally(Data, Response.Payload)
        StartCooldown(SkillID, Response.Payload.Cooldown)

Function ApplySkillLocally (Data, Payload)
  → PlayAnimMontage(Data.AnimMontage)
  → SpawnSystemAtLocation(Data.NiagaraFX, Payload.SpawnLocation)
  → ApplyGameplayEffectToTarget(Payload.Targets, Data.EffectHandle)
  → If Data.TriggersProjectile → SpawnActor(BP_SkillProjectile)</code></pre>
      <h3>Catalogação de Skills</h3>
      <table class="matrix">
        <thead>
          <tr>
            <th>Grupo</th>
            <th>Exemplos</th>
            <th>Conversão UE5</th>
            <th>Observações</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Skills Básicas</strong></td>
            <td><code>Falling Slash</code>, <code>Power Slash</code></td>
            <td>Montages simples + <code>GameplayEffect</code> instantâneo de dano. Usar <code>Trace</code> em arco para alcance, conforme <code>SkillHitBox.cpp</code>.</td>
            <td>Respeitar delay <code>Delay</code> de <code>Skill.txt</code>; sincronizar com animação para evitar spam.</td>
          </tr>
          <tr>
            <td><strong>Skills com Projétil</strong></td>
            <td><code>Ice Arrow</code>, <code>Triple Shot</code></td>
            <td><code>BP_SkillProjectile</code> com movimento <code>ProjectileMovement</code> e colisão <code>Sphere</code>. Mesh/partículas importadas de <code>SkillEffect.bmd</code>.</td>
            <td>Servidor calcula trajetória e impacto final (anti-cheat). Cliente mostra trajetória prevista e ajusta ao receber confirmação.</td>
          </tr>
          <tr>
            <td><strong>Buffs &amp; Debuffs</strong></td>
            <td><code>Greater Fortitude</code>, <code>Soul Barrier</code></td>
            <td><code>GameplayEffect</code> com atributos modificadores (HP Max, Defense). Replicar durações de <code>SkillManager.cpp</code>.</td>
            <td>Exibir ícone em <code>WBP_BuffTray</code> reaproveitando sprites originais. Backend envia <code>BuffId</code> e <code>ExpireAt</code>.</td>
          </tr>
          <tr>
            <td><strong>Master Skills</strong></td>
            <td><code>Flame Strike</code>, <code>Archangel's Will</code></td>
            <td>Criar árvore em <code>WBP_SkillTree</code> com dados de <code>MasterSkillTree.txt</code>. Cada nó aplica <code>GameplayEffect</code> incremental.</td>
            <td>Necessário endpoint dedicado para salvar progresso (<code>POST /skills/master-tree</code>).</td>
          </tr>
          <tr>
            <td><strong>Skills de Mobs</strong></td>
            <td><code>Selupan Ice Storm</code>, <code>Kundun Summon</code></td>
            <td>Reaproveitar <code>MonsterSkillManager.cpp</code> para gerar <code>DT_MobSkillProfiles</code>. Comportamentos viram tarefas específicas no Behavior Tree.</td>
            <td>Sincronizar com eventos de IA do atlas de mobs para garantir efeitos corretos no momento do cast.</td>
          </tr>
        </tbody>
      </table>
      <div class="callout">
        <strong>Boas práticas:</strong>
        <ul>
          <li>Centralize cálculos críticos (dano, resistência, hit chance) no backend para evitar divergências.</li>
          <li>Utilize <code>AbilitySystemComponent</code> ou uma camada C++ para habilidades com múltiplos efeitos simultâneos.</li>
          <li>Reaproveite texturas/ícones originais em formato <code>.tga</code>/<code>.ozj</code> convertendo para <code>.png</code> e mantendo nomes para rastreabilidade.</li>
          <li>Implemente testes automatizados de skill (Blueprint Functional Tests) executando combos, buffs e projeções de dano comparados com valores originais.</li>
        </ul>
      </div>
    </section>

    <section id="blueprints">
      <h2>Exemplos Práticos em Blueprint</h2>
      <p>Use os snippets abaixo como base para recriar a lógica principal em Blueprints reaproveitando assets existentes.</p>
      <details open>
        <summary>HUD Dinâmico e Inventário (Widget Blueprint)</summary>
        <ol>
          <li>Criar <code>WBP_HUD</code> contendo componentes de barra de vida/mana (Progress Bar) e painel de inventário (Uniform Grid).</li>
          <li>Associar <code>BP_InventoryManager</code> ao Player Controller e expor eventos <em>OnInventoryChanged</em>.</li>
          <li>No Event Graph do widget, reagir ao evento para atualizar ícones reaproveitados.</li>
        </ol>
        <pre><code>Event Construct
  → Get Player Controller → Cast to BP_PlayerController
  → Bind Event to InventoryManager.OnInventoryChanged

Custom Event OnInventoryChanged (Itens)
  → Clear Children (GridInventario)
  → ForEach Itens:
      Create Widget (WBP_ItemSlot)
      SetData (ItemID, IconeTextura, Quantidade)
      Add Child to Grid (coluna = Index % 6, linha = Index / 6)</code></pre>
      </details>
      <details>
        <summary>Tela de Login (Widget + Fluxo HTTP)</summary>
        <ol>
          <li>Criar <code>WBP_Login</code> com Canvas 640×480, inputs e botões posicionados conforme <code>CLoginWin::SetPosition</code>.</li>
          <li>Adicionar <em>Widget Switcher</em> para alternar entre estados (Padrão, Carregando, Erro) enquanto a requisição HTTP é processada.</li>
          <li>Implementar <code>BP_LoginController</code> (GameInstanceSubsystem) que chama <code>BP_ServerGateway.LoginAsync</code> e gerencia cache de usuário.</li>
          <li>Mapear códigos de erro <code>GlobalText[450..461]</code> para mensagens amigáveis e reproduzir sons <code>SOUND_CLICK01</code>/<code>SOUND_FAIL</code>.</li>
          <li>Ao sucesso, salvar Token/Refresh em <code>USaveGame</code>, armazenar lista de personagens no <code>GameInstance</code> e abrir a cena de seleção.</li>
        </ol>
        <pre><code>Event Construct
  → LoginController = GetGameInstanceSubsystem(BP_LoginController)
  → Bind LoginController.OnLoginSuccess → HandleSuccess
  → Bind LoginController.OnLoginFailed → HandleError

OnClickLogin / OnPressEnter
  → PlaySound2D(SFX_Click)
  → WidgetSwitcher.SetActiveIndex(STATE_Loading)
  → LoginController.RequestLogin(UserText, PassText, RememberCheck.IsChecked)

HandleSuccess(Characters)
  → WidgetSwitcher.SetActiveIndex(STATE_Default)
  → SaveGameInstance(Token)
  → OpenLevel("L_CharacterSelect")

HandleError(Code, Message)
  → WidgetSwitcher.SetActiveIndex(STATE_Default)
  → MessageBox.Show(Message)
  → PlaySound2D(SFX_Error)</code></pre>
      </details>
      <details>
        <summary>Seleção de Personagem (UMG + Preview 3D)</summary>
        <ol>
          <li>Criar <code>WBP_CharacterSelect</code> com <code>UniformGridPanel</code> de 5 slots usando sprites <code>CharSel</code> originais.</li>
          <li>Adicionar <code>BP_CharacterPreviewManager</code> (Actor) responsável por spawnar <code>BP_CharacterPreview</code> e movimentar a câmera.</li>
          <li>Conectar botões <em>Create</em>, <em>Delete</em>, <em>Connect</em> ao <code>BP_ServerGateway</code> para executar chamadas <code>POST /characters</code>, <code>DELETE /characters/{id}</code>, <code>POST /sessions/enter</code>.</li>
          <li>Reaproveitar animações de idle/pose importadas do cliente original (índice por classe em <code>CharacterManager</code>).</li>
          <li>Sincronizar estado <code>SelectedHero</code> no <code>PlayerState</code> para que outros sistemas carreguem inventário, mapa e configurações corretas.</li>
        </ol>
        <pre><code>Event Construct
  → ServerGateway.ListCharactersAsync()
  → Bind OnCharactersReceived → BuildSlots

BuildSlots(List)
  → ForEach Index 0..4
        Slot = CreateWidget(WBP_CharacterSlot)
        Slot.Setup(List[Index])
        Slot.OnSelected.Bind → HandleSelected
        Grid.AddChild(Slot)

HandleSelected(CharData)
  → PreviewManager.FocusOn(CharData)
  → SelectedCharacter = CharData
  → UpdateTopBarButtons()

OnClickConnect
  → ServerGateway.EnterWorldAsync(SelectedCharacter.Id)
  → OnSuccess → OpenLevel(SelectedCharacter.StartMap)

OnClickCreate
  → ShowModal(WBP_CharacterCreation)</code></pre>
      </details>
      <details>
        <summary>Sistema de Itens com Data Table</summary>
        <ol>
          <li>Criar <code>DT_Items</code> (Data Table) baseado em struct <code>FItemStats</code> contendo Nome, Tipo, Raridade, Mesh, Icone, Efeito.</li>
          <li>No <code>BP_ItemBase</code>, adicionar variável <code>ItemRowName</code> e carregar dados na construção.</li>
          <li>Expor função <code>ApplyEffect</code> para uso por consumíveis ou equipamentos.</li>
        </ol>
        <pre><code>Event OnConstruct (BP_ItemBase)
  → Get Data Table Row (DT_Items, ItemRowName)
  → Set DisplayName, Icon, Mesh, Stats

Function ApplyEffect (Alvo)
  Switch on ItemType
    Consumivel → Alvo.ApplyHealth(Stats.HealAmount)
    Equipamento → Alvo.EquiparSlot(Stats.Slot, self)
    Gema → Alvo.AtribuirBuff(Stats.BuffID, Stats.Duration)</code></pre>
      </details>
      <details>
        <summary>XP e Level Up Automatizado</summary>
        <ol>
          <li>Criar componente <code>BP_ProgressionComponent</code> com variáveis <code>CurrentXP</code>, <code>CurrentLevel</code>, <code>XPTable</code>.</li>
          <li>Adicionar função <code>AddExperience</code> chamada por inimigos ao morrer.</li>
          <li>Disparar evento <code>OnLevelUp</code> que atualiza HUD e atributos do personagem.</li>
        </ol>
        <pre><code>Function AddExperience (Amount)
  CurrentXP += Amount
  while CurrentXP ≥ XPTable[CurrentLevel]
    CurrentXP -= XPTable[CurrentLevel]
    CurrentLevel += 1
    OnLevelUp.Broadcast(CurrentLevel)

Event OnLevelUp
  → PlayerStatsComponent.IncrementarAtributos(CurrentLevel)
  → HUDWidget.PlayAnimation(LevelUpAnim)
  → Spawn Niagara (FX_LevelUp) na localização do jogador</code></pre>
      </details>
      <details>
        <summary>Drop de Loot Dinâmico</summary>
        <ol>
          <li><code>BP_LootSpawner</code> recebe tabela <code>DT_LootTable</code> herdada do jogo original.</li>
          <li>Ao destruir inimigo, chamar <code>SpawnLoot</code> informando <em>LootContext</em> (região, dificuldade).</li>
          <li>Gerar item físico com mesh/partícula reutilizada.</li>
        </ol>
        <pre><code>Function SpawnLoot (LootContext)
  EntradasVálidas ← Filtrar DT_LootTable por Região &amp; Raridade
  Sorteio ← Random Weighted Selection (DropRate)
  SpawnActor BP_ItemPickup at GetActorLocation()
  ItemPickup.SetItemID(Sorteio.ItemID)
  ItemPickup.PlayNiagara(FX_Drop, Cor = Sorteio.RaridadeCor)
  ItemPickup.Bind OnCollected → Inventario.AddItem(ItemID)</code></pre>
      </details>
      <details>
        <summary>Spawn e Respawn de Mobs com Tabelas Originais</summary>
        <ol>
          <li>Converter <code>MonsterSetBase.txt</code> para <code>DT_MobSpawn</code> contendo mapa, coordenadas, direção e tempo de respawn.</li>
          <li>No <code>BP_MobSpawner</code>, carregar a linha do Data Table no <code>BeginPlay</code> e solicitar autorização ao backend (<code>POST /world/spawn</code>).</li>
          <li>Ao receber a resposta, spawnar <code>BP_MobCharacter</code> com malhas originais e registrar o <em>MobInstanceId</em>.</li>
          <li>Escutar o evento <code>OnMobDied</code> do personagem para iniciar temporizador de respawn baseado em <code>RespawnTime</code>.</li>
        </ol>
        <pre><code>Event BeginPlay (BP_MobSpawner)
  → Row = Get Data Table Row (DT_MobSpawn, SpawnId)
  → HTTP POST /world/spawn (SpawnId)
  → OnSuccess → SpawnMob(Row, Response.Payload)

Function SpawnMob (Row, Payload)
  → SpawnActor(BP_MobCharacter, Location = Row.WorldPosition)
  → Mob.SetInstanceId(Payload.InstanceId)
  → Mob.ApplyStats(Payload.Stats)
  → Mob.OnMobDied.AddDynamic(self, &BP_MobSpawner::HandleMobDeath)

Function HandleMobDeath (Context)
  → SpawnLoot(Context)
  → SetTimer(Row.RespawnTime, Respawn)</code></pre>
      </details>
      <details>
        <summary>Execução de Skills com Gameplay Ability System</summary>
        <ol>
          <li>Registrar skills em <code>DT_SkillCatalog</code> com cooldown, mana e referência para <code>GameplayAbility</code>.</li>
          <li>No <code>AbilitySystemComponent</code>, conceder habilidades conforme retorno do backend (<code>GET /characters/{id}/skills</code>).</li>
          <li>Ao pressionar um slot, chamar <code>TryActivateAbilityByClass</code> e enviar requisição <code>POST /skills/cast</code> simultaneamente.</li>
          <li>Receber confirmação e aplicar <code>GameplayEffect</code> nas entidades afetadas usando IDs originais.</li>
        </ol>
        <pre><code>Event InputSkill (SkillSlot)
  → AbilityClass = SkillCatalog[SkillSlot].Ability
  → if ASC.TryActivateAbilityByClass(AbilityClass)
        → HTTP POST /skills/cast (SkillID)

Ability::ActivateAbility
  → CommitAbilityCost()
  → PlayMontageAndWait(SkillMontage)
  → SpawnSystemAttached(NiagaraFX)
  → ApplyGameplayEffectSpecToTarget(TargetEffect, TargetData)</code></pre>
      </details>
      <details>
        <summary>Carregamento de Mapas com Subníveis</summary>
        <ol>
          <li>Converter mapas grandes para <code>World Partition</code> e criar <em>Data Layers</em> para iluminação, efeitos e gameplay.</li>
          <li>Usar <code>BP_MapManager</code> para carregar subníveis com base na proximidade do jogador.</li>
          <li>Controlar música ambiente e sons locais via <code>Audio Volumes</code>.</li>
        </ol>
        <pre><code>Event BeginPlay (BP_MapManager)
  → Set Data Layer State (Exploração, Loaded)
  → Load Stream Level (Dungeon_Entrada)

Event OnPlayerReachedPortal
  → Load Stream Level (Dungeon_Boss)
  → Set Data Layer State (Exploração, Unloaded)
  → Set Data Layer State (BossFight, Loaded)
  → AudioManager.PlayCue(MusicaBoss)</code></pre>
      </details>
      <details>
        <summary>Efeitos Visuais Atualizados no Niagara</summary>
        <ol>
          <li>Importar texturas de partículas legadas para o Niagara e criar <code>NS_SpellImpact</code>.</li>
          <li>Expor parâmetros de cor e escala para refletir raridade do item/skill.</li>
          <li>Chamar efeito via <code>GameplayCue</code> ou diretamente nos Blueprints de habilidade.</li>
        </ol>
        <pre><code>Function PlayImpactFX (Contexto)
  NiagaraComponent.SetVariableLinearColor("Color", Contexto.RaridadeCor)
  NiagaraComponent.SetVariableFloat("Scale", Contexto.Escala)
  NiagaraComponent.Activate()
  AudioComponent.Play()
  CameraShake.Play(Contexto.ShakeClass)</code></pre>
      </details>
      <details>
        <summary>Gateway UE5 &lt;&gt; Servidor Moderno (HTTP/JSON)</summary>
        <ol>
          <li>Criar <code>BP_ServerGateway</code> (Object Blueprint) com funções assíncronas para Login, LoadCharacter, SaveInventory.</li>
          <li>Utilizar <code>FHttpModule</code> via <em>Blueprint Function Library</em> (nós <code>Execute HTTP Request</code> ou plugin VaRest) para chamar APIs REST.</li>
          <li>Serializar/deserializar <code>JSON</code> refletindo os mesmos campos dos arquivos <code>Data/Item</code> e tabelas SQL.</li>
          <li>Propagar resultados via <em>Delegates</em> (ex.: <code>OnInventoryReceived</code>) para atualizar HUD/inventário.</li>
        </ol>
        <pre><code>Function LoginAsync (Email, Senha)
  Create Request (POST, /auth/login)
  Set Header "Content-Type" = "application/json"
  Set Content (Make JSON → { "email": Email, "password": Senha })
  Send
  On Success:
    Parse JSON → Token, Characters[]
    Store Token
    Broadcast OnLoginSuccess(Token, Characters)
  On Error:
    Broadcast OnLoginFailed(StatusCode, Message)

Function LoadInventoryAsync (CharacterID)
  Create Request (GET, /characters/{CharacterID}/inventory)
  Set Header "Authorization" = Token
  Send
  On Success:
    Parse JSON → Itens[]
    Broadcast OnInventoryReceived(Itens)

Delegate OnInventoryReceived(Itens)
  → BP_InventoryManager.UpdateFromServer(Itens)</code></pre>
      </details>

    </section>

    <section id="codigo-detalhado">
      <h2>Mapeamento de Código &rarr; Blueprints UE5</h2>
      <p>
        Use o painel abaixo para navegar entre os módulos principais. Cada aba traz o trecho de código do projeto
        original, a leitura da lógica e o passo a passo para replicar em Blueprints na Unreal Engine 5 reaproveitando
        os mesmos assets, coordenadas e fluxos de dados.
      </p>
      <div class="conversion-tabs" role="tablist">
        <button class="conversion-button active" data-pane="hud">HUD &amp; Barra de Experiência</button>
        <button class="conversion-button" data-pane="login">Tela de Login</button>
        <button class="conversion-button" data-pane="items">Sistema Completo de Itens</button>
        <button class="conversion-button" data-pane="inventory">Inventário e Equipamentos</button>
        <button class="conversion-button" data-pane="progression">Progressão / XP</button>
        <button class="conversion-button" data-pane="drops">Sistema de Drops</button>
        <button class="conversion-button" data-pane="character-select">Seleção de Personagens</button>
        <button class="conversion-button" data-pane="mobs">Sistema de Mobs</button>
        <button class="conversion-button" data-pane="skills">Sistema de Skills</button>
        <button class="conversion-button" data-pane="companions">Companheiros &amp; Recursos Avançados</button>
        <button class="conversion-button" data-pane="social">Party, Guild &amp; Gens</button>
        <button class="conversion-button" data-pane="maps">Mapas e Navegação</button>
        <button class="conversion-button" data-pane="effects">Efeitos Visuais</button>
        <button class="conversion-button" data-pane="backend">Backend &amp; Serviços</button>
        <button class="conversion-button" data-pane="qa">QA, Debug &amp; Telemetria</button>
      </div>

      <article class="conversion-pane active" data-pane="hud">
        <h3>HUD Principal com Layout Original</h3>
        <p>
          O cliente define a HUD no <code>CNewUIMainFrameWindow</code>, renderizando faixas, gauges e botões com offsets
          absolutos para 640&times;480 e ajustes proporcionais. Esses valores são a referência direta para posicionar os
          widgets UMG reaproveitando as texturas convertidas de <code>Interface\*.ozj/.ozt</code>.
        </p>
        <div class="source-card">
          <div class="source-meta">Cliente original – <code>Source Main 5.2/source/NewUIMainFrameWindow.cpp</code></div>
          <pre><code>bool SEASON3B::CNewUIMainFrameWindow::Render()
{
        EnableAlphaTest();
        RenderFrame();
        RenderLifeMana();
        RenderGuageSD();
        RenderGuageAG();
        RenderButtons();
        RenderExperience();
        DisableAlphaBlend();
        return true;
}

void SEASON3B::CNewUIMainFrameWindow::RenderFrame()
{
        float width, height;
        float x, y;

        width = 256.f; height = 51.f;
        x = 0.f; y = 480.f - height;
        SEASON3B::RenderImage(IMAGE_MENU_1, x, y, width, height);
        width = 128.f;
        x = 256.f;
        SEASON3B::RenderImage(IMAGE_MENU_2, x, y, width, height);
        width = 256.f;
        x = 256.f + 128.f;
        SEASON3B::RenderImage(IMAGE_MENU_3, x, y, width, height);
}

void SEASON3B::CNewUIMainFrameWindow::RenderGuageSD()
{
        width = 16.f; height = 39.f;
        x = 204; y = 480.f - 49.f;
        RenderBitmap(IMAGE_GAUGE_SD, x, y + (fShield * height), width, height - (fShield * height), 0.f, fShield*height/64.f, width/16.f, (1.0f - fShield)*height/64.f);
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Experiência – <code>RenderExperience()</code> no mesmo arquivo</div>
          <pre><code>x = 2.f; y = 473.f; width = fProgress * 629.f; height = 4.f;
RenderBitmap(IMAGE_GAUGE_EXBAR, x, y, width, height, 0.f, 0.f, 6.f/8.f, 4.f/4.f);
SEASON3B::RenderNumber(635.f, 469.f, (int)fExpBarNum);
if(SEASON3B::CheckMouseIn(x, y, 629.f, 4.f) == true)
{
        sprintf(strTipText, GlobalText[1748], dwExperience, dwNexExperience);
        RenderTipText(280, 418, strTipText);
}</code></pre>
        </div>
        <svg class="layout-map" viewBox="0 0 640 480" aria-labelledby="hud-layout-title">
          <title id="hud-layout-title">Mapa visual da HUD original (640×480)</title>
          <rect x="0" y="429" width="256" height="51" />
          <text x="12" y="446">Menu 1</text>
          <rect x="256" y="429" width="128" height="51" />
          <text x="268" y="446">Menu 2</text>
          <rect x="384" y="429" width="256" height="51" />
          <text x="396" y="446">Menu 3</text>
          <rect class="asset" x="158" y="432" width="45" height="39" />
          <text x="163" y="452">HP</text>
          <rect class="asset" x="437" y="432" width="45" height="39" />
          <text x="442" y="452">MP</text>
          <rect class="asset" x="204" y="431" width="16" height="39" />
          <text x="205" y="425">SD</text>
          <rect class="asset" x="420" y="431" width="16" height="39" />
          <text x="421" y="425">AG</text>
          <rect class="asset" x="2" y="473" width="629" height="4" />
          <text x="6" y="468">XP</text>
        </svg>
        <h4>Passo a passo no UMG</h4>
        <ol>
          <li>Converter as texturas <code>Interface\newui_menu0*.ozj</code>, <code>Interface\newui_menu_red.ozj</code>, <code>Interface\newui_menu_blue.ozj</code>, <code>Interface\newui_menu_sd.ozj</code> e <code>Interface\newui_menu_ag.ozj</code> para <code>.png</code> preservando as dimensões (use a rotina descrita em <code>GlobalBitmap.cpp</code> para remover o cabeçalho de 24 bytes).</li>
          <li>Criar <code>WBP_HUD</code> com um <em>Canvas Panel</em> raiz travado em 640×480 e habilitar <em>Screen Alignment = Fill</em>. Ajustar as âncoras das imagens seguindo o mapa acima (faixas ancoradas em Bottom Stretch, gauges em pontos absolutos).</li>
          <li>Adicionar <em>Progress Bars</em> para HP/MP/SD/AG usando <em>Fill from Bottom</em> e máscaras do mesmo tamanho dos sprites. Os valores de preenchimento replicam <code>height - (valor/max * height)</code>.</li>
          <li>Adicionar um <em>Border</em> invisível sobre a barra de XP e ligar ao evento <code>OnMouseMove</code> para mostrar um tooltip idêntico a <code>RenderTipText</code> (usar <code>Format Text</code> para exibir <em>XP atual</em> / <em>próximo nível</em>).</li>
          <li>Para múltiplas resoluções, encapsular o Canvas em um <em>Scale Box</em> com <em>Stretch = ScaleToFit</em> e expor um multiplicador de DPI para manter legibilidade em monitores maiores.</li>
        </ol>
        <h4>Blueprint (Widget Graph)</h4>
        <pre><code>Event Construct
  → Bind OnStatChanged (BP_PlayerState)
  → AtualizarHUD(Stats)

Event AtualizarHUD (Stats)
  → SetPercent(HPBar, Stats.HP / Stats.MaxHP)
  → SetPercent(MPBar, Stats.MP / Stats.MaxMP)
  → SetPercent(SDBar, Stats.SD / Stats.MaxSD)
  → SetPercent(AGBar, Stats.AG / Stats.MaxAG)
  → AtualizarXP(Stats.CurrentXP, Stats.NextXP)

Function AtualizarXP (XPAtual, XPNecessaria)
  → Progress = Clamp(XPAtual / XPNecessaria, 0, 1)
  → XPBar.SetFillAmount(Progress)
  → XPLabel.SetText(FText::Format("{0}/10", Floor(Progress * 10)))</code></pre>
        <div class="callout">
          <strong>Dica de conversão:</strong> Os botões inferiores usam sprites <code>Interface\partCharge1\newui_menu_Bt*.ozj</code> espaçados de 30&nbsp;px. Monte um <code>UniformGridPanel</code> com colunas fixas e ícones reutilizados para preservar o comportamento original.</div>
      </article>

      <article class="conversion-pane" data-pane="login">
        <h3>Tela de Login (Layout, Fluxo e Backend)</h3>
        <p>
          O cliente original constrói a janela de login em <code>CLoginWin</code> e o cabeçalho em
          <code>CLoginMainWin</code>, reaproveitando sprites <code>BITMAP_LOG_IN</code> e alinhando os
          controles em coordenadas absolutas (base 640×480). Esses valores guiam o posicionamento dos
          widgets UMG e a conversão do fluxo de autenticação para Blueprints na UE5.
        </p>
        <div class="source-card">
          <div class="source-meta">Cliente original – <code>Source Main 5.2/source/LoginWin.cpp</code></div>
          <pre><code>void CLoginWin::Create()
{
        CWin::Create(329, 245, BITMAP_LOG_IN + 7);
        m_asprInputBox[0].Create(156, 23, BITMAP_LOG_IN + 8);
        m_aBtn[0].Create(54, 30, BITMAP_BUTTON);
        m_pIDInputBox = new CUITextInputBox; m_pIDInputBox->Init(g_hWnd, 140, 14, MAX_ID_SIZE);
        m_pPassInputBox = new CUITextInputBox; m_pPassInputBox->Init(g_hWnd, 140, 14, MAX_PASSWORD_SIZE, TRUE);
}

void CLoginWin::SetPosition(int nX, int nY)
{
        m_asprInputBox[0].SetPosition(nX + 109, nY + 106);
        m_asprInputBox[1].SetPosition(nX + 109, nY + 131);
        m_aBtn[0].SetPosition(nX + 150, nY + 178);
        m_aBtn[1].SetPosition(nX + 211, nY + 178);
}

void CLoginWin::UpdateWhileActive(double)
{
        if (m_aBtn[0].IsClick()) RequestLogin();
        else if (CInput::Instance().IsKeyDown(VK_RETURN)) RequestLogin();
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Botões superiores – <code>Source Main 5.2/source/LoginMainWin.cpp</code></div>
          <pre><code>void CLoginMainWin::Create()
{
        for (int i = 0; i &lt;= LMW_BTN_CREDIT; ++i)
                m_aBtn[i].Create(54, 30, BITMAP_LOG_IN + 4 + i, 3, 2, 1);
        CWin::Create(CInput::Instance().GetScreenWidth() - 60, m_aBtn[0].GetHeight(), -2);
        m_sprDeco.Create(189, 103, BITMAP_LOG_IN + 6, 0, NULL, 105, 59);
}</code></pre>
        </div>
        <h4>Mapa de posicionamento (base 640×480)</h4>
        <table>
          <thead>
            <tr>
              <th>Elemento</th>
              <th>Sprite original</th>
              <th>Coordenadas (X, Y)</th>
              <th>Tamanho</th>
              <th>Observações de conversão</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Janela</td>
              <td><code>BITMAP_LOG_IN + 7</code></td>
              <td>(~155, ~120)</td>
              <td>329×245</td>
              <td>Canvas raiz ancorado ao centro; aplicar <em>Scale Box</em> para múltiplas resoluções.</td>
            </tr>
            <tr>
              <td>Input Usuário</td>
              <td><code>BITMAP_LOG_IN + 8</code></td>
              <td>(+109, +106)</td>
              <td>156×23</td>
              <td>Use <em>Editable Text Box</em> com fonte importada de <code>g_hFixFont</code> (Arial 12px).</td>
            </tr>
            <tr>
              <td>Input Senha</td>
              <td><code>BITMAP_LOG_IN + 8</code></td>
              <td>(+109, +131)</td>
              <td>156×23</td>
              <td>Ativar <em>Is Password</em>; manter máscara translúcida (alpha 25).</td>
            </tr>
            <tr>
              <td>Botão OK</td>
              <td><code>BITMAP_BUTTON</code></td>
              <td>(+150, +178)</td>
              <td>54×30</td>
              <td>Reutilize sprites <code>Interface\newui_btn_login_ok.ozj</code>; ligar a <code>RequestLogin</code>.</td>
            </tr>
            <tr>
              <td>Botão Cancelar</td>
              <td><code>BITMAP_BUTTON + 1</code></td>
              <td>(+211, +178)</td>
              <td>54×30</td>
              <td>Executa <code>CancelLogin</code>; na UE5, navegue para <code>MainMenu</code>.</td>
            </tr>
            <tr>
              <td>Botões superiores</td>
              <td><code>BITMAP_LOG_IN + 4..6</code></td>
              <td>(Topo direito)</td>
              <td>54×30</td>
              <td>Monte <em>Horizontal Box</em> ancorada ao topo (Menu/Credits).</td>
            </tr>
          </tbody>
        </table>
        <h4>Passos para replicar no UMG</h4>
        <ol>
          <li>Converter os arquivos <code>Interface\LogIn\*.ozj</code> e <code>Interface\LogIn\*.ozt</code> para <code>.png</code>
            mantendo nomes originais e gerar um atlas 1:1 para <code>WBP_Login</code>.</li>
          <li>Criar um <em>Widget Blueprint</em> com <code>Canvas Panel</code> centralizado em 640×480; inserir imagens para frame,
            inputs e botões seguindo a tabela acima.</li>
          <li>Adicionar <code>EditableTextBox</code> (Usuário) e <code>EditableTextBox</code> (Senha) e replicar a navegação Tab
            usando <code>SetUserFocus</code> no <code>Event Construct</code>, similar ao <code>SetTabTarget</code>.</li>
          <li>Configurar animação de foco inicial: no <code>Event Pre Construct</code>, chamar uma função que decide qual campo
            recebe foco (ID preenchido &rarr; senha) conforme o comportamento de <code>FirstLoad</code>.</li>
          <li>Integrar o backend criando <code>BP_LoginController</code> (Actor) que injeta <code>BP_ServerGateway</code> e expõe
            eventos <code>OnLoginSuccess</code>/<code>OnLoginFailed</code>.</li>
        </ol>
        <h4>Blueprint – Fluxo de autenticação</h4>
        <pre><code>WBP_Login::Event Construct
  → Get GameInstance → GetSubsystem(BP_LoginController)
  → Bind OnLoginSuccess → HandleSuccess
  → Bind OnLoginFailed → HandleFailure

OnClick Botão OK ou OnPress Enter
  → PlaySound2D(SFX_Click)
  → BP_LoginController.RequestLogin(UsuarioText, SenhaText)

BP_LoginController::RequestLogin(User, Pass)
  → Branch (IsEmpty?) → Mostrar aviso
  → ServerGateway.LoginAsync(User, Pass)

ServerGateway::OnLoginSuccess(Token, Characters)
  → SaveGameInstance(Token)
  → OnLoginSuccess.Broadcast(Characters)

WBP_Login::HandleSuccess(Characters)
  → Load Stream Level "CharacterSelect"
  → Passar lista para <code>WBP_CharacterSlots</code>

HandleFailure(Status, Message)
  → Mostrar popup reaproveitando estilo <code>MESSAGE_BOX</code></code></pre>
        <div class="callout">
          <strong>Backend recomendado:</strong> expor <code>POST /auth/login</code> (retorna Token + lista de personagens),
          <code>GET /servers</code> e <code>GET /patch-notes</code> para substituir os botões superiores. Utilize <em>Gameplay
          Tags</em> para mapear códigos de erro legados (GlobalText[450..461]).
        </div>
      </article>

      <article class="conversion-pane" data-pane="items">
        <h3>Sistema Completo de Itens (Dados &rarr; Mundo &rarr; UI)</h3>
        <p>
          Este painel conecta tabelas originais de itens, lógica de colisão de drops e renderização
          no inventário/HUD. Ele serve como referência única para reconstruir metadados, pickups,
          tooltips e sincronização com o backend moderno utilizando Blueprints da UE5.
        </p>
        <div class="grid-2">
          <div class="source-card">
            <div class="source-meta">Dados &mdash; <code>MuServer_Season_5_Update_15/Data/Item/Item.txt</code></div>
            <pre><code>//Index Slot Skill X   Y   Serial Opt Drop  Nome             Lvl  DmgMin DmgMax Speed Dur
0      0    0     1   2   1      1   1     "Kris"           6    6      11     5    20
1      0    0     1   3   1      1   1     "Short Sword"   3    3      7      2    22
2      0    0     1   3   1      1   1     "Rapier"        9    9      15     4    23</code></pre>
          </div>
          <div class="source-card">
            <div class="source-meta">Cliente &mdash; <code>Source Main 5.2/source/NewUIMyInventory.cpp</code></div>
            <pre><code>void CNewUIMyInventory::RenderItemToolTip(int iSlotIndex)
{
    if(m_iPointedSlot != -1)
    {
        ITEM* pEquipmentItemSlot = &CharacterMachine->Equipment[iSlotIndex];
        if(pEquipmentItemSlot->Type != -1)
        {
            int iTargetX = m_EquipmentSlots[iSlotIndex].x + m_EquipmentSlots[iSlotIndex].width / 2;
            int iTargetY = m_EquipmentSlots[iSlotIndex].y + m_EquipmentSlots[iSlotIndex].height / 2;
            if(m_RepairMode == REPAIR_MODE_OFF)
                RenderItemInfo(iTargetX, iTargetY, pEquipmentItemSlot, false);
            else
                RenderRepairInfo(iTargetX, iTargetY, pEquipmentItemSlot, false);
        }
    }
}</code></pre>
          </div>
        </div>
        <div class="grid-2">
          <div class="source-card">
            <div class="source-meta">Cliente &mdash; <code>Source Main 5.2/source/NewUIInventoryCtrl.cpp</code></div>
            <pre><code>void CNewUIPickedItem::Render3D()
{
    if(m_pPickedItem && m_pPickedItem->Type >= 0)
    {
        m_Pos.x = MouseX - m_Size.cx/2;
        m_Pos.y = MouseY - m_Size.cy/2;
        RenderItem3D(m_Pos.x, m_Pos.y, m_Size.cx, m_Size.cy,
            m_pPickedItem->Type, m_pPickedItem->Level,
            m_pPickedItem->Option1, m_pPickedItem->ExtOption, true);
    }
}</code></pre>
          </div>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/Map.cpp</code></div>
            <pre><code>bool CMap::CheckAttr(int x,int y,BYTE attr)
{
    if((this->GetAttr(x,y) & attr) != 0)
    {
        return 1;
    }
    return 0;
}

bool CMap::CheckStandAttr(int x,int y)
{
    if(this->CheckAttr(x,y,2) != 0) return 0;
    if(this->CheckAttr(x,y,4) != 0) return 0;
    if(this->CheckAttr(x,y,8) != 0) return 0;
    return 1;
}</code></pre>
          </div>
        </div>
        <h4>1. Estrutura de Dados e Importação</h4>
        <ol>
          <li>
            Converter <code>Item.txt</code>, <code>ItemOption.txt</code>, <code>ItemDrop.txt</code> e
            <code>ItemValue.txt</code> para <code>.csv</code> ou <code>.json</code>, mantendo índices originais.
            Gere <code>DT_ItemDefinitions</code> (struct <code>FItemDefinition</code>) e
            <code>DT_ItemOptions</code> (struct <code>FItemOption</code>) na UE5.
          </li>
          <li>
            Criar <code>PrimaryDataAsset BP_ItemCatalog</code> para mapear famílias de itens, ícones
            reaproveitados e classes de Blueprint associadas (ex.: <code>BP_Item_Weapon_Kris</code>).
          </li>
          <li>
            Sincronizar dados com backend por endpoint <code>GET /items?hash=</code> reutilizando o checksum
            original dos arquivos para evitar recarregamentos desnecessários.
          </li>
        </ol>
        <h4>2. Blueprint de Instância de Item</h4>
        <ol>
          <li>Criar <code>BP_ItemInstance</code> (Actor) com componentes <code>StaticMesh</code> ou <code>Niagara</code> para pickups.</li>
          <li>Adicionar <code>UBoxComponent</code> (colisão) com tamanho proporcional a <code>Width</code> e <code>Height</code> originais × 32px.</li>
          <li>
            Implementar função <code>InitializeFromRow</code> que recebe <code>FItemDefinition</code> e seta mesh, ícone, raridade,
            atributos e efeitos sonoros/visuais.
          </li>
          <li>
            Ativar replicação e <code>Net Dormancy</code> configurável para evitar tráfego excessivo quando não houver jogadores por perto.
          </li>
        </ol>
        <pre><code>Event InitializeFromRow(RowName)
  → Get Data Table Row (DT_ItemDefinitions, RowName)
  → Set ItemID/Name/Rarity/Dimensions
  → StaticMesh.SetStaticMesh(Row.Mesh)
  → CollisionBox.SetBoxExtent(Row.CollisionExtent)
  → SetCustomDepthStencil(Row.RarityColor)</code></pre>
        <h4>3. Colisão e Validação de Drop</h4>
        <ol>
          <li>
            No backend, reutilizar <code>CheckStandAttr</code> para negar drops em blocos com atributos 2/4/8. Em UE5, gerar
            <code>Gameplay Tags</code> (ex.: <code>Map.Blocked.Drop</code>) a partir de <code>Data/World</code>.
          </li>
          <li>
            No <code>BP_LootService</code>, após confirmação do servidor, traçar <code>Line Trace</code> até o solo e ajustar o pickup
            para evitar interseções. Caso a colisão falhe, solicitar nova posição com fallback conforme lógica original.
          </li>
          <li>
            Configurar <code>OnComponentBeginOverlap</code> do <code>CollisionBox</code> para chamar <code>RequestLoot</code>,
            validando permissões (party, owner) antes de destruir o Actor.
          </li>
        </ol>
        <h4>4. Tooltips e Renderização no Inventário</h4>
        <ol>
          <li>
            Criar <code>WBP_ItemTooltip</code> que recebe <code>FItemDisplayData</code>. Usar <code>SizeBox</code> + <code>VerticalBox</code>
            para replicar as seções do tooltip (nome, atributos, opções, requisitos).
          </li>
          <li>
            Em <code>WBP_Inventory</code>, mapear <code>OnHovered</code> do slot para abrir tooltip na posição do cursor,
            convertendo <code>GridX/GridY</code> em coordenadas absolutas (multiplicar por 32 px + offset <code>(15,200)</code>).
          </li>
          <li>
            Implementar função <code>ComposeTooltip</code> que consulta <code>DT_ItemOptions</code> e adiciona linhas coloridas
            conforme raridade (seguir paleta original: Excellent = #00FF00, Ancient = #00FFFF, Socket = #FF00FF).
          </li>
          <li>
            Para renderização de arrasto, usar <code>WBP_ItemGhost</code> com <code>Image</code> ligado ao ícone original.
            Atualizar a posição na tela a cada <code>Tick</code>, replicando <code>RenderItem3D</code> com coordenadas do mouse.
          </li>
        </ol>
        <pre><code>OnHovered (InventorySlot)
  → Get Item Data (ItemRow, Options, Durability)
  → TooltipWidget = Create Widget (WBP_ItemTooltip)
  → TooltipWidget.Initialize(Item Data)
  → Add to Viewport (ZOrder alto)
  → Set Position in Viewport(MousePosition + Offset)

OnDragDetected
  → Create Widget (WBP_ItemGhost)
  → Set BrushFromTexture(Item.Icon)
  → DragOp.DefaultDragVisual = ItemGhost
  → DragOp.Payload = SlotReference</code></pre>
        <h4>5. Backend &amp; Persistência</h4>
        <ul>
          <li>
            Endpoints mínimos: <code>GET /characters/{id}/inventory</code>, <code>POST /inventory/move</code>,
            <code>POST /inventory/drop</code>, <code>POST /inventory/pickup</code>, <code>POST /inventory/update-stats</code>.
          </li>
          <li>
            Persistir estado visual (durabilidade, tempo restante de itens periódicos) replicando
            <code>m_PeriodicItemTime</code>. Retornar <code>serverTime</code> para cálculo cliente.
          </li>
          <li>
            Utilizar filas (ex.: Redis Streams) para confirmar drops massivos e evitar race conditions em mapas lotados.
          </li>
        </ul>
        <div class="callout">
          <strong>Checklist rápido:</strong>
          <ul>
            <li>Todos os itens possuem <em>RowName</em> e ícone importado? (conferir via <code>Data Validation</code>).</li>
            <li>Colisões dos pickups respeitam <code>CheckStandAttr</code> e impedem drops em áreas proibidas?</li>
            <li>Tooltips reproduzem cores, fontes e texto dinâmico (durabilidade, opções, sockets) do cliente original?</li>
            <li>Arrastar/soltar sincroniza com o backend e restaura estado quando a operação é negada?</li>
          </ul>
        </div>
      </article>

      <article class="conversion-pane" data-pane="inventory">
        <h3>Inventário, Slots e Equipamentos</h3>
        <p>O inventário é criado por <code>CNewUIMyInventory</code>, instanciando um <code>CNewUIInventoryCtrl</code> e carregando os frames de fundo, botões e slots.</p>
        <div class="source-card">
          <div class="source-meta">Cliente – <code>Source Main 5.2/source/NewUIMyInventory.cpp</code></div>
          <pre><code>bool SEASON3B::CNewUIMyInventory::Create(CNewUIManager* pNewUIMng,
        CNewUI3DRenderMng* pNewUI3DRenderMng, int x, int y)
{
        m_pNewInventoryCtrl = new CNewUIInventoryCtrl;
        if(false == m_pNewInventoryCtrl->Create(m_pNewUI3DRenderMng, g_pNewItemMng,
                this, x+15, y+200, 8, 8))
        {
                SAFE_DELETE(m_pNewInventoryCtrl);
                return false;
        }

        SetPos(x, y);
        LoadImages();
        SetEquipmentSlotInfo();
        SetButtonInfo();
        Show(false);
        return true;
}</code></pre>
        </div>
        <h4>Como migrar para Widget Blueprint</h4>
        <ol>
          <li>Converter os sprites <code>Interface\newui_item_back*.ozt</code>, <code>Interface\newui_item_table*.ozt</code>, <code>Interface\newui_exit_00.ozt</code> e ícones de slots para <code>.png</code>. Use as dimensões originais (ex.: 190×320 para o fundo) e mantenha o padding.</li>
          <li>Criar <code>WBP_Inventory</code> com Canvas 640×480. Posicionar o background em <code>(15, 200)</code> para replicar <code>x+15, y+200</code>.</li>
          <li>Adicionar <code>UniformGridPanel</code> 8×8 com células 32×32. Cada item deve armazenar <code>GridX</code>, <code>GridY</code>, <code>Width</code> e <code>Height</code> para suportar itens 2×n.</li>
          <li>Implementar <code>BP_InventoryComponent</code> no personagem com array de <code>FInventorySlot</code> (ItemID, Quantidade, Rotação, Estados). Expor eventos <code>OnItemAdded</code>, <code>OnItemRemoved</code>, <code>OnSlotUpdated</code>.</li>
          <li>No widget, ligar os eventos para replicar <code>AddItem</code>, <code>DeleteItem</code> e <code>FindItemAtPt</code>, atualizando ícones e highlights.</li>
          <li>Para equipamentos, criar painel lateral com slots nomeados. Mapeie <code>MAX_EQUIPMENT_INDEX</code> e <code>EQUIPMENT_WEAPON_LEFT</code> para <em>Enums</em> blueprint e chame o gateway REST equivalente a <code>SendRequestEquippingInventoryItem</code>.</li>
        </ol>
        <h4>Blueprint sugerido (arrastar &amp; soltar)</h4>
        <pre><code>OnMouseButtonDown (ItemSlot)
  → DetectDragIfPressed

OnDragDetected
  → Create DragDropOperation
  → Operation.Payload = SlotData
  → Operation.DefaultDragVisual = WBP_ItemGhost (usa sprite original)

OnDrop
  → TargetSlot = Grid.Coordenada
  → InventoryComponent.TryMoveItem(Payload.Index, TargetSlot)
  → Se sucesso → AtualizarSlotVisual(TargetSlot)
  → Se falha → Reverter visual</code></pre>
        <div class="callout warning">
          <strong>Sincronização com o servidor:</strong> Cada movimento deve chamar <code>POST /inventory/move</code> replicando as mesmas validações de <code>CGItemDropRecv</code> (itens bloqueados, periódicos, lucky items). O backend precisa retornar o inventário atualizado para evitar divergências.</div>
      </article>

      <article class="conversion-pane" data-pane="progression">
        <h3>Progressão de Experiência (Cliente + Servidor)</h3>
        <p>O cliente calcula a fração da barra enquanto o servidor controla o ganho de XP e a distribuição de pontos.</p>
        <div class="source-card">
          <div class="source-meta">Cliente – <code>RenderExperience()</code> em <code>NewUIMainFrameWindow.cpp</code></div>
          <pre><code>float fNeedExp = dwNexExperience - dwPriorExperience;
float fExp = dwExperience - dwPriorExperience;
float fExpBarNum = (fExp / fNeedExp) * 10.f;
float fProgress = fExpBarNum - (int)fExpBarNum;
RenderBitmap(IMAGE_GAUGE_EXBAR, 2.f, 473.f, fProgress * 629.f, 4.f, 0.f, 0.f, 6.f/8.f, 4.f/4.f);
SEASON3B::RenderNumber(635.f, 469.f, (int)fExpBarNum);</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Servidor – <code>CObjectManager::CharacterLevelUp</code></div>
          <pre><code>if((lpObj->Experience+AddExperience) < lpObj->NextExperience)
{
        lpObj->Experience += AddExperience;
        return 0;
}

while(true)
{
        lpObj->Level++;
        lpObj->LevelUpPoint += gServerInfo.m_LevelUpPoint[lpObj->Class];
        AddExperience -= (((--MaxLevelUp)==0)?AddExperience:(lpObj->NextExperience-lpObj->Experience));
        lpObj->Experience = lpObj->NextExperience;
        gObjCalcExperience(lpObj);
        if((lpObj->Experience+AddExperience) < lpObj->NextExperience)
        {
                lpObj->Experience += AddExperience;
                break;
        }
}</code></pre>
        </div>
        <h4>Blueprint + Backend</h4>
        <ol>
          <li>Criar <code>BP_ProgressionComponent</code> com tabela de XP importada do servidor. Variáveis: <code>CurrentXP</code>, <code>NextXP</code>, <code>Level</code>, <code>PendingLevelUps</code>, <code>PointsToSpend</code>.</li>
          <li>Ao receber XP do servidor (resposta ao equivalente de <code>CharacterLevelUp</code>), aplicar a lógica <code>while</code> em Blueprint para consumir múltiplos level ups.</li>
          <li>Disparar <code>OnLevelUp</code> para atualizar atributos, HUD e tocar efeitos. Reaproveitar animações <code>FX_LevelUp</code> e sons originais.</li>
          <li>Persistir pontos gastando via endpoint <code>POST /characters/{id}/stats</code>, enviando <code>PointsToSpend</code> e atributos finais.</li>
        </ol>
        <h4>Blueprint de processamento</h4>
        <pre><code>OnReceiveXPUpdate (Payload)
  → CurrentXP = Payload.CurrentXP
  → NextXP = Payload.NextXP
  → Level = Payload.Level
  → PointsToSpend = Payload.Points
  → PendingLevelUps = Payload.LevelUps
  → HUDWidget.AtualizarXP(CurrentXP, NextXP)
  → For Loop (Index = 0 .. PendingLevelUps-1)
        → HUDWidget.PlayAnimation(LevelUpAnim)
        → SpawnEmitterAtLocation(FX_LevelUp)
        → PlaySound(LevelUpSound)</code></pre>
        <div class="callout">
          <strong>Validação:</strong> mantenha o cálculo oficial no backend para evitar exploits. O Blueprint apenas replica o resultado para feedback imediato.</div>
      </article>

      <article class="conversion-pane" data-pane="drops">
        <h3>Sistema de Drop e Restrições</h3>
        <p>Os drops verificam múltiplas condições antes de delegar ao mapa. O mesmo fluxo deve existir no backend moderno.</p>
        <div class="source-card">
          <div class="source-meta">Servidor – <code>Source MuServer Update 15/GameServer/GameServer/ItemManager.cpp</code></div>
          <pre><code>void CItemManager::CGItemDropRecv(PMSG_ITEM_DROP_RECV* lpMsg,int aIndex)
{
        CItem* lpItem = &lpObj->Inventory[lpMsg->slot];
        if(lpItem->IsLuckyItem() != 0 || lpItem->m_IsPeriodicItem != 0)
        {
                DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
                return;
        }
        if(gItemMove.CheckItemMoveAllowDrop(lpItem->m_Index) == 0)
        {
                DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
                return;
        }
        ...
        if(gMap[lpObj->Map].ItemDrop(lpItem->m_Index,lpItem->m_Level,lpItem->m_Durability,
                lpMsg->x,lpMsg->y,lpItem->m_Option1,lpItem->m_Option2,lpItem->m_Option3,
                lpItem->m_NewOption,lpItem->m_SetOption,lpItem->m_Serial,aIndex,
                lpItem->m_PetItemLevel,lpItem->m_PetItemExp,lpItem->m_JewelOfHarmonyOption,
                lpItem->m_ItemOptionEx,lpItem->m_SocketOption,lpItem->m_SocketOptionBonus,
                lpItem->m_PeriodicItemTime) == 0)
        {
                DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
                return;
        }
        this->InventoryDelItem(aIndex,lpMsg->slot);
}</code></pre>
        </div>
        <h4>Plano de conversão</h4>
        <ol>
          <li>Expor endpoint <code>POST /drops</code> que recebe ItemID, opções e posição. Aplicar as mesmas validações (Lucky, Periodic, Lock, Bag Manager) antes de autorizar.</li>
          <li>No UE5, criar <code>BP_LootService</code> para enviar a requisição e spawnar <code>BP_ItemPickup</code> apenas após sucesso.</li>
          <li>Reutilizar meshes e partículas originais. Para gemas, reaplicar <code>FX_Drop</code> e as cores herdadas de <code>newui_item_table</code>.</li>
          <li>Manter sincronia: se o servidor negar, tocar som de erro e cancelar o arraste (equivalente ao <code>DataSend</code> com <code>result = 0</code>).</li>
        </ol>
        <pre><code>Function RequestDrop(ItemSlot, GridPos)
  → Build Payload (Slot, GridPos, ItemOptions)
  → HTTP POST /drops
  → OnSuccess:
        Inventory.RemoveSlot(ItemSlot)
        SpawnActor(BP_ItemPickup, GridPos)
  → OnError:
        HUD.ShowMessage("Drop negado: motivo")
        Inventory.RefreshSlot(ItemSlot)</code></pre>
        <div class="callout">
          <strong>Triggers especiais:</strong> Kalima Gate, Mercenary, Life Stone e eventos sazonais têm ramos dedicados no código. Crie tabelas <code>DT_SpecialDrop</code> e trate-as antes da lógica genérica para manter o comportamento original.</div>
      </article>

      <article class="conversion-pane" data-pane="character-select">
        <h3>Seleção de Personagens &amp; Criação</h3>
        <p>
          A tela de seleção no cliente legado combina <code>CCharSelMainWin</code> (botões e faixa superior),
          <code>CharMakeWin</code> (criação) e rotinas de câmera em <code>ZzzScene.cpp</code>. A UE5 deve
          reproduzir a mesma disposição dos cinco slots, controle por teclado/mouse e integração com o
          backend (lista de personagens, criação, deleção e entrada no jogo).
        </p>
        <div class="source-card">
          <div class="source-meta">Cliente – <code>Source Main 5.2/source/CharSelMainWin.cpp</code></div>
          <pre><code>void CCharSelMainWin::Create()
{
        m_asprBack[DECO].Create(189, 103, BITMAP_LOG_IN+2);
        m_aBtn[CREATE].Create(54, 30, BITMAP_LOG_IN+3, 4, 2, 1, 3);
        m_aBtn[CONNECT].Create(54, 30, BITMAP_LOG_IN+5, 4, 2, 1, 3);
        CWin::Create(m_aBtn[0].GetWidth() * CSMW_BTN_MAX + m_asprBack[INFO].GetWidth() + 6,
                     m_aBtn[0].GetHeight(), -2);
}

void CCharSelMainWin::SetPosition(int nX, int nY)
{
        m_aBtn[CREATE].SetPosition(nX, nY);
        m_aBtn[MENU].SetPosition(nX + nBtnWidth + 1, nY);
        m_aBtn[DELETE].SetPosition(nWinRight - nBtnWidth, nY);
        m_aBtn[CONNECT].SetPosition(nWinRight - (nBtnWidth * 2 + 1), nY);
}

void CCharSelMainWin::UpdateWhileActive(double)
{
        if (m_aBtn[CONNECT].IsClick()) ::StartGame();
        else if (m_aBtn[CREATE].IsClick()) rUIMng.ShowWin(&rUIMng.m_CharMakeWin);
        else if (m_aBtn[DELETE].IsClick()) DeleteCharacter();
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Criação de personagem – <code>Source Main 5.2/source/CharMakeWin.cpp</code></div>
          <pre><code>CWin::Create(ScreenWidth, ScreenHeight);
m_asprBack[INPUT].Create(346, 38, BITMAP_LOG_IN);
m_abtnJob[i].Create(108, 26, BITMAP_LOG_IN+1, 4, 2, 1);
m_aBtn[OK].SetPosition(nBaseX, nBaseY);
m_aBtn[CANCEL].SetPosition(nX + 400, nBaseY);
UpdateDisplay(); // ativa/desativa classes, textos e preview
</code></pre>
        </div>
        <h4>Layout e reaproveitamento de assets</h4>
        <ul>
          <li><strong>Slots 3D:</strong> a cena <code>CreateCharacterScene()</code> ( <code>ZzzScene.cpp</code> ) posiciona até cinco
            personagens em torno de um pivot central. No UE5, usar um <code>Level Sequence</code> ou <code>Camera Rail</code>
            com cinco <code>BP_CharacterPreview</code> em posições equivalentes (distância ~240 unidades, ângulos 20°).</li>
          <li><strong>Painel superior:</strong> recriar um <code>WBP_CharSelectTopBar</code> com <em>Horizontal Box</em> (Create,
            Menu, Connect, Delete) usando as mesmas texturas <code>newui_btn_charselect_*.ozj</code>.</li>
          <li><strong>Painel informativo:</strong> <code>m_asprBack[INFO]</code> tem largura dinâmica. No UMG, usar <em>Size Box</em>
            ancorada ao topo direito exibindo servidor, avisos e status de bloqueio (texto amarelo quando <code>m_bAccountBlockItem</code>).</li>
          <li><strong>Janela de criação:</strong> a malha de botões (classes) segue colunas 108×26. Em UE5, usar <code>UniformGridPanel</code>
            com <code>Slot Padding = 2</code> e fontes idênticas para manter alinhamento.</li>
        </ul>
        <h4>Fluxo UE5 recomendado</h4>
        <ol>
          <li><em>Game Instance</em> chama <code>ServerGateway.ListCharactersAsync()</code> após login e repassa o resultado para
            <code>WBP_CharacterSelect</code>.</li>
          <li>O widget cria cinco <code>WBP_CharacterSlot</code> que exibem nome, classe, nível e ícones reutilizando sprites do
            inventário (asas, armas). Slots vazios exibem botão “Create”.</li>
          <li>Ao focar um slot, a câmera interpola para o personagem correspondente e toca animação de idle específica
            (mapeada por classe em uma <code>Data Table</code> derivada de <code>CharacterManager.cpp</code>).</li>
          <li>O botão “Connect” chama <code>POST /sessions/enter</code> com <code>CharacterId</code>. Ao sucesso, carrega o mapa
            e aplica dados iniciais (inventário, posição) retornados pelo backend.</li>
          <li>O botão “Delete” abre <code>WBP_Confirmation</code>. Se confirmado, chama <code>DELETE /characters/{id}</code> e
            remove o slot da lista.</li>
        </ol>
        <h4>Blueprint – Widgets principais</h4>
        <pre><code>WBP_CharacterSelect::Event Construct
  → Bind ListCharactersAsync::OnSuccess → PopulateSlots
  → ServerGateway.ListCharactersAsync()

PopulateSlots(Characters)
  → For Index 0..4
        → SlotWidget = CreateWidget(WBP_CharacterSlot)
        → SlotWidget.Setup(Characters[Index])
        → Grid.AddChildToUniformGrid(SlotWidget, Row, Column)
        → SlotWidget.OnSelected.Bind → HandleSlotSelected

HandleSlotSelected(CharData)
  → PreviewManager.ShowCharacter(CharData)
  → SelectedCharacter = CharData
  → UpdateButtons(SelectedCharacter != null)

OnClickConnect
  → ServerGateway.EnterWorldAsync(SelectedCharacter.Id)
  → OnSuccess → OpenLevel(CharData.StartMap)

OnClickCreate
  → OpenWidget(WBP_CharacterCreation)

WBP_CharacterCreation::OnConfirm(Name, Class)
  → ServerGateway.CreateCharacterAsync(Name, Class)
  → OnSuccess → RefreshCharacterList()</code></pre>
        <div class="callout">
          <strong>Dicas adicionais:</strong> mantenha o estado <code>SelectedHero</code> no <em>Player State</em> para compartilhar
          a escolha com outros subsistemas (inventário inicial, cinematics). Registre telemetria para ações de delete/criar,
          replicando os logs do <em>GameServer</em> original.</div>
      </article>

      <article class="conversion-pane" data-pane="mobs">
        <h3>Sistema de Mobs (Spawn &rarr; IA &rarr; Drop)</h3>
        <p>
          O backend antigo controla spawn e comportamento dos mobs através de tabelas e estados pré-definidos. A
          reconstrução na UE5 deve preservar o fluxo original: carregar pontos de spawn, rodar IA temporizada, emitir
          mensagens de estado e conceder drop/XP após a morte.
        </p>
        <div class="source-card">
          <div class="source-meta">Servidor &mdash; <code>MonsterSetBase.cpp</code></div>
          <pre><code>void CMonsterSetBase::Load(char* path)
{
        ...
        info.Type = section;
        info.MonsterClass = lpMemScript->GetNumber();
        info.Map = lpMemScript->GetAsNumber();
        info.Dis = lpMemScript->GetAsNumber();
        info.X = lpMemScript->GetAsNumber();
        info.Y = lpMemScript->GetAsNumber();
        if(section == 1 || section == 3)
        {
                info.Dir = lpMemScript->GetAsNumber();
                info.RespawnTime = lpMemScript->GetAsNumber();
        }
        ...
        this->SetInfo(this->m_count,&info);
        this->m_count++;
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Servidor &mdash; <code>MonsterAI.cpp</code></div>
          <pre><code>if((GetTickCount()-lpObj->LastAIRunTime) < ((DWORD)lpMonsterAIUnitInfo->m_DelayTime))
{
        return 0;
}

if(lpMonsterAIUnitInfo->RunAIUnitInfo(aIndex) == 0)
{
        return 0;
}

lpObj->LastAIRunTime = GetTickCount();</code></pre>
        </div>
        <h4>Etapas de conversão</h4>
        <ol>
          <li><strong>Dados:</strong> converter <code>Monster.txt</code>, <code>MonsterSetBase.txt</code> e tabelas auxiliares em <code>DT_MobStats</code> e <code>DT_MobSpawn</code>.</li>
          <li><strong>Spawn:</strong> criar <code>BP_MobSpawner</code> que lê <code>DT_MobSpawn</code>, posiciona pontos com base em <code>X</code>/<code>Y</code> convertidos (multiplique por <code>TERRAIN_SCALE</code>) e solicita instâncias ao backend.</li>
          <li><strong>Instância:</strong> <code>BP_MobCharacter</code> aplica atributos de <code>DT_MobStats</code> (HP, Defesa, Velocidade) e inicia <code>Behavior Tree</code> equivalente ao AI Unit do legado.</li>
          <li><strong>Mensagens:</strong> use <code>Gameplay Message Subsystem</code> ou <code>Multicast RPC</code> para representar <code>ProcessStateMsg</code> (drop, knockback, reset, efeitos).</li>
          <li><strong>Respawn:</strong> armazenar <code>RespawnTime</code> e agendar timers locais apenas após confirmação do servidor, replicando <code>MonsterManager::RespawnMonster</code>.</li>
        </ol>
        <h4>Blueprint de morte, drop e XP</h4>
        <pre><code>Event OnMobDied (DamageContext)
  → Send HTTP (POST /world/mob/{MobInstanceID}/death)
        Body = { KillerId, MapId, Position }
  → OnSuccess (Payload)
        → ForEach Loot in Payload.LootEntries
              SpawnActor(BP_ItemPickup, Loot.Location)
        → Broadcast OnExperienceReceived(Payload.XPArray)
        → ScheduleRespawn(Payload.RespawnInSeconds)

Function ScheduleRespawn(Time)
  → SetTimer(Time)
  → OnTimer → Request Spawn novamente (SpawnerId)</code></pre>
        <div class="callout warning">
          <strong>Validação crítica:</strong> mantenha o cálculo de agro e ataque no servidor (arquivos <code>MonsterAIAgro.cpp</code>, <code>Attack.cpp</code>). O cliente apenas apresenta o resultado, evitando exploits.</div>
        <div class="callout">
          <strong>Checklist:</strong>
          <ul>
            <li>Coordenadas e direções importadas respeitam a malha convertida? (teste com gizmo de depuração).</li>
            <li>Timers de IA replicam <code>m_DelayTime</code> para cada AI Unit.</li>
            <li>Mensagens de estado (código 1, 2, 3, 55, 56, 57) possuem equivalente em eventos UE5.</li>
            <li>Perfis especiais (bosses) usam Behavior Trees específicos com tarefas que consultam <code>MonsterSkillManager.cpp</code>.</li>
          </ul>
        </div>
      </article>

      <article class="conversion-pane" data-pane="skills">
        <h3>Sistema de Skills (Jogador &amp; Mob)</h3>
        <p>
          Os scripts legados definem custo, alcance, cooldown e efeitos adicionais para cada skill. Ao portar para a UE5,
          replique as mesmas estruturas de dados e sincronize casting/cancelamento com o backend antes de aplicar efeitos visuais.
        </p>
        <div class="source-card">
          <div class="source-meta">Servidor &mdash; <code>SkillManager.cpp</code></div>
          <pre><code>info.Index = lpMemScript->GetNumber();
strcpy_s(info.Name,lpMemScript->GetAsString());
info.Damage = lpMemScript->GetAsNumber();
info.Mana = lpMemScript->GetAsNumber();
info.Range = lpMemScript->GetAsNumber();
info.Delay = lpMemScript->GetAsNumber();
info.Type = lpMemScript->GetAsNumber();
info.Effect = lpMemScript->GetAsNumber();
info.RequireLevel = lpMemScript->GetAsNumber();
...</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Cliente &mdash; <code>SkillEffectMgr.cpp</code></div>
          <pre><code>void CSkillEffectMgr::DeleteEffect(int efftype)
{
        for(int i=0;i<MAX_SKILL_EFFECTS;i++)
        {
                OBJECT *o = &m_SkillEffects[i];
                if(o->Live && o->Type==efftype)
                {
                        EffectDestructor(o);
                }
        }
}

bool CSkillEffectMgr::SearchEffect(int iType, OBJECT* pOwner, int iSubType)
{
        for(int i=0; i<MAX_SKILL_EFFECTS; ++i)
        {
                OBJECT *o = &m_SkillEffects[i];
                if(o->Live && o->Type == iType && o->Owner == pOwner)
                {
                        if(iSubType == -1 || o->SubType == iSubType)
                        {
                                return true;
                        }
                }
        }
        return false;
}</code></pre>
        </div>
        <h4>Passos para a UE5</h4>
        <ol>
          <li><strong>Dados:</strong> gerar <code>DT_SkillCatalog</code> com campos de custo, alcance, delay e requisitos por classe exatamente como <code>SkillManager.cpp</code> carrega.</li>
          <li><strong>Componente:</strong> implementar <code>BP_SkillComponent</code> que associa <code>SkillID</code> a um <code>UGameplayAbility</code> ou função Blueprint responsável por validar recurso (mana/bp) e enviar requisição ao servidor.</li>
          <li><strong>Cooldown:</strong> armazenar <code>LastCastTime</code> retornado pelo backend e popular <code>WBP_SkillBar</code> com progresso circular (usando os ícones originais).</li>
          <li><strong>Efeitos:</strong> converter efeitos persistentes em <code>Gameplay Effects</code> e <code>Niagara Systems</code> referenciando o dono (equivalente a <code>Owner</code> em <code>SkillEffectMgr</code>).</li>
          <li><strong>Sincronização:</strong> sempre aguardar confirmação do backend para habilidades que causam dano. Para buffs/visual, é possível reproduzir imediatamente, mas envie <code>POST /skills/cast</code> para validar.</li>
        </ol>
        <h4>Blueprint resumido</h4>
        <pre><code>Event InputSkill (SkillSlot)
  → SkillID = Hotbar[SkillSlot]
  → Dados = DT_SkillCatalog[SkillID]
  → If Cooldown.Ativo → HUD.FlashCooldown(SkillSlot)
  → Else → TryCastSkill(SkillID)

Function ApplySkillResponse (Payload)
  → ForEach Target in Payload.Targets
        → ApplyGameplayEffectToTarget(Target, Payload.EffectHandle)
  → HUD.UpdateCooldown(Payload.SkillID, Payload.Cooldown)
  → If Payload.SpawnFX → SpawnSystemAtLocation(Payload.SpawnFX, Payload.Location)</code></pre>
        <div class="callout">
          <strong>Pontos de validação:</strong>
          <ul>
            <li>Confirme que o consumo de mana/stamina bate com valores originais (diferença máxima aceitável ±1).</li>
            <li>Buffs exclusivos (ex.: Soul Barrier) devem impedir múltiplas instâncias simultâneas assim como <code>SearchEffect</code>.</li>
            <li>Habilidades de mobs reutilizam o mesmo pipeline com perfis automáticos gerados a partir de <code>MonsterSkillManager.cpp</code>.</li>
            <li>Registre métricas de latência de cast para ajustar tolerâncias de cancelamento.</li>
          </ul>
        </div>
      </article>

      <article class="conversion-pane" data-pane="companions">
        <h3>Companheiros Muun, Pentagrama e Helper</h3>
        <p>
          Os executáveis originais combinam UI dedicada para pets em <code>NewUIPetInfoWindow.cpp</code>
          com lógicas de servidor em <code>MuunSystem.cpp</code>, <code>PentagramSystem.cpp</code> e
          <code>Helper.cpp</code>. Esta aba mostra como portar companions, joias elementais e o sistema
          automático preservando os mesmos dados e limites.
        </p>
        <div class="source-card">
          <div class="source-meta">Cliente &mdash; <code>Source Main 5.2/source/NewUIPetInfoWindow.cpp</code></div>
          <pre><code>LoadBitmap("Interface\\newui_msgbox_back.jpg", IMAGE_PETINFO_BACK, GL_LINEAR);
LoadBitmap("Interface\\newui_pet_lifebar01.jpg", IMAGE_PETINFO_LIFEBAR, GL_LINEAR);
LoadBitmap("Interface\\newui_pet_lifebar02.jpg", IMAGE_PETINFO_LIFE, GL_LINEAR);</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Servidor &mdash; <code>MuunSystem.cpp</code>, <code>PentagramSystem.cpp</code>, <code>Helper.cpp</code></div>
          <pre><code>gMuunSystem.MainProc();            // User.cpp: atualiza buffs Muun
gPentagramSystem.Load("Item\\PentagramOption.txt");
if(lpObj->HelperDelayTime != 0) {  // Helper.cpp
        lpObj->Money -= (lpObj->Level+lpObj->MasterLevel)*gServerInfo.m_HelperActiveMoney[HelperStage];
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Configuração &mdash; <code>ServerInfo.cpp</code></div>
          <pre><code>gMuunSystem.Load(gPath.GetFullPath("Item\\MuunOption.txt"));
gPentagramSystem.LoadJewel(gPath.GetFullPath("Item\\PentagramJewelOption.txt"));
gPcPoint.Load(gPath.GetFullPath("PcPoint.txt"));</code></pre>
        </div>
        <h4>Fluxo de Blueprint</h4>
        <ol>
          <li><strong>Componentes:</strong> criar <code>BP_MuunComponent</code>, <code>BP_PentagramComponent</code> e <code>BP_HelperSubsystem</code> anexados ao personagem. Eles carregam <code>Data Tables</code> derivados de <code>MuunOption</code>, <code>PentagramOption</code> e <code>PcPoint.txt</code>.</li>
          <li><strong>UI:</strong> construir <code>WBP_MuunPanel</code> usando as texturas convertidas (<code>newui_pet_lifebar*</code>) e adicionar abas para slots elementais e configurações do Helper.</li>
          <li><strong>Interação:</strong> expor bindings para <code>Equipar</code>/<code>Remover</code> companion, inserir joias em sockets e alternar o Helper. Cada ação dispara <code>POST</code>/<code>DELETE</code> no gateway replicando <code>CGMuunUseRecv</code>, <code>CGPentagramJewelInsertRecv</code> e <code>CGHelperStartRecv</code>.</li>
          <li><strong>Feedback:</strong> renderizar efeitos (Niagara/Skeletal Mesh) conforme dados de <code>MuunSprite</code> e aplicar materiais elementais com multiplicadores provenientes do backend.</li>
        </ol>
        <h4>Integração Backend</h4>
        <ol>
          <li>Fornecer <code>/companions</code> (GET/POST/DELETE) carregando <code>Item/MuunOption.txt</code> e respeitando <code>EvolutionItemIndex</code>.</li>
          <li>Implementar <code>/pentagram/socket</code> com validações de rank/nível segundo <code>PentagramJewelOption.txt</code> e taxas de <code>PentagramJewelMixRate.txt</code>.</li>
          <li>Sincronizar o Helper via WebSocket enviando mensagens <code>HelperStart</code>/<code>HelperStop</code> quando o servidor deduz Zen ou encerra por mapa inválido (seguindo <code>CHelper::DisableHelper</code>).</li>
          <li>Compartilhar o saldo PcPoint no mesmo canal das notificações de loja para atualizar o HUD (reutilize o payload que substitui <code>GDPcPointPointSend</code>).</li>
        </ol>
        <h4>Blueprint Exemplo</h4>
        <pre><code>// BP_MuunComponent
Event BeginPlay
  Load Data Table Row (MuunID)
  Spawn Companion Actor (SkeletalMesh from Data)
  AttachToComponent(CharacterMesh, SocketName)

Event ToggleHelper(bEnable)
  If bEnable
    -> HTTP POST /helper/start { Map = CurrentMap }
  Else
    -> HTTP POST /helper/stop

Event OnHelperUpdate(Payload)
  HelperState = Payload.State
  Owner.HUD.UpdateHelperStatus(HelperState.CostPerMinute, HelperState.ElapsedMinutes)</code></pre>
        <div class="callout">
          <strong>Checklist:</strong>
          <ul>
            <li>Texturas convertidas mantém offsets <code>(15,200)</code> e <code>(x+12, y+48)</code> herdados do cliente.</li>
            <li>Endpoints validam Zen/custos conforme <code>m_HelperActiveMoney</code> e bloqueiam mapas proibidos (<code>GetMapHelperEnable</code>).</li>
            <li>Companions atualizam atributos conforme <code>MuunSystemInfo.OptionValue</code> e exibem rank/evolução corretos.</li>
            <li>O dano elemental reproduz multiplicadores retornados pelo backend antes de aplicar <code>Gameplay Effects</code>.</li>
          </ul>
        </div>
      </article>

      <article class="conversion-pane" data-pane="social">

        <h3>Party, Guild e Sistema Gens</h3>
        <p>
          A camada social original combina UI em <code>NewUIPartyListWindow.cpp</code>/<code>NewUIPartyInfoWindow.cpp</code>,
          gerenciamento de guildas no cliente e protocolos do servidor em <code>Party.cpp</code>,
          <code>Guild.cpp</code>, <code>GuildMatching.cpp</code> e <code>GensSystem.cpp</code>.
          Esta aba mostra como espelhar convites, gerenciamento e rivalidades Gens na UE5 reaproveitando
          assets e regras herdadas.
        </p>
        <div class="source-card">
          <div class="source-meta">Cliente &mdash; <code>Source Main 5.2/source/NewUIPartyListWindow.cpp</code></div>
          <pre><code>if( CheckMouseIn( m_Pos.x, m_Pos.y+iVal, PARTY_LIST_WINDOW_WIDTH, PARTY_LIST_WINDOW_HEIGHT) )
{
        m_iSelectedCharacter = i;

        if( SelectedCharacter==-1) {
                CHARACTER *c = &CharactersClient[Party[i].index];
                if( c && c != Hero ) {
                        CreateChat ( c->ID, "", c );
                }
        }

        if( SelectCharacterInPartyList( &Party[i] ) )
        {
                return true;
        }
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/Party.cpp</code></div>
          <pre><code>if(this->m_PartyInfo[count].Count == 0)
{
        gObj[aIndex].PartyNumber = count;
        this->m_PartyInfo[count].Count = 1;
        this->m_PartyInfo[count].Index[0] = aIndex;

        for(int i=1;i < MAX_PARTY_USER;i++)
        {
                this->m_PartyInfo[count].Index[i] = -1;
        }
        this->GCPartyListSend(count);
        this->m_PartyCount = (((++this->m_PartyCount)>=MAX_OBJECT)?0:this->m_PartyCount);
        return 1;
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/Guild.cpp</code></div>
          <pre><code>if(lpTarget->GuildNumber == 0)
{
        this->GCGuildResultSend(aIndex,4);
        return;
}

if(strcmp(lpTarget->Guild->Names[0],lpTarget->Name) != 0)
{
        this->GCGuildResultSend(aIndex,4);
        return;
}

if(lpObj->Interface.use != 0 || lpTarget->Interface.use != 0)
{
        this->GCGuildResultSend(aIndex,6);
        return;
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/GensSystem.cpp</code></div>
          <pre><code>pMsg.header.set(0xF8,0x07,sizeof(pMsg));
pMsg.GensFamily = lpObj->GensFamily;
pMsg.GensRank = ((lpObj->GensContribution>=10000)?lpObj->GensRank:0);
pMsg.GensSymbol = lpObj->GensSymbol;
pMsg.GensContribution = lpObj->GensContribution;
pMsg.GensNextContribution = lpObj->GensNextContribution;
DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);</code></pre>
        </div>
        <h4>Passos para a UE5</h4>
        <ol>
          <li><strong>Assets:</strong> converta <code>Source Main 5.2/bin/Data/Interface/newui_Party_Back.ozt</code>,
            <code>newui_Party_X.ozt</code>, <code>newui_Party_Lifebar*.ozj</code> e ícones de guilda para <code>.png</code>.
            Posicione-os em <code>WBP_PartyPanel</code> com o espaçamento <code>m_iVal = 24</code> preservado.</li>
          <li><strong>Subsystem:</strong> crie <code>UPartySubsystem</code> em C++ ou Blueprint contendo arrays
            <code>FPartyMember</code> e eventos multicast (<code>OnPartyUpdated</code>) seguindo as estruturas
            de <code>m_PartyInfo</code>.</li>
          <li><strong>Protocolos:</strong> mapeie chamadas <code>/party/create</code>, <code>/party/invite</code>,
            <code>/party/kick</code> para microserviço que reproduz <code>Party.cpp</code> (máx. membros em
            <code>gServerInfo.m_PartyMaxMembers</code>). Use <code>Gameplay Message Router</code> para notificar HUD.</li>
          <li><strong>Party Matching:</strong> importe regras de <code>PartyMatching.cpp</code> e
            <code>Data/Custom/CustomMove.txt</code> para criar um widget de busca com filtros (nível, mapa, Gens).</li>
          <li><strong>Guild:</strong> construa <code>UGuildSubsystem</code> que mantém <code>GuildRank</code>,
            <code>Members</code> e <code>Alliance</code>. Implementar validações de convite conforme
            <code>CGGuildRequestRecv</code> e atualize banners convertendo emblemas (<code>GuildMark.bmp</code>) para
            <code>Runtime Virtual Texture</code>.</li>
          <li><strong>Gens:</strong> crie <code>UGensService</code> que consulta endpoints <code>/gens/member</code>,
            <code>/gens/rank</code> e aplica bloqueios de guild/party baseando-se em <code>ServerInfo.h</code>
            (<code>m_GensSystemGuildLock</code>, <code>m_GensSystemPartyLock</code>). Renderize contribuições
            na HUD usando dados da resposta e os ícones originais <code>newui_gens_*.ozj</code>.</li>
          <li><strong>Viewport:</strong> sincronize badges de rivalidade utilizando <code>BP_GensIndicatorComponent</code>
            que recebe <code>GensFamily</code>, <code>GensRank</code>, <code>GensSymbol</code> tal como
            <code>GCViewportGensSystemSend</code> envia.</li>
        </ol>
        <h4>Blueprint resumido</h4>
        <pre><code>// BP_SocialSubsystem
Event InitializeSubsystem()
  PartyService.Bind("/party/update", HandlePartyUpdate)
  GuildService.Bind("/guild/update", HandleGuildUpdate)
  GensService.Bind("/gens/member", HandleGensUpdate)

Function InviteToParty(TargetId)
  HTTP POST /party/invite { target = TargetId }

Function HandlePartyUpdate(Payload)
  PartyMembers = Payload.Members
  OnPartyUpdated.Broadcast(PartyMembers)
  HUD.PartyPanel.Refresh(PartyMembers)

Function HandleGensUpdate(Payload)
  CurrentGens = Payload.Family
  CurrentContribution = Payload.Contribution
  HUD.UpdateGensBadge(CurrentGens, CurrentContribution)</code></pre>
        <div class="callout">
          <strong>Checklist:</strong>
          <ul>
            <li>Valide limites de slots conforme <code>MAX_PARTYS</code> e <code>MAX_GUILD_USER</code>.</li>
            <li>Reaplique filtros de convite (estado da interface, mapas bloqueados) iguais aos retornos
              do servidor legado (<code>result = 4/5/6</code>).</li>
            <li>Incorpore comandos <code>/party</code>, <code>/guild</code>, <code>/gens</code> lendo
              <code>Data/Command.txt</code> e expondo atalhos no chat.</li>
            <li>Capture telemetria por evento (convites aceitos, expulsões, troca de família) e envie para o painel
              descrito em “Operações, Telemetria”.</li>
          </ul>
        </div>
      </article>

      <article class="conversion-pane" data-pane="maps">
        <h3>Mapas, Atributos e Respawns</h3>
        <p>O servidor lê os arquivos binários de mapa, armazena atributos e respawns fixos. Esses dados orientam a reconstrução no UE5.</p>
        <div class="source-card">
          <div class="source-meta">Servidor – <code>Source MuServer Update 15/GameServer/GameServer/Map.cpp</code></div>
          <pre><code>void CMap::Load(char* path,int map)
{
        BYTE width, height;
        ReadFile(file,&width,sizeof(width),&BytesRead,0);
        ReadFile(file,&height,sizeof(height),&BytesRead,0);
        this->m_width = width+1;
        this->m_height = height+1;
        int size = this->m_width * this->m_height;
        this->m_MapAttr = (BYTE*)GlobalAlloc(GPTR,size);
        ReadFile(file,this->m_MapAttr,size,&BytesRead,0);
        this->m_path->SetMapDimensions(this->m_width,this->m_height,this->m_MapAttr);
        this->m_MapNumber = map;
}

CMap::CMap()
{
        SetRect(&this->m_MapRespawn[0],130,116,151,137);
        SetRect(&this->m_MapRespawn[1],106,236,112,243);
        SetRect(&this->m_MapRespawn[2],197,35,218,50);
        SetRect(&this->m_MapRespawn[3],174,101,187,125);
}</code></pre>
        </div>
        <h4>Como portar para a UE5</h4>
        <ol>
          <li>Extrair os arquivos de atributos (<code>Map*.att</code>) e meshes (<code>Map*.bmd</code>) do cliente usando a mesma lógica de leitura. Cada byte representa um tile de 4×4 unidades.</li>
          <li>Converter a grade em <code>.csv</code> (X, Y, Attribute) e importar como <code>Data Table</code>. Use Blueprint ou C++ para gerar <code>Landscape</code> e <code>NavModifierVolume</code> conforme o atributo (walkable, noground, safezone).</li>
          <li>Criar <code>BP_MapAttributeVolume</code> que percorre as linhas no <code>BeginPlay</code>, aplicando materiais diferentes e registrando colisões.</li>
          <li>Respawns: transformar os retângulos <code>SetRect</code> em <code>BoxComponent</code> e registrar em <code>BP_GameMode</code> para spawn seguro de jogadores.</li>
          <li>Configurar World Partition subdividindo nos mesmos blocos do cliente (ex.: 256×256 tiles). Reutilizar texturas <code>Data/World</code> e ajustar colisões com base na escala 1 tile = 100 unidades da UE5.</li>
        </ol>
        <pre><code>Event BeginPlay (BP_MapAttributeVolume)
  → ForEach Row (DT_MapAtt)
        → SpawnVolume = AddInstance(Attr == TW_NOGROUND ? NoWalkMaterial : WalkableMaterial)
        → If Attr == TW_SAFEZONE → RegisterRespawnArea(Location, Extent)
        → If Attr == TW_WATER → ApplyWaterPostProcess(Location)</code></pre>
        <div class="callout">
          <strong>Coordenadas originais:</strong> mantenha a escala 1 tile = 100 unidades da UE5 para garantir alinhamento de colisão, alcance de habilidades e posições de NPC.</div>
        <details class="guia">
          <summary>Portais, Warp e Move Command</summary>
          <div class="grid-2">
            <div class="source-card">
              <div class="source-meta">Cliente &mdash; <code>Source Main 5.2/source/MoveCommandData.cpp</code></div>
              <pre><code>bool CMoveCommandData::Create(const std::string&amp; filename)
{
    FILE* fp = fopen(filename.c_str(), "rb");
    fread(&amp;count, sizeof(int), 1, fp);
    fread(&amp;(pMoveInfoData-&gt;_ReqInfo), sizeof(MOVEREQINFO), 1, fp);
    BuxConvert((BYTE*)&amp;(pMoveInfoData-&gt;_ReqInfo), sizeof(MOVEREQINFO));
    m_listMoveInfoData.push_back(pMoveInfoData);
}</code></pre>
            </div>
            <div class="source-card">
              <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/Move.cpp</code></div>
              <pre><code>void CMove::Load(char* path)
{
    MOVE_INFO info;
    info.Index    = lpMemScript-&gt;GetNumber();
    info.Name     = lpMemScript-&gt;GetAsString();
    info.Gate     = lpMemScript-&gt;GetAsNumber();
    this-&gt;m_MoveInfo.insert(std::pair&lt;int,MOVE_INFO&gt;(info.Index,info));
}

void CMove::Move(LPOBJ lpObj,int index)
{
    if(MoveInfo.MinLevel != -1 &amp;&amp; lpObj-&gt;Level &lt; gGate.GetMoveLevel(...))
    {
        gNotice.GCNoticeSend(lpObj-&gt;Index,1,0,0,0,0,0,gMessage.GetMessage(224),...);
        return;
    }
}</code></pre>
            </div>
          </div>
          <ol>
            <li>Extraia <code>Data/Local/&lt;ML&gt;/movereq_*.bmd</code> (cliente) e <code>Data/Move/Move.txt</code>, <code>Data/Move/Gate.txt</code> (servidor). Converta todos para <code>Data Tables</code> (<code>DT_WarpRequirements</code>, <code>DT_Gates</code>).</li>
            <li>Implemente um <code>BP_WarpService</code> que carrega as tabelas no <code>GameInstance</code>, expondo filtros por nível, reset, contribuição de Gens e custo em Zen idênticos a <code>MOVEREQINFO</code>.</li>
            <li>Recrie o widget UMG usando as coordenadas definidas em <code>CNewUIMoveCommandWindow::SetPos</code> (larguras dinâmicas por resolução) e listas com rolagem equivalente.</li>
            <li>No backend, replique as validações de <code>CMove::Move</code> e <code>Gate.cpp</code> antes de teleportar. Retorne códigos <code>result</code> compatíveis para atualizar o HUD de erro no cliente.</li>
            <li>Configure <code>BP_PortalActor</code> que consulta <code>DT_Gates</code>, posiciona <code>BoxComponent</code> com base nos retângulos e envia requisições <code>POST /warp</code> ao serviço.</li>
          </ol>
          <pre><code>// Blueprint (BP_WarpService)
Function RequestWarp(WarpIndex)
  → Requirements = DT_WarpRequirements[WarpIndex]
  → If !ValidateCharacter(Requirements) → ShowError(Requirements.FailCode)
  → Else CallHTTP("POST", "/warp", { Index: WarpIndex })
        → OnSuccess: Teleport Player to DT_Gates[Requirements.Gate].TargetTransform
        → OnFail: Surface server message via HUD Toast</code></pre>
          <div class="callout">
            <strong>Sincronização:</strong> utilize <code>MapServerManager.cpp</code> como referência para distribuir jogadores entre instâncias e mantenha os mesmos índices de gate para que spawns coincidam com <code>SetRect</code> configurado no carregamento do mapa.</div>
        </details>
      </article>

      <article class="conversion-pane" data-pane="effects">
        <h3>Efeitos e Partículas</h3>
        <p>O módulo de efeitos mantém arrays globais e verifica alcance contra personagens antes de aplicar o impacto.</p>
        <div class="source-card">
          <div class="source-meta">Cliente – <code>Source Main 5.2/source/ZzzEffect.cpp</code></div>
          <pre><code>PARTICLE  Particles[MAX_PARTICLES];
OBJECT Effects[MAX_EFFECTS];

bool AddRangeAttack(vec3_t Position, float Range, short PKKey, int DamageKey[], int* piCount, int iMaxKey)
{
        for(int i=0;i<MAX_CHARACTERS_CLIENT;i++)
        {
                CHARACTER *c = &CharactersClient[i];
                OBJECT *o = &c->Object;
                float dx = Position[0]-o->Position[0];
                float dy = Position[1]-o->Position[1];
                float Distance = sqrtf(dx*dx+dy*dy);
                if(o->Live && o->Visible && c!=Hero && !c->Dead && Distance<=Range)
                {
                        DamageKey[(*piCount)++] = c->Key;
                        if(*piCount >= iMaxKey) break;
                }
        }
        return true;
}</code></pre>
        </div>
        <h4>Estratégia Niagara</h4>
        <ol>
          <li>Converter texturas de partículas em <code>Data/Effect</code> para <code>.png</code> ou <code>.tga</code> padrão. Importar como Sprite ou Flipbook no Niagara.</li>
          <li>Criar <code>NS_RangeAttack</code> com inputs <code>Range</code>, <code>Color</code> e <code>DamageKeys</code>. Usar uma <em>Blueprint Function Library</em> para aplicar a mesma checagem de distância e disparar <code>GameplayCue</code>.</li>
          <li>Reaproveitar meshes <code>MODEL_*</code> exportadas para <code>.fbx</code> e usá-las em <code>Niagara Mesh Renderer</code> para raios, lasers e efeitos 3D.</li>
          <li>Centralizar o controle em <code>BP_EffectManager</code>, mantendo <code>Object Pool</code> para partículas similares ao array <code>Particles</code>.</li>
        </ol>
        <pre><code>Function SpawnRangeEffect (Origin, Range, Cue)
  → ActorsInRange = SphereOverlapActors(Range)
  → ForEach Alvo válido
        → ApplyGameplayEffectToTarget(Cue)
  → NiagaraComponent.SetVariableFloat("Range", Range)
  → NiagaraComponent.SetVariableLinearColor("Tint", Cue.Color)
  → NiagaraComponent.Activate()
  → AudioComponent.Play()</code></pre>
        <div class="callout">
          <strong>Feedback sonoro:</strong> mantenha o mapeamento das trilhas listadas em <code>Source Main 5.2/source/DSPlaySound.h</code>. No UE5, utilize <code>MetaSounds</code> com a mesma enumeração para sincronizar áudio e partículas.</div>
      </article>

      <article class="conversion-pane" data-pane="backend">
        <h3>Backend &amp; Serviços Modernizados</h3>
        <p>
          Recrie as responsabilidades do <em>GameServer</em>, <em>DataServer</em> e serviços auxiliares com APIs claras que a UE5 possa consumir
          via <code>HTTP</code>, <code>WebSocket</code> ou <code>gRPC</code>. Mantenha o vínculo com os mesmos dados herdados (SQL e arquivos
          <code>.txt</code>) enquanto aplica autenticação moderna e observabilidade.
        </p>
        <div class="grid-2">
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/Protocol.cpp</code></div>
            <pre><code>case 0x0F: // Skill use
    CGUseSkillRecv(aRecv, aIndex);
    break;

case 0x18: // Item pick
    CGItemGetRecv(aIndex, aRecv);
    break;

case 0x17: // Item drop
    gItemManager.CGItemDropRecv((PMSG_ITEM_DROP_RECV*)aRecv, aIndex);
    break;</code></pre>
          </div>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/DataServer/DBItemInfo.cpp</code></div>
            <pre><code>BOOL CDBItemInfo::LoadItemInfo(char* szName, BYTE* lpItemInfo)
{
    int nReturn = this->m_DBQuery.Fetch();
    if(nReturn == SQL_NO_DATA) return FALSE;
    memcpy(lpItemInfo, this->m_DBQuery.GetAsBinary("ItemInfo"), MAX_ITEM_INFO);
    return TRUE;
}</code></pre>
          </div>
        </div>
        <h4>Adaptação para microsserviços</h4>
        <ol>
          <li>Criar um <em>Gateway</em> HTTP (Node/Express ou .NET Minimal API) com rotas equivalentes aos <code>case</code> acima: <code>POST /skills/use</code>, <code>POST /inventory/drop</code>, <code>POST /inventory/pick</code>.</li>
          <li>Encapsular consultas SQL em repositórios. Use <code>Dapper</code> ou <code>TypeORM</code> para carregar blobs de item igual ao <code>LoadItemInfo</code>, convertendo para <code>FItemDefinition</code>.</li>
          <li>Adicionar fila de eventos (RabbitMQ/Kafka) para notificações assíncronas (ex.: <em>MobDied</em>, <em>SkillCast</em>) que disparam atualizações em tempo real para os clientes.</li>
          <li>Implementar autenticação com tokens (JWT) emitidos pelo serviço de contas. Os requests do jogo enviam <code>Bearer Token</code> no cabeçalho.</li>
        </ol>
        <h4>Blueprint → HTTP</h4>
        <pre><code>Function BP_RequestDrop(ItemGuid, WorldSlot)
  → Make Json Object { "itemGuid": ItemGuid, "map": MapId, "position": WorldSlot }
  → HttpSubsystem::POST("/inventory/drop", Json)
  → OnSuccess → InventoryComponent.ApplyServerDelta(Response.Payload)
  → OnFailure → MostrarErro("Falha ao dropar item")</code></pre>
        <div class="callout warning">
          <strong>Segurança:</strong> valide tudo no backend. As Blueprints apenas pedem autorização; as regras de PK, safe zone e logs continuam rodando no servidor reescrito.</div>
        <details class="guia">
          <summary>Customizações, Bots e Serviços Extras</summary>
          <div class="grid-2">
            <div>
              <h5>Referências no MuServer</h5>
              <ul>
                <li><code>GameServer/GameServer/BotHelper.cpp</code>, <code>BotStore.cpp</code>, <code>BotWarper.cpp</code> &mdash; automatizam buff, loja e teleporte.</li>
                <li><code>GameServer/GameServer/CustomNpcQuest.cpp</code>, <code>CustomNpcCollector.cpp</code> &mdash; scripts de NPC personalizados ligados ao <code>EventInventory</code>.</li>
                <li><code>GameServer/GameServer/CustomEventDrop.cpp</code>, <code>CustomEventTime.cpp</code> &mdash; definem drops programados e calendário rotativo.</li>
                <li><code>GameServer/GameServer/CustomMix.cpp</code>, <code>CustomWing.cpp</code>, <code>JewelMix.cpp</code> &mdash; tabelas extras de combinação de itens.</li>
                <li><code>GameServer/GameServer/CustomRanking.cpp</code>, <code>CustomTop.cpp</code> &mdash; agregam dados de ranking em memória.</li>
              </ul>
            </div>
            <div>
              <h5>Tradução para serviços modernos</h5>
              <ul>
                <li>Implemente microserviço <strong>BotService</strong> expondo <code>POST /bot/{id}/schedule</code> e WebSocket <code>/ws/bot</code> para transmitir comandos automáticos às Blueprints (<code>BP_BotProxy</code>).</li>
                <li>Converta scripts de NPC para <code>Data Assets</code> (<code>DA_CustomNPC</code>) que carregam diálogos originais (<code>NewUINPCDialogue.cpp</code>) e disparam chamadas REST <code>/npc/{id}/interact</code>.</li>
                <li>Crie serviço <strong>EventOrchestrator</strong> que lê cronogramas equivalentes a <code>CustomEventTime.txt</code>, dispara mensagens <code>Event.Start</code>/<code>Event.End</code> e sincroniza com o <code>BP_EventDirector</code>.</li>
                <li>Exponha APIs de <strong>Mixing</strong> (<code>POST /mix</code>) com lógica replicada de <code>CustomMix.cpp</code> / <code>JewelMix.cpp</code>; o widget UE5 de craft reutiliza layout de <code>NewUIMixInventory.cpp</code>.</li>
                <li>Persista rankings customizados em banco (Redis + SQL) e publique <code>/ranking/custom/{tipo}</code>; HUD UE5 consome via <code>WBP_RankingBoard</code>.</li>
              </ul>
            </div>
          </div>
          <div class="callout">
            <strong>Checklist:</strong> valide que cada módulo <code>Custom*</code> ou <code>Bot*</code> possui endpoint/documentação correspondente e que os assets/diálogos originais foram importados para os Widgets UMG associados.</div>
        </details>
        <h4>Streaming de dados em tempo real</h4>
        <ul>
          <li><strong>Posições e mobs:</strong> exponha <code>/ws/world</code> para replicar <code>GSGObjViewportListSend</code>. UE5 consome via <code>WebSocket</code> usando <code>UGameInstanceSubsystem</code>.</li>
          <li><strong>Ranking e eventos:</strong> atualize endpoints <code>/events/active</code> e <code>/ranking/{categoria}</code>. Use <code>Async Task Blueprint Proxy</code> para popular painéis sem travar o game thread.</li>
          <li><strong>Persistência de skills:</strong> sempre sincronize cooldowns e buffs no backend para evitar divergências entre clientes.</li>
        </ul>
      </article>

      <article class="conversion-pane" data-pane="qa">
        <h3>QA, Depuração &amp; Telemetria</h3>
        <p>
          Garanta que cada sistema recriado (HUD, itens, mobs, skills, mapas) seja validado com testes automatizados e sessões de QA.
          Use ferramentas de profiling para comparar comportamento com o cliente legado e detectar regressões cedo.
        </p>
        <div class="grid-2">
          <div>
            <h4>Checklist de QA por sprint</h4>
            <ul>
              <li>🔁 <strong>Comparação visual:</strong> capturar screenshots na UE5 e no cliente original usando as mesmas coordenadas e assets.</li>
              <li>🎯 <strong>Logs críticos:</strong> monitorar <code>LogInventory</code>, <code>LogSkill</code>, <code>LogMob</code> no backend para cada ação do jogador.</li>
              <li>🧪 <strong>Testes automatizados:</strong> escrever <code>Functional Tests</code> em UE5 para spawns, drops e tooltips. No backend, criar testes de integração cobrindo <code>/inventory</code>, <code>/skills</code>, <code>/mobs</code>.</li>
              <li>📈 <strong>Telemetria:</strong> enviar métricas para Prometheus/Grafana (tempo de spawn, taxa de erro HTTP, RTT médio do WebSocket).</li>
            </ul>
          </div>
          <div>
            <h4>Ferramentas recomendadas</h4>
            <ul>
              <li><strong>Replay UE5:</strong> habilite <em>Network Replay</em> para reproduzir combates e garantir que skills/drops funcionem em partidas reais.</li>
              <li><strong>Automation System:</strong> configure <code>AutomationTool</code> com grupos <em>Frontend</em> (widgets, blueprint) e <em>Backend</em> (APIs via scripts Python).</li>
              <li><strong>Perf Insights:</strong> use <em>Unreal Insights</em> comparando FPS com efeitos ligados/desligados para descobrir gargalos.</li>
              <li><strong>DataDog / Elastic:</strong> concentre logs de backend e cliente em dashboards com filtros por <em>AccountID</em>, <em>MapID</em> e <em>SkillID</em>.</li>
            </ul>
          </div>
        </div>
        <h4>Exemplo de script de validação cruzada</h4>
        <pre><code># validate_drops.py
from httpx import Client

with Client(base_url="https://api.seu-jogo.com") as http:
    resp = http.post("/inventory/drop", json={
        "itemGuid": "c7a2...",
        "map": 33,
        "position": {"x": 120, "y": 85}
    })
    resp.raise_for_status()
    assert resp.json()["result"] == "ok"

    loot = http.get("/world/mob/last-drop").json()
    assert loot["itemGuid"] == "c7a2..."
    assert loot["map"] == 33
</code></pre>
        <div class="callout">
          <strong>Rotina de regressão:</strong> execute o script acima após cada build noturno e anexe o resultado ao relatório de QA. Combine com <code>Gauntlet</code> no UE5 para validar menus, HUD e combate.</div>
      </article>
    </section>

    <section id="cobertura-total">
      <h2>Cobertura Completa Frontend + Backend</h2>
      <p>
        Após revisar os fontes <code>Source Main 5.2/source</code> e a árvore de serviços em
        <code>MuServer_Season_5_Update_15</code>, utilize esta seção para conferir que cada módulo do
        guia possui um plano de recriação na UE5 e um serviço moderno correspondente. A lista consolida
        fluxos críticos do cliente (login, HUD, inventário, skills, sociais) e do backend (autenticação,
        world, economia, eventos) para evitar lacunas durante a migração.
      </p>

      <div class="coverage-grid">
        <article class="coverage-card">
          <h3>Cliente UE5 (Frontend)</h3>
          <p>
            Certifique-se de que cada widget UMG e Blueprint cobre os fluxos definidos no cliente legado.
          </p>
          <ul>
            <li>
              Replique <code>LoginWin.cpp</code>, <code>CharSelMainWin.cpp</code> e
              <code>NewUIMainFrameWindow.cpp</code> dentro das instruções de <a href="#guias-frontend">Interfaces &amp; HUD</a>,
              reaproveitando sprites de <code>Source Main 5.2/bin/Data</code> e respeitando offsets originais.
            </li>
            <li>
              Garanta que <code>WBP_Inventory</code> e <code>BP_ItemDrag</code> cubram a lógica de
              <code>NewUIInventoryCtrl.cpp</code>, <code>NewUIItemMng.cpp</code> e
              <code>NewUIItemExplanationWindow.cpp</code>, conforme o roteiro da
              <a href="#item-system-encyclopedia">Enciclopédia do Sistema de Itens</a>.
            </li>
            <li>
              Confirme que os Blueprints de mobs e skills consomem tabelas derivadas de
              <code>Data/Monster/MonsterSetBase.txt</code>, <code>Data/Skill/Skill.txt</code> e scripts de eventos citados em
              <a href="#mob-system-atlas">Sistemas de mobs</a> e <a href="#skill-system-guide">Sistemas de skills</a>.
            </li>
            <li>
              Valide widgets sociais (<code>NewUIFriendWindow.cpp</code>, <code>NewUIGuildInfoWindow.cpp</code>) e economia
              (<code>NewUINPCShop.cpp</code>, <code>NewUITrade.cpp</code>) com os cards de
              <a href="#social-guildas">Social</a> e <a href="#economia-lojas">Economia</a>.
            </li>
          </ul>
        </article>

        <article class="coverage-card">
          <h3>Serviços Modernos (Backend)</h3>
          <p>
            Mapeie cada responsabilidade do MuServer para um microserviço ou módulo atualizado.
          </p>
          <ul>
            <li>
              Recrie autenticação, seleção de servidor e handshake observando <code>ConnectServer</code>,
              <code>JoinServer</code> e <code>GameServer</code> em
              <code>MuServer_Season_5_Update_15</code>, seguindo o plano de <a href="#frontend-backend">Gateway UE5 ⇄ Serviços</a>.
            </li>
            <li>
              Converta rotinas de inventário (<code>GameServer/GameServer/ItemBagManager.cpp</code>,
              <code>GameServer/GameServer/Protocol.cpp</code>) e persistência (<code>DataServer</code>) em APIs descritas nas seções
              <a href="#backend">Serviços modernos</a> e <a href="#item-system-encyclopedia">Sistema de itens</a>.
            </li>
            <li>
              Cubra eventos e instâncias (<code>GameServer/GameServer/CastleSiege.cpp</code>,
              <code>GameServer/GameServer/ImperialGuardian.cpp</code>) com os roteiros de
              <a href="#eventos-liveops">Eventos &amp; live ops</a> e <a href="#missoes_eventos">Missões &amp; rankings</a>.
            </li>
            <li>
              Centralize economia, cash shop e trocas (<code>GameServer/GameServer/CShopManager.cpp</code>,
              <code>GameServer/GameServer/Trade.cpp</code>) no serviço de economia detalhado em
              <a href="#economia-lojas">Economia e lojas</a>.
            </li>
          </ul>
        </article>

        <article class="coverage-card">
          <h3>Sincronização Front ⇄ Back</h3>
          <p>
            Utilize estes checkpoints para garantir consistência entre Blueprints e serviços.
          </p>
          <ul>
            <li>
              Alinhe payloads JSON com as estruturas lidas em <code>GameServer/GameServer/Protocol.h</code> e
              <code>DataServer/DBItemInfo.cpp</code>, evitando perda de atributos (durabilidade, socket, option).
            </li>
            <li>
              Replique cronogramas de spawn e respawn usando <code>Data/Monster/MonsterSpawn.txt</code> e os timers do
              <code>GameServer/GameServer/MonsterAIManager.cpp</code>, refletidos em <a href="#mob-system-atlas">Sistemas de mobs</a>.
            </li>
            <li>
              Garanta que o sistema de skills use o mesmo mapeamento de <code>SkillInfo.cpp</code> e
              <code>SkillManager.cpp</code>, com cooldowns validados no backend antes de aplicar efeitos na UE5.
            </li>
            <li>
              Mantenha logs e telemetria dos serviços <code>Log/</code> originais (como <code>GameServer/log/ItemLog</code>) através
              dos procedimentos de <a href="#qa-operacoes">QA &amp; operações</a>.
            </li>
          </ul>
        </article>
      </div>

      <h3>Passo a passo de validação final</h3>
      <ol>
        <li>
          Execute o roteiro de <a href="#guias-frontend">Interfaces &amp; HUD</a> comparando cada widget com as classes
          <code>LoginWin.cpp</code>, <code>CharSelMainWin.cpp</code>, <code>NewUIBuffWindow.cpp</code> e
          <code>NewUIMyInventory.cpp</code>. Confirme resolução, âncoras e atalhos.
        </li>
        <li>
          Siga a <a href="#item-system-encyclopedia">Enciclopédia do Sistema de Itens</a> para testar drop, colisão, tooltip e
          armazenamento, confrontando com <code>NewUIInventoryCtrl.cpp</code>, <code>GItemManager.cpp</code> e scripts
          <code>Data/Item/*.txt</code>.
        </li>
        <li>
          Valide mobs, XP e skills com os checklists de <a href="#mob-system-atlas">mobs</a> e
          <a href="#skill-system-guide">skills</a>, garantindo que os dados de <code>MonsterSetBase.txt</code>,
          <code>SkillTree.txt</code> e handlers como <code>GameServer/GameServer/SkillAttack.cpp</code> estejam sincronizados.
        </li>
        <li>
          Revise sistemas sociais, economia e eventos (<a href="#social-guildas">Social</a>,
          <a href="#economia-lojas">Economia</a>, <a href="#eventos-liveops">Eventos</a>) com as classes legadas
          <code>NewUIFriendWindow.cpp</code>, <code>CShopManager.cpp</code>, <code>CCastleSiege.cpp</code> e tabelas
          <code>Data/Event/*.txt</code>.
        </li>
        <li>
          Finalize com infraestrutura e segurança acompanhando <a href="#comandos-seguranca">Comandos &amp; segurança</a> e
          <a href="#frontend-backend">Gateway</a>, substituindo <code>ConnectServer</code>, <code>Filter.cpp</code> e
          <code>HackPacketCheck.cpp</code> por middlewares e monitoramento documentados.
        </li>
      </ol>

      <table class="matrix">
        <thead>
          <tr>
            <th>Domínio</th>
            <th>Fontes principais (Main / MuServer)</th>
            <th>Seção UE5 correspondente</th>
            <th>Critério de aceitação</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Fluxos iniciais</td>
            <td><code>LoginWin.cpp</code>, <code>CharSelMainWin.cpp</code>, <code>ConnectServer/ServerList.cpp</code></td>
            <td><a href="#guias-frontend">Interfaces &amp; HUD</a>, <a href="#frontend-backend">Gateway UE5 ⇄ Serviços</a></td>
            <td>Tela de login e seleção autenticam via API e reproduzem layout original.</td>
          </tr>
          <tr>
            <td>HUD &amp; inventário</td>
            <td><code>NewUIMainFrameWindow.cpp</code>, <code>NewUIInventoryCtrl.cpp</code>, <code>GameServer/Protocol.cpp</code></td>
            <td><a href="#guias-frontend">Interfaces &amp; HUD</a>, <a href="#item-system-encyclopedia">Sistema de itens</a></td>
            <td>Slots, tooltips e sincronização de inventário refletem ações do backend em tempo real.</td>
          </tr>
          <tr>
            <td>Mobs &amp; progressão</td>
            <td><code>MonsterAIManager.cpp</code>, <code>MonsterSetBase.txt</code>, <code>GameServer/Experience.cpp</code></td>
            <td><a href="#mob-system-atlas">Sistemas de mobs</a>, <a href="#skill-system-guide">Sistemas de skills</a></td>
            <td>Spawns, AI e XP batem com as curvas e timers originais.</td>
          </tr>
          <tr>
            <td>Economia</td>
            <td><code>NewUINPCShop.cpp</code>, <code>CShopManager.cpp</code>, <code>Data/CashShop/</code></td>
            <td><a href="#economia-lojas">Economia e lojas</a>, <a href="#backend">Serviços modernos</a></td>
            <td>Compras, vendas e cash shop fecham ciclo com logs e rollback confiáveis.</td>
          </tr>
          <tr>
            <td>Social &amp; eventos</td>
            <td><code>NewUIFriendWindow.cpp</code>, <code>GensSystem.cpp</code>, <code>CastleSiege.cpp</code></td>
            <td><a href="#social-guildas">Social, guildas &amp; gens</a>, <a href="#eventos-liveops">Eventos &amp; live ops</a></td>
            <td>Party, guilda e eventos disparados pelo backend aparecem em tempo real na UE5.</td>
          </tr>
          <tr>
            <td>Operação &amp; segurança</td>
            <td><code>CommandManager.cpp</code>, <code>Filter.cpp</code>, <code>HackPacketCheck.cpp</code></td>
            <td><a href="#comandos-seguranca">Comandos e segurança</a>, <a href="#qa-operacoes">QA &amp; operações</a></td>
            <td>Comandos administrativos, logs e alertas de segurança cobrem os cenários originais.</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section id="garantia-funcionamento">
      <h2>Garantia de Funcionamento UE5 (Frontend + Backend)</h2>
      <p>
        As instruções abaixo consolidam o estudo do cliente <code>Source Main 5.2</code> e do servidor
        <code>MuServer_Season_5_Update_15</code> em um roteiro de verificação prática. Utilize este
        painel para confirmar, a cada entrega, que as Blueprints UE5 reproduzem o comportamento dos
        executáveis originais e que os novos microserviços respeitam o protocolo legado.
      </p>

      <div class="assurance-grid">
        <div class="assurance-card">
          <span class="status-flag">Frontend UE5</span>
          <h3>Checklist de Blueprint</h3>
          <ul>
            <li>Reimportou HUD, inventário e minimapa usando offsets definidos em <code>NewUI*</code> dentro de <code>Source Main 5.2/source</code>.</li>
            <li>Construiu <code>WBP_Login</code>, <code>WBP_CharacterSelect</code>, <code>WBP_HUD_Root</code> e <code>WBP_Inventory</code> respeitando sprites originais em <code>Source Main 5.2/bin/Data</code>.</li>
            <li>Verificou animações de feedback (HP/MP, XP, drop) replicando <code>RenderBitmap</code> e <code>g_pRenderText</code> com materiais UE5.</li>
            <li>Validou drag &amp; drop e tooltips convertendo lógica de <code>CNewUIInventoryCtrl</code> e <code>CNewUIItemExplanationWindow</code>.</li>
            <li>Confirmou que Blueprints de mobs e skills usam dados de <code>Data/Monster/MonsterSetBase.txt</code> e <code>Data/Skill/Skill.txt</code> via <code>Data Tables</code>.</li>
          </ul>
        </div>
        <div class="assurance-card">
          <span class="status-flag">Backend Moderno</span>
          <h3>Checklist de Serviços</h3>
          <ul>
            <li>Implementou gateways que traduzem <code>Protocol.cpp</code> para REST/WebSocket (<code>/auth/login</code>, <code>/character/list</code>, <code>/inventory/move</code>).</li>
            <li>Replicou validações de <code>ItemManager.cpp</code>, <code>Trade.cpp</code> e <code>ShopManager.cpp</code> antes de persistir.</li>
            <li>Reutilizou tabelas SQL em <code>MuServer_Season_5_Update_15/ScriptSql</code> garantindo campos compatíveis com <code>GameServer</code>.</li>
            <li>Automatizou carga de arquivos <code>Data/</code> (itens, monstros, eventos) com scripts do diretório <code>tools/</code> (ex.: <code>tools/item_converter</code>).</li>
            <li>Configurou auditoria e logs inspirados em <code>LogAddTD</code> para cada endpoint crítico.</li>
          </ul>
        </div>
        <div class="assurance-card">
          <span class="status-flag">Integração</span>
          <h3>Checklist de Sincronização</h3>
          <ul>
            <li>Back-end envia mensagens WebSocket equivalentes a <code>GCInventoryItemOneSend</code>, <code>GCLevelUpSend</code> e <code>GCDropItemSend</code>.</li>
            <li>UE5 consome respostas reproduzindo estados de interface (<code>NewUIMessageBox</code>, <code>NewUIChatWindow</code>) sem divergência visual.</li>
            <li>Testes de carga de mobs garantem respawn conforme <code>MonsterAIElement.cpp</code> e timers <code>gQueueTimer</code>.</li>
            <li>XP e recompensas validam contra <code>ExperienceTable.txt</code> e <code>BonusManager.cpp</code>.</li>
            <li>Economia e cash shop respeitam limites de <code>CCashShop::LoadCashItemList</code> e <code>CNewUINPCShop::Load</code>.</li>
          </ul>
        </div>
      </div>

      <h3>Validação Cruzada por Sistema</h3>
      <table class="matrix">
        <thead>
          <tr>
            <th>Sistema</th>
            <th>Fonte Legada</th>
            <th>Verificação UE5</th>
            <th>Respaldo Backend</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Login &amp; Seleção</td>
            <td><code>CLoginWin.cpp</code>, <code>NewUICharSel.cpp</code>, <code>JoinServer/JoinServer.cpp</code></td>
            <td>Executar <em>PIE</em> com <code>WBP_Login</code> ➝ <code>WBP_CharacterSelect</code> e validar animações de foco e bloqueios por classe.</td>
            <td>Microserviço <code>/auth/login</code> replica <code>MD5Encryption</code> e lista personagens a partir de <code>Character</code> (SQL).</td>
          </tr>
          <tr>
            <td>Inventário &amp; Drops</td>
            <td><code>CNewUIInventoryCtrl.cpp</code>, <code>ItemManager.cpp</code>, <code>CItemDrop.cpp</code></td>
            <td>Blueprint <code>WBP_Inventory</code> confirma slots 8×8 em (15,200) e tooltips conforme categoria.</td>
            <td>Serviço <code>/inventory/move</code> aplica verificações <code>INVENTORY_FULL_RANGE</code> e notifica via WebSocket.</td>
          </tr>
          <tr>
            <td>Mobs, Respawn &amp; XP</td>
            <td><code>MonsterSetBase.txt</code>, <code>MonsterAIElement.cpp</code>, <code>ExperienceTable.txt</code></td>
            <td><code>BP_MobSpawner</code> lê <code>Data Table</code> convertida e atualiza HUD (barra de XP, drop preview).</td>
            <td>Serviço <code>/mob/spawn</code> controla timers e envia <code>GCMonsterDieSend</code> com XP calculado.</td>
          </tr>
          <tr>
            <td>Skills &amp; Combos</td>
            <td><code>SkillManager.cpp</code>, <code>ComboSkill.cpp</code>, <code>SkillEffectMgr.cpp</code></td>
            <td>Blueprints de habilidade usam <code>Gameplay Ability System</code> com custos, delays e efeitos Niagara idênticos.</td>
            <td>Endpoint <code>/skill/cast</code> valida pré-requisitos e envia <code>GCMagicAttackSend</code>/<code>GCComboSkillSend</code>.</td>
          </tr>
          <tr>
            <td>Economia &amp; Lojas</td>
            <td><code>CNewUINPCShop.cpp</code>, <code>ShopManager.cpp</code>, <code>CCashShop.cpp</code></td>
            <td>Widgets UE5 replicam abas, filtros e animações de compra (sons/FX reutilizados de <code>Data/Sound</code>).</td>
            <td>Microserviço <code>/shop/purchase</code> aplica limites de estoque, logs e saldo de Zen/Cash como no legado.</td>
          </tr>
        </tbody>
      </table>

      <details class="guia" open>
        <summary>Ordem de Smoke Test (Front + Back)</summary>
        <ol>
          <li><strong>Inicialização:</strong> Execute o servidor gateway e serviços (Auth, Character, Inventory, Drop) verificando conexões com o banco legado convertido.</li>
          <li><strong>Cliente PIE:</strong> Abra o mapa <code>L_Login.umap</code>, autentique-se e avance até o mapa de lobby validando mensagens recebidas.</li>
          <li><strong>Inventário:</strong> Spawne um item via comando <code>/item</code> no backend e confirme atualização em tela e persistência.</li>
          <li><strong>Combate:</strong> Derrote mobs configurados no <code>MonsterSetBase</code> convertido e confirme XP, drops e atualizações de ranking.</li>
          <li><strong>Economia:</strong> Realize compra/venda em NPC e cash shop garantindo sincronização de saldo e logs.</li>
        </ol>
      </details>

      <details class="guia">
        <summary>Checklist de Falhas Comuns e Correções</summary>
        <ul>
          <li><strong>HUD desalinhada:</strong> Revise âncoras e escalas aplicando valores de <code>RenderImage</code> do legado.</li>
          <li><strong>Itens sumindo:</strong> Certifique-se de que o backend aplica <code>IsDropBan</code> e bloqueios de transação antes de remover do inventário.</li>
          <li><strong>XP divergente:</strong> Compare curva carregada na UE5 com <code>g_MonsterExperienceRate</code> e <code>ExperienceTable.txt</code>.</li>
          <li><strong>Skills sem efeito:</strong> Verifique se a <code>Ability</code> UE5 dispara <code>GameplayCue</code> equivalente a <code>SkillEffectMgr</code>.</li>
          <li><strong>Compras duplicadas:</strong> Habilite locks transacionais seguindo <code>ShopManager::CGShopItemSellRecv</code>.</li>
        </ul>
      </details>

      <div class="checklist">
        <label>
          <input type="checkbox" />
          <span><strong>Logs comparados:</strong> Exportou <code>LogAddTD</code> original e comparou com registros estruturados do backend novo.</span>
        </label>
        <label>
          <input type="checkbox" />
          <span><strong>Paridade visual:</strong> Capturou screenshots UE5 e cliente legado confirmando correspondência de coordenadas UI.</span>
        </label>
        <label>
          <input type="checkbox" />
          <span><strong>Eventos críticos:</strong> Validou login, criação de personagem, queda de servidor e rollback com scripts automatizados.</span>
        </label>
      </div>

      <h3>Procedimento de Certificação Final</h3>
      <ol>
        <li>Executar bateria de testes GAuntlet/Functional Tests e Postman collections refletindo o protocolo <code>Protocol.cpp</code>.</li>
        <li>Comparar métricas de performance (tick, CPU, memória) com dados coletados do GameServer original.</li>
        <li>Revisar manualmente os principais fluxos (login ➝ seleção ➝ mapa ➝ combate ➝ loja) com equipe multidisciplinar.</li>
        <li>Congelar dados de configuração (<code>Data/*.txt</code>, SQL) e gerar relatórios assinados de paridade antes do lançamento.</li>
      </ol>

      <div class="callout">
        <strong>Dica:</strong> mantenha um build de referência do cliente original para comparar comportamentos lado a lado em cada entrega da UE5. Utilize captures de pacotes (Wireshark) para validar que tokens, códigos de erro e sequências seguem os mesmos padrões observados no MuServer.
      </div>
    </section>

    <section id="verificacoes">
      <h2>Painel de Decisão Rápida</h2>
      <div class="timeline">
        <div class="timeline-step">
          <span class="label">Início</span>
          <strong>Importo todos os assets agora?</strong>
          <p>Somente após classificar como <em>Pronto</em>, <em>Precisa Ajustes</em> ou <em>Substituir</em>. Caso contrário, importe um lote pequeno para validar materiais e colisões.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Depois do HUD</span>
          <strong>Recrio a interface antes dos sistemas?</strong>
          <p>Sim. Com HUD + Inventário prontos, você valida feedback instantâneo e detecta falta de dados herdados.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Progresso</span>
          <strong>XP ou Itens primeiro?</strong>
          <p>Inicie pelos itens. XP depende de recompensas, então garanta que o inventário suporte equipar/consumir para depois ajustar a progressão.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Conteúdo</span>
          <strong>Mapas ou Drops antes?</strong>
          <p>Mapas. Estruture navegação e colisões; em seguida distribua inimigos e configure drops conforme layout final.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Final</span>
          <strong>Efeitos visuais no fim?</strong>
          <p>Sim. Após sistemas estáveis, aplique Niagara, som e pós-processo com base no gameplay consolidado.</p>
        </div>
      </div>
      <div class="callout" style="margin-top: 1.75rem;">
        <strong>Dica:</strong> Revise o painel após cada etapa. Se houver bloqueio por falta de asset convertido, mova temporariamente para um placeholder marcado com <em>debug material</em> e siga com a lógica.
      </div>
    </section>


    <section id="frontend-backend">
      <h2>Mapa Profundo do Código Original &rarr; Conversão UE5</h2>
      <p>
        Utilize a matriz abaixo para navegar pelo código fonte do cliente (<code>Source Main 5.2</code>) e dos serviços do
        servidor (<code>MuServer_Season_5_Update_15</code>), relacionando cada responsabilidade com a solução equivalente em
        Unreal Engine 5.
      </p>
      <table class="matrix">
        <thead>
          <tr>
            <th>Responsabilidade</th>
            <th>Origem Legada</th>
            <th>Pontos de Atenção</th>
            <th>Conversão Unreal Engine 5</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>HUD Principal</strong></td>
            <td>
              <code>Source Main 5.2/source/NewUIMainFrameWindow.cpp</code><br />
              <code>Source Main 5.2/source/UIControls.cpp</code>
            </td>
            <td>
              Coordenadas absolutas baseadas em <code>g_fScreenRate_x/y</code>, dependências diretas de assets BMP/TGA no
              diretório <code>GlobalBitmap</code>.
            </td>
            <td>
              Criar widgets UMG separados: <code>WBP_StatusBar</code>, <code>WBP_Minimap</code>, <code>WBP_BuffTray</code>.
              Usar <code>Widget Switcher</code> + bindings de escala para preservar proporções. Importar texturas em
              <code>/Game/UI/Legacy</code> e converter para <code>Slate Brush</code>.
            </td>
          </tr>
          <tr>
            <td><strong>Inventário &amp; Misturas</strong></td>
            <td>
              <code>NewUIMyInventory.cpp</code>, <code>NewUIMixInventory.cpp</code>, <code>MixMgr.cpp</code>
            </td>
            <td>
              Slots codificados manualmente, regras de arrastar/soltar via <code>MouseLButton</code>.
            </td>
            <td>
              <code>BP_InventoryGrid</code> + <code>Drag &amp; Drop Operation</code>. Implementar <code>Data Assets</code> para
              fórmulas de mistura e <code>Actor Component</code> para lógica de craft sincronizada com o backend.
            </td>
          </tr>
          <tr>
            <td><strong>Eventos &amp; Bosses</strong></td>
            <td>
              <code>NewUIBloodCastleEnter.cpp</code>, <code>GMDoppelGanger*.cpp</code>, <code>Event.cpp</code>
            </td>
            <td>
              Agendamento hardcoded, dependência de scripts <code>Data/Event/*.dat</code>.
            </td>
            <td>
              Converter para <code>Gameplay Ability System</code> + <code>Gameplay Tags</code>. Usar
              <code>Primary Data Assets</code> para eventos e <code>Timer Manager</code> para agendamentos dinâmicos com dados
              carregados via HTTP.
            </td>
          </tr>
          <tr>
            <td><strong>Networking &amp; Sessões</strong></td>
            <td>
              <code>WSclient.cpp</code>, <code>ProtocolSend.cpp</code>, <code>ServerGroup.cpp</code>
            </td>
            <td>
              Protocolo proprietário baseado em TCP; autenticação manual com <code>SimpleModulus</code>.
            </td>
            <td>
              Migrar para <code>EOS</code> ou <code>OSS</code>. Implementar autenticação JWT/HTTPS e replicação com
              <code>Gameplay Message Subsystem</code>. Reaproveitar chaves existentes para gerar tokens iniciais.
            </td>
          </tr>
          <tr>
            <td><strong>Banco de Dados</strong></td>
            <td>
              Scripts em <code>MuServer_Season_5_Update_15/ScriptSql</code>, rotinas C++ em <code>GameServer/DataServer</code>
            </td>
            <td>
              Stored procedures com lógica de negócios (reset diário, ranking, guilds).
            </td>
            <td>
              Criar microserviços .NET/Node nestas rotinas; expor endpoints REST/GraphQL para UE5. Usar
              <code>Data Access Layer</code> com migrations automatizadas.
            </td>
          </tr>
        </tbody>
      </table>
      <div class="callout">
        <strong>Dica:</strong> mantenha uma planilha de rastreabilidade onde cada arquivo legado tem um destino UE5 documentado
        (Blueprint, C++ ou serviço). Isso acelera revisões e facilita auditorias futuras.
      </div>
    </section>

    <section id="guias-frontend">
      <h2>Guias Específicos de Interface (Frontend)</h2>
      <div class="legend">
        <span>🔁 Reaproveitar Asset</span>
        <span>🎯 Ajustar Coordenadas</span>
        <span>🧩 Lógica Blueprint</span>
        <span>🌐 Integração Backend</span>
      </div>
      <details class="guia" open>
        <summary>HUD Principal &mdash; Coordenadas e Layout</summary>
        <div class="grid-2">
          <div>
            <h4>1. Preparar Assets</h4>
            <ul>
              <li>Exportar elementos <code>GlobalBitmap\Interface\*.bmp</code> para <code>.png</code> (transparência).</li>
              <li>Organizar texturas no UE5 em <code>/Game/UI/HUD/Textures</code> seguindo nomes originais para facilitar busca.</li>
              <li>Criar <code>Material Instance</code> por grupo (barra, moldura, minimapa).</li>
            </ul>
          </div>
          <div>
            <h4>2. Reconstruir Layout</h4>
            <p><strong>Passo a passo:</strong></p>
            <ol>
              <li>Criar <code>WBP_HUD_Master</code> baseado em <code>Canvas Panel</code>.</li>
              <li>Adicionar <code>Overlay</code> com âncoras fixas conforme percentual legado (ex.: barra de HP em 3% x 94%).</li>
              <li>Usar <code>SizeBox</code> para garantir dimensões originais (consultar <code>NewUIMainFrameWindow.cpp</code>).</li>
              <li>Configurar animações em <code>Timeline</code> para efeitos de ganho de XP (<code>m_bExpEffect</code>).</li>
            </ol>
          </div>
        </div>
        <div class="code-card">
<pre>// Trecho original (NewUIMainFrameWindow.cpp)
if (m_bExpEffect && gCurTime - m_dwExpEffectTime < 1500)
{
    float fScale = (float)(gCurTime - m_dwExpEffectTime) / 1500.0f;
    RenderBitmap(IMAGE_EXP_EFFECT, 230.0f, 430.0f, 256.0f*fScale, 64.0f, 0.0f, 0.0f);
}
</pre>
        </div>
        <p><strong>Conversão Blueprint:</strong></p>
        <div class="blueprint-flow">
          <div class="blueprint-step">
            <h4>Evento XP Gained</h4>
            <p>
              No <code>BP_PlayerState</code>, disparar <code>Event XP Gained</code> passando quantidade de XP. Atualizar variável
              <code>ExpEffectStart</code>.
            </p>
          </div>
          <div class="blueprint-step">
            <h4>Widget Animation</h4>
            <p>
              No <code>WBP_HUD_Master</code>, criar animação <em>ExpPulse</em>. Bindar <code>Tick</code> para calcular escala via
              <code>GetWorldDeltaSeconds</code> replicando o fator <code>fScale</code>.
            </p>
          </div>
          <div class="blueprint-step">
            <h4>Material Parameter</h4>
            <p>
              Utilizar <code>Dynamic Material Instance</code> com parâmetro <code>Scale</code> aplicado ao brush. Controlar via
              <code>Set Scalar Parameter Value</code> durante a animação.
            </p>
          </div>
        </div>
      </details>

      <details class="guia">
        <summary>Inventário &amp; Loja Integrada</summary>
        <p>
          Combine os sistemas de inventário (<code>NewUIMyInventory</code>) e loja (<code>NewUIShop</code>) em um fluxo modular
          reutilizando ícones e slots originais.
        </p>
        <ol>
          <li>Gerar <code>Data Table</code> a partir de <code>Data/Item/Item.txt</code> usando script Python (incluir colunas de
            tamanho <em>width/height</em> e categoria).</li>
          <li>Criar <code>WBP_ItemSlot</code> com <code>Border</code> para destacar raridade. Importar <code>Item*.tga</code> como
            <code>Texture2D</code>.</li>
          <li>Implementar arrastar/soltar com <code>OnDragDetected</code> e <code>OnDrop</code>. Use <code>ItemGUID</code> para
            sincronizar com o backend.</li>
          <li>Para a loja, consumir endpoint <code>GET /shop/offers</code> (novo backend) e popular <code>WBP_ShopGrid</code>.
            Enviar compras com <code>POST /shop/purchase</code>, esperando confirmação antes de remover moeda local.</li>
        </ol>
      </details>

      <details class="guia">
        <summary>Tooltips de Itens &amp; Renderização 2D</summary>
        <div class="grid-2">
          <div>
            <h4>Referências Legadas</h4>
            <ul>
              <li><code>NewUIMyInventory::RenderItemToolTip</code> posiciona o tooltip no centro do slot apontado.</li>
              <li><code>NewUIInventoryCtrl::RenderItemToolTip</code> alterna entre <code>RenderItemInfo</code> e <code>RenderRepairInfo</code>.</li>
              <li><code>GlobalText.h</code> fornece as strings localizadas usadas em <code>RenderTipText</code>.</li>
            </ul>
          </div>
          <div class="source-card">
            <div class="source-meta">Cliente &mdash; <code>NewUIInventoryCtrl.cpp</code></div>
            <pre><code>void CNewUIInventoryCtrl::RenderItemToolTip()
{
    if(m_pToolTipItem != NULL)
    {
        ITEM_ATTRIBUTE* pItemAttr = &ItemAttribute[m_pToolTipItem->Type];
        int iTargetX = m_Pos.x + m_pToolTipItem->x*INVENTORY_SQUARE_WIDTH
            + pItemAttr->Width*INVENTORY_SQUARE_WIDTH/2;
        int iTargetY = m_Pos.y + m_pToolTipItem->y*INVENTORY_SQUARE_HEIGHT
            + pItemAttr->Height*INVENTORY_SQUARE_HEIGHT/2;
        RenderItemInfo(iTargetX, iTargetY, m_pToolTipItem, false);
    }
}</code></pre>
          </div>
        </div>
        <h4>Adaptação UE5</h4>
        <ol>
          <li>Criar <code>WBP_ItemTooltip</code> com <code>Canvas Panel</code> raiz e <code>SizeBox</code> ajustável. Utilize <code>TextBlock</code> configurados com fontes convertidas de <code>Tahoma</code> 12 px.</li>
          <li>Implementar <code>PositionTooltip</code> convertendo <code>GridX/GridY</code> em pixels (usar 32 px por célula, equivalente a <code>INVENTORY_SQUARE_WIDTH/HEIGHT</code>) e adicionando o offset <code>(15,200)</code> do inventário legado.</li>
          <li>Para reparo, utilize <code>Widget Switcher</code> alternando entre <em>Default</em> e <em>Repair</em> conforme estado do inventário.</li>
          <li>Reproduzir efeitos de brilho usando <code>Material Instance</code> com máscara original e parâmetro <code>GlowIntensity</code> animado por <code>Timeline</code>.</li>
        </ol>
        <h4>Blueprint</h4>
        <pre><code>Function ShowTooltip(SlotData, bRepairMode)
  → Tooltip = Create Widget (WBP_ItemTooltip)
  → Tooltip.SetData(SlotData, bRepairMode)
  → Tooltip.PositionTooltip(GridOrigin + SlotData.Grid * 32)
  → Tooltip.AddToViewport(ZOrder 900)

Function HideTooltip()
  → If Tooltip Is Valid → Remove From Parent</code></pre>
        <div class="callout">
          <strong>Dica:</strong> use <code>Data Table Row Handle</code> para buscar descrições adicionais (sockets, excellence) e gerar listas dinâmicas com <code>CreateWidget(WBP_TooltipLine)</code> por categoria.
        </div>
      </details>

      <details class="guia">
        <summary>Minimapa + Mapas de Mundo</summary>
        <p>
          Reutilize as texturas <code>MapManager</code> e dados <code>Data/World/World*.txt</code> para gerar minimapas dinâmicos
          e mapas de navegação.
        </p>
        <ul>
          <li>Importar sprites originais do minimapa para <code>/Game/UI/Maps</code>.</li>
          <li>Converter posições absolutas em percentuais (dividir por resolução original 640x480) para aplicar em
            <code>Canvas Panel Slot</code>.</li>
          <li>Gerar <code>Render Targets</code> com ícones 3D (Player, Party, Boss) usando <code>SceneCapture2D</code>.</li>
          <li>Sincronizar com backend via endpoint <code>GET /world/events</code> para mostrar objetivos em tempo real.</li>
        </ul>
      </details>
    </section>

    <section id="backend">
      <h2>Trilha de Modernização Backend</h2>
      <p>
        Abaixo está um roteiro para reconstruir cada serviço do servidor legado em uma arquitetura moderna escalável,
        mantendo compatibilidade com o cliente UE5.
      </p>
      <div class="swimlane">
        <div>
          <strong>Serviço</strong>
          <ul>
            <li>AuthServer</li>
            <li>JoinServer</li>
            <li>DataServer</li>
            <li>GameServer</li>
            <li>Ranking/Tools</li>
          </ul>
        </div>
        <div>
          <strong>Plano de Ação</strong>
          <ul>
            <li>
              Substituir autenticação SimpleModulus por <code>OAuth2/JWT</code>. Criar endpoint <code>POST /auth/login</code>
              que valida credenciais no banco modernizado.
            </li>
            <li>
              Implementar <code>Session Service</code> (Redis/SQL) para registrar servidores disponíveis e distribuir jogadores.
            </li>
            <li>
              Migrar procedures de <code>DataServer</code> para microserviço com <code>Entity Framework</code> ou <code>Prisma</code>
              aplicando migrations automáticas.
            </li>
            <li>
              Criar API WebSocket/HTTP para eventos de gameplay (drop, xp, quests). UE5 se conecta via <code>Subsystem</code>
              personalizado.
            </li>
            <li>
              Reescrever ferramentas (<code>Tools/</code>) como painel web React/Vue para administração em tempo real.
            </li>
          </ul>
        </div>
      </div>
      <h3>Blueprint Gateway &rarr; Backend</h3>
      <p>
        Exemplo de implementação em Blueprint para consumo de API REST hospedada pelo novo backend. Utilize o plugin HTTP
        padrão da UE5 ou o sistema <code>VaRest</code>.
      </p>
      <pre class="code-card"><code>// BP_ServerGateway (Actor Component)
Event RequestLogin(Email, Senha)
  CreateRequest ← Construct HTTP Request
  SetURL "https://api.seuprojeto.com/auth/login"
  SetVerb POST
  SetHeader "Content-Type", "application/json"
  SetContent (Json Serialize {Email, Senha})
  ProcessRequest

Event OnResponseReceived(Request, Response, bWasSuccessful)
  If !bWasSuccessful → Broadcast OnLoginFailed
  Else
    ParseJSON(Response.Content)
    Cache Token, PlayerId
    Broadcast OnLoginSuccess(Token, PlayerId)
    → BP_InventoryManager.LoadRemoteInventory(Token)
</code></pre>
      <p>
        No backend, espelhe as regras de negócio originais (por exemplo, cálculos de XP em <code>GameServer/GameMain.cpp</code>)
        em serviços especializados. Garanta testes unitários antes de integrar com o cliente UE5.
      </p>
      <h3>Checklist de Confiabilidade</h3>
      <ul class="checklist">
        <li>Automatizar testes de carga para <code>/auth/login</code>, <code>/character/load</code> e <code>/drop/register</code>.</li>
        <li>Monitorar logs com ELK/Grafana, correlacionando IDs de sessão ao <code>PlayerID</code>.</li>
        <li>Implementar fila (RabbitMQ/Kafka) para eventos assíncronos como drops e notificações de ranking.</li>
        <li>Configurar pipelines CI/CD para servidor e cliente, garantindo builds reproduzíveis.</li>
      </ul>
    </section>

    <section id="social-guildas">
      <h2>Guia de Recriação — Sistemas Sociais e Guildas</h2>
      <p>
        Utilize esta trilha para reconstruir chat, lista de amigos e funcionalidades de guilda mantendo paridade com o
        cliente original. Todas as etapas contemplam integrações com o backend modernizado e o reaproveitamento dos
        assets de interface, ícones de ranks e avatares.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>1. Chat e Amigos</h3>
          <ul>
            <li>Importe fontes bitmap e ícones de canal (<code>UI/Chat/Icons</code>) para uma pasta <code>/UI/Chat</code> no UE5.</li>
            <li>Replique os painéis de conversa com widgets UMG. Utilize <code>ScrollBox</code> e <code>RichTextBlock</code> para manter cores e tags.</li>
            <li>Crie um <code>BP_ChatGateway</code> (Actor Component) com eventos <code>SendMessage</code>, <code>JoinChannel</code> e <code>ReceiveMessage</code>.</li>
            <li>No backend, exponha rotas WebSocket (<code>/chat/ws</code>) e REST (<code>/chat/history</code>). Sincronize com Redis para múltiplas instâncias.</li>
          </ul>
        </div>
        <div class="card">
          <h3>2. Estrutura de Guildas</h3>
          <ul>
            <li>Migração dos dados: converta tabelas <code>Guild</code>, <code>GuildMember</code> e <code>GuildStorage</code> para Data Tables/ORM atualizados.</li>
            <li>Monte um widget UMG com abas: Visão Geral, Membros, Diplomacia e Armazém usando os ícones originais.</li>
            <li>Implemente componentes Blueprints <code>BP_GuildService</code> com chamadas <code>LoadGuild</code>, <code>InviteMember</code>, <code>PromoteMember</code>.</li>
            <li>Backend: crie microserviço <code>GuildService</code> com endpoints REST. Use filas para logs de contribuições (RabbitMQ/Kafka).</li>
          </ul>
        </div>
        <div class="card">
          <h3>3. Diplomacia e Guerra</h3>
          <ul>
            <li>Reutilize banners originais (texturas 256x128) como <code>MaterialInstance</code> para o widget de bandeiras.</li>
            <li>Adapte scripts legados de guerra de castelo para Blueprint via <code>BP_WarController</code> que consome eventos do backend.</li>
            <li>Expose eventos <code>OnGuildDeclaredWar</code>, <code>OnGuildAlliance</code> para atualizar HUDs e notificações.</li>
            <li>No servidor, mantenha regras de agendamento com cron jobs. Envie broadcast via WebSocket para a UE5.</li>
          </ul>
        </div>
      </div>
      <details class="accordion open">
        <summary>Blueprint Focus: Widget de Chat Multifila</summary>
        <pre class="code-card"><code>// Widget_BP_ChatWindow (UMG)
Event Construct
  BindEvent BP_ChatGateway.OnMessageReceived → AddChatLine

Function SendCurrentMessage
  CurrentText ← GetText ChatInput
  BP_ChatGateway.SendMessage(CurrentChannel, CurrentText)
  ClearText ChatInput

Function AddChatLine(Channel, Sender, Message)
  Row ← CreateWidget(Widget_BP_ChatRow)
  Row.Setup(ChannelColor(Channel), Sender, Message)
  ChatScroll.AddChild(Row)
  ChatScroll.ScrollToEnd()</code></pre>
      </details>
      <div class="checklist">
        <p><strong>Checklist Social &amp; Guildas</strong></p>
        <ul>
          <li>Histórico de chat carrega mensagens anteriores via <code>/chat/history?channel=global</code>.</li>
          <li>Convite de guilda dispara notificação com os ícones originais e aplica permissões corretas.</li>
          <li>Armazém de guilda usa o mesmo blueprint de inventário com slots protegidos (replicação confiável).</li>
          <li>Logs de contribuição e guerra são persistidos e exibidos em tempo real no painel UMG.</li>
        </ul>
      </div>
    </section>

    <section id="economia-lojas">
      <h2>Guia de Recriação — Economia, Lojas e NPCs</h2>
      <p>
        Converta o sistema econômico original, mantendo listas de preços, moedas múltiplas e lógica de NPCs. Aproveite as
        sprites de botões e molduras existentes para acelerar a montagem dos menus.
      </p>
      <ol>
        <li>
          <strong>Normalização de Dados:</strong> gere Data Tables para <code>Items</code>, <code>ShopCatalog</code>, <code>BundlePromo</code>. Inclua campos de moeda e requisitos de classe.
        </li>
        <li>
          <strong>Blueprints de UI:</strong> crie widgets <code>Widget_BP_Shop</code> e <code>Widget_BP_CurrencyDisplay</code> reutilizando molduras originais. Monte grid dinâmico com <code>TileView</code>.
        </li>
        <li>
          <strong>Interação com NPC:</strong> derive de <code>BP_NPCBase</code> adicionando componente <code>BP_ShopInteractor</code> que abre o widget e solicita catálogo ao backend.
        </li>
        <li>
          <strong>Transações:</strong> implemente fluxo seguro: <code>RequestPurchase</code> → verificação de estoque → resposta com itens/atualização de moeda → animação de confirmação.
        </li>
      </ol>
      <div class="grid-2">
        <div>
          <h3>Exemplo Blueprint — Compra de Item</h3>
          <pre class="code-card"><code>// BP_ShopInteractor (Component)
Event RequestPurchase(ShopItemId)
  Payload ← MakeStruct(FPurchaseRequest)
  Payload.ItemId = ShopItemId
  Payload.PlayerId = CachedPlayerId
  HTTP_Post("/shop/purchase", Payload, OnPurchaseResponse)

Event OnPurchaseResponse(Response)
  If Response.Success
    InventoryManager.AddItem(Response.ItemData)
    CurrencyManager.UpdateBalances(Response.NewBalances)
    Widget_BP_Shop.PlayAnimation(SuccessAnim)
  Else
    Widget_BP_Shop.ShowError(Response.ErrorCode)</code></pre>
        </div>
        <div>
          <h3>Backend Modernizado</h3>
          <ul>
            <li>Crie microserviço <code>EconomyService</code> com endpoints <code>/shop/catalog</code>, <code>/shop/purchase</code>, <code>/shop/gift</code>.</li>
            <li>Implemente verificação de estoque e limites diários reutilizando regras de <code>DataServer</code>.</li>
            <li>Use transações SQL para debitar moedas e adicionar itens simultaneamente.</li>
            <li>Integre com sistema de logs para auditoria financeira e alertas.</li>
          </ul>
        </div>
      </div>
      <div class="checklist">
        <p><strong>Checklist de Economia</strong></p>
        <ul>
          <li>Todas as moedas (Zen, WCoin, Pontos de Evento) exibidas com ícones originais e atualização em tempo real.</li>
          <li>NPCs respeitam horários/condições configurados em Data Table reaproveitada.</li>
          <li>Compras bloqueadas corretamente quando inventário não possui espaço.</li>
          <li>Logs de compra acessíveis no painel administrativo recriado.</li>
        </ul>
      </div>
    </section>

    <section id="eventos-liveops">
      <h2>Guia de Recriação — Eventos Dinâmicos e Live Ops</h2>
      <p>
        Reaproveite scripts de eventos como Blood Castle, Devil Square e Chaos Castle adaptando-os para o ecossistema UE5.
        As instruções abaixo detalham como orquestrar servidores de evento, cronogramas e recompensas.
      </p>
      <div class="grid-2">
        <div>
          <h3>Fluxo Geral</h3>
          <ol>
            <li>Crie <code>BP_EventScheduler</code> (Subsystem) responsável por ler cronogramas do backend via <code>/events/schedule</code>.</li>
            <li>Para cada evento, spawnar <code>BP_EventController</code> que instancia mapas dedicados (Level Streaming) e configura spawners.</li>
            <li>Sincronize recompensas com <code>LootService</code> e notificações globais de chat.</li>
            <li>Ao finalizar, envie relatório de participação para o backend e atualize rankings.</li>
          </ol>
        </div>
        <div>
          <h3>Blueprint — Entrada em Evento</h3>
          <pre class="code-card"><code>// BP_EventPortal (Actor)
Event OnPlayerInteract(Player)
  EventInfo ← EventScheduler.GetNext("BloodCastle")
  If EventInfo.IsOpen
    PlayerController.OpenConfirmation(EventInfo.Description)
    PlayerController.OnConfirm → JoinEvent

Function JoinEvent(Player)
  HTTP_Post("/events/join", {EventId, PlayerId})
  OnSuccess → PlayerTravelToLevel(EventInfo.LevelPath)
  OnFailure → UI.ShowError(EventInfo.ErrorMessage)</code></pre>
        </div>
      </div>
      <details class="accordion open">
        <summary>Checklist de Live Ops</summary>
        <ul>
          <li>Cronogramas convertidos do legado para JSON (armazenados no backend).</li>
          <li>Rankings atualizados após cada evento e exibidos no widget original adaptado.</li>
          <li>Recompensas respeitam tabelas de drop herdadas, com logs persistidos.</li>
          <li>GM Tools permitem iniciar, pausar ou cancelar eventos manualmente.</li>
        </ul>
      </details>
    </section>

    <section id="crafting-refino">
      <h2>Guia de Recriação — Crafting, Aprimoramento e Refinamento</h2>
      <p>
        Esta seção guia a reconstrução dos sistemas de crafting, reforço de armas/armaduras, combinação de jóias e
        manufatura de consumíveis. Reaproveite interfaces bitmap (<code>UI/Crafting</code>) e tabelas de sucesso que estão em
        <code>DataServer/Scripts/Craft</code>, traduzindo-as para Data Tables da UE5 e serviços backend.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>1. Preparação de Dados</h3>
          <ul>
            <li>Converter tabelas <code>ChaosMachine</code>, <code>JewelMix</code> e <code>ItemUpgrade</code> em <code>CSV</code> → Data Tables.</li>
            <li>Mapear requisitos de nível, taxa de sucesso e custos para structs <code>FCraftingRecipe</code>.</li>
            <li>Normalizar ícones para <code>Texture2D</code> preservando offsets originais (consultar atlas fornecido).</li>
          </ul>
        </div>
        <div class="card">
          <h3>2. Interface UMG</h3>
          <ul>
            <li>Criar <code>Widget_BP_Crafting</code> com <code>CanvasPanel</code> usando coordenadas originais listadas no atlas.</li>
            <li>Adicionar slots de item (<code>BP_ItemSlot</code>) com suporte a arrastar/soltar e highlights de sucesso.</li>
            <li>Reutilizar animações de brilho importando <code>UI/Crafting/GlowFlipbook</code> para <code>Niagara</code>.</li>
          </ul>
        </div>
        <div class="card">
          <h3>3. Backend e Regras</h3>
          <ul>
            <li>Implementar microserviço <code>CraftingService</code> com endpoints <code>/craft/preview</code> e <code>/craft/execute</code>.</li>
            <li>Portar lógica de sucesso da <code>ChaosMachine.cpp</code> para função <code>CalculateCraftResult</code> com seed determinística.</li>
            <li>Logar eventos em <code>CraftingAudit</code> para rastrear consumo de recursos.</li>
          </ul>
        </div>
      </div>
      <div class="grid-2">
        <div>
          <h3>Blueprint — Execução da Máquina do Caos</h3>
          <pre class="code-card"><code>// Widget_BP_Crafting
Event OnCraftButtonClicked()
  Request.Payload ← BuildPayloadFromSlots()
  HTTP_Post("/craft/preview", Payload, OnPreviewResponse)

Event OnPreviewResponse(Response)
  If Response.SuccessRate &lt; Threshold
    ShowWarning("Chance baixa. Confirmar?")
  Else
    ExecuteCraft(Response)</code></pre>
        </div>
        <div>
          <h3>Blueprint — Confirmação e Resultado</h3>
          <pre class="code-card"><code>Function ExecuteCraft(PreviewData)
  HTTP_Post("/craft/execute", PreviewData.Request, OnCraftResolved)

Event OnCraftResolved(Result)
  If Result.Success
    InventoryManager.ReplaceItems(Result.ItemsAwarded)
    PlayAnimation(SuccessBurst)
  Else
    InventoryManager.RemoveItems(Result.ItemsConsumed)
    PlayAnimation(FailureSpark)
  Telemetry.Emit("craft", Result)</code></pre>
        </div>
      </div>
      <details class="accordion open">
        <summary>Checklist de Crafting</summary>
        <ul>
          <li>Slots respeitam posicionamento legado (veja tabela de coordenadas na aba Atlas).</li>
          <li>Taxas de sucesso batem com percentuais originais (comparar 100 execuções automatizadas).</li>
          <li>Consumíveis retornam tooltips atualizados após cada craft.</li>
          <li>Logs de crafting integrados ao painel de operações.</li>
        </ul>
      </details>
    </section>

    <section id="montarias-pets">
      <h2>Guia de Recriação — Montarias, Pets e Companheiros</h2>
      <p>
        Reconstrua as funcionalidades de pets de combate, montarias e mascotes cosméticos mantendo animações e estatísticas
        herdadas. Use os modelos originais (pasta <code>Client/Data/Pets</code>) convertendo-os para <code>SkeletalMesh</code> com
        retargeting para os rigs da UE5.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>Importação e Retarget</h3>
          <ul>
            <li>Converter arquivos <code>.bmd/.ozj</code> para <code>.fbx</code> usando o pipeline existente.</li>
            <li>Aplicar retarget no <code>IK Retargeter</code> para animações de idle, walk, run, attack.</li>
            <li>Configurar <code>DataAssets</code> <code>DA_PetDefinition</code> com atributos, bônus e efeitos visuais.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Comportamento em Blueprint</h3>
          <ul>
            <li>Criar <code>BP_PetCompanion</code> (Character) com <code>AIController</code> baseado em Behaviour Tree.</li>
            <li>Implementar estados: seguir jogador, atacar alvo prioritário, coletar drops (respeitando filtros do inventário).</li>
            <li>Adicionar componente <code>BP_PetStats</code> sincronizado com backend via <code>/pet/status</code>.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Backend Integrado</h3>
          <ul>
            <li>Criar serviço <code>PetService</code> responsável por evolução, armazenamento e buffs temporários.</li>
            <li>Portar scripts de evolução (<code>PetEvolution.lua</code>) para funções versionadas.</li>
            <li>Expôr sockets para atualizações em tempo real (WebSocket <code>/pet/live</code>).</li>
          </ul>
        </div>
      </div>
      <div class="grid-2">
        <div>
          <h3>Blueprint — Montaria</h3>
          <pre class="code-card"><code>// BP_MountComponent
Event EquipMount(MountId)
  MountData ← PetRepository.GetMount(MountId)
  SpawnActor(BP_MountPawn, MountData.Mesh)
  AttachToComponent(Player, Socket="Pelvis")
  Player.Movement.SetMovementMode(Flying ? Fly : MoveWalking)
  Backend.Notify("/mount/activate", MountId)</code></pre>
        </div>
        <div>
          <h3>Blueprint — Pet de Coleta</h3>
          <pre class="code-card"><code>// BTTask_CollectDrop
ExecuteTask()
  TargetItem ← SenseComponent.GetNearestDrop()
  If Inventory.HasFreeSlot(TargetItem)
    MoveTo(TargetItem.Location)
    Interact → LootService.RegisterPickup(TargetItem.Id)
    Inventory.AddItem(TargetItem)
  FinishExecute(true)</code></pre>
        </div>
      </div>
      <details class="accordion open">
        <summary>Checklist de Montarias e Pets</summary>
        <ul>
          <li>Padrões de velocidade e bônus replicados conforme planilhas originais.</li>
          <li>UI de gerenciamento reutiliza ícones e molduras convertidos.</li>
          <li>Pet respeita colisões do mapa e evita pegar itens negados pelo filtro do jogador.</li>
          <li>Persistência de evolução validada com testes de reconexão.</li>
        </ul>
      </details>
    </section>

    <section id="comandos-seguranca">
      <h2>Guia de Recriação — Comandos, Opções e Segurança</h2>
      <p>
        O cliente legado mistura atalhos personalizados, comandos <em>slash</em> e filtros anti-cheat
        para proteger a experiência. Esta seção descreve como migrar o fluxo completo para UE5,
        mantendo a compatibilidade com os arquivos de configuração e tabelas originais.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>Comandos Slash</h3>
          <p><strong>Referência:</strong> <code>CommandManager.cpp</code>, <code>Command.cpp</code>,
            <code>Data/Command.txt</code>.</p>
          <ul>
            <li>Converter <code>Data/Command.txt</code> para <code>DT_CommandCatalog</code> com campos
              <code>Label</code>, <code>Permission</code>, <code>Arguments</code>.</li>
            <li>Implementar <code>BP_CommandParser</code> replicando <code>GetNumber/GetString</code>
              para extrair argumentos.</li>
            <li>Criar microserviço <code>CommandService</code> que executa as ações (
              <code>/move</code>, <code>/reset</code>, <code>/post</code>) com validações de permissão
              iguais a <code>CommandManager::CheckAuthority</code>.</li>
            <li>Emitir feedback no chat usando os mesmos códigos de mensagem (<code>gMessage.GetMessage</code>).</li>
          </ul>
        </div>
        <div class="card">
          <h3>Painel de Opções</h3>
          <p><strong>Referência:</strong> <code>NewUIOptionWindow.cpp</code>,
            <code>NewUIHotKey.cpp</code>, <code>NewUIMoveCommandWindow.cpp</code>.</p>
          <ul>
            <li>Mapear controles originais (sensibilidade, som, filtros de chat) para <code>CommonUI</code>
              usando <code>WBP_OptionsMenu</code>.</li>
            <li>Persistir valores em <code>USaveGame</code> com a mesma granularidade (slots para macro A–Z,
              câmera mínima/máxima, filtros de drop).</li>
            <li>Expor API <code>/profile/options</code> para sincronizar preferências entre dispositivos.</li>
            <li>Reutilizar ícones e sliders convertendo <code>Interface/newui_option_*.ozj</code>.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Filtros &amp; Anti-cheat</h3>
          <p><strong>Referência:</strong> <code>Filter.cpp</code>, <code>HackPacketCheck.cpp</code>,
            <code>HackCheck.cpp</code>, arquivos <code>Data/Hack/*.txt</code>.</p>
          <ul>
            <li>Transformar <code>HackPacketCheck.txt</code> e <code>HackSkillCheck.txt</code> em regras JSON
              consumidas por um serviço <code>SecurityService</code>.</li>
            <li>Aplicar sanitação de chat replicando <code>CFilter::CheckSyntax</code> antes de exibir mensagens.</li>
            <li>Registrar eventos suspeitos (packet flood, skill inválido) e bloquear temporariamente a conta,
              enviando métricas para o painel de telemetria.</li>
            <li>Integração opcional com soluções modernas (EOS, GameShield) mantendo o fallback legado.</li>
          </ul>
        </div>
      </div>
      <div class="source-card">
        <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/CommandManager.cpp</code></div>
        <pre><code>void CCommandManager::MainProc()
{
        for(int n=OBJECT_START_USER;n < MAX_OBJECT;n++)
        {
                if(gObjIsConnectedGP(n) == 0)
                {
                        continue;
                }

                if(gObj[n].AutoAddPointCount > 0)
                {
                        this->CommandAddPointAutoProc(&gObj[n]);
                }

                if(gObj[n].AutoResetEnable != 0)
                {
                        this->CommandResetAutoProc(&gObj[n]);
                }
        }
}</code></pre>
      </div>
      <div class="source-card">
        <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/Filter.cpp</code></div>
        <pre><code>void CFilter::CheckSyntax(char* text)
{
        for(int n=0;n < this->m_count;n++)
        {
                char* temp = text;

                while(true)
                {
                        temp = strstr(temp,this->m_FilterInfo[n].label);

                        if(temp == 0)
                        {
                                break;
                        }

                        int len = strlen(this->m_FilterInfo[n].label);

                        memset(temp,0x2A,len);

                        temp += len;
                }
        }
}</code></pre>
      </div>
      <div class="source-card">
        <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/HackPacketCheck.cpp</code></div>
        <pre><code>info.Index = lpMemScript->GetNumber();
info.Value = lpMemScript->GetAsNumber();
info.Encrypt = lpMemScript->GetAsNumber();
info.MaxDelay = lpMemScript->GetAsNumber();
info.MinCount = lpMemScript->GetAsNumber();
info.MaxCount = lpMemScript->GetAsNumber();
this->SetInfo(info);</code></pre>
      </div>
      <h4>Blueprint &amp; Fluxo de Segurança</h4>
      <pre class="code-card"><code>// BP_CommandParser
Event OnChatSubmitted(Text)
  If Text.StartsWith("/")
    Parsed ← ParseCommand(Text)
    HTTP_Post("/command/execute", Parsed, OnCommandResult)
  Else
    ChatGateway.SendMessage(Text)

Function OnSecurityAlert(AlertPayload)
  HUD.ShowWarning(AlertPayload.Message)
  If AlertPayload.Action == "kick"
    ClientTravel(LoginMap)

SecurityService.Bind("/security/alert", OnSecurityAlert)</code></pre>
      <div class="checklist">
        <p><strong>Checklist de Segurança</strong></p>
        <ul>
          <li>Todos os comandos disponíveis respeitam permissões de <code>Data/Command.txt</code>.</li>
          <li>Logs auditáveis para uso de comandos, mudanças de opções e bloqueios temporários.</li>
          <li>Alertas de hack acionam respostas automáticas e registram pacotes para investigação.</li>
          <li>Opções persistidas sincronizam com o backend e carregam ao entrar no jogo.</li>
        </ul>
      </div>
    </section>

    <section id="pvp-arenas">
      <h2>Guia de Recriação — PvP, Arenas e Guerras</h2>
      <p>
        Replique arenas PvP, duelos, Castle Siege e campos de batalha com base nas rotinas originais. Este guia apresenta
        instruções claras para configurar mapas, rotas de matchmaking e integração de rankings competitivos.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>Matchmaking e Filas</h3>
          <ul>
            <li>Implementar <code>BP_PvPQueueManager</code> (Subsystem) responsável por registrar jogadores e consultar <code>/pvp/queue</code>.</li>
            <li>Utilizar <code>Data Tables</code> <code>DT_PvPRules</code> para restrições de nível/classe.</li>
            <li>Sincronizar estado com HUD via eventos multicast (<code>OnQueueStatusChanged</code>).</li>
          </ul>
        </div>
        <div class="card">
          <h3>Configuração de Mapas</h3>
          <ul>
            <li>Converter mapas originais usando <code>Datasmith</code> ou exportadores dedicados, mantendo posições de spawn.</li>
            <li>Configurar <code>BP_PvPSpawnPoint</code> com coordenadas importadas do arquivo <code>MapSettings/pvp_spawn.csv</code>.</li>
            <li>Adicionar <code>LevelSequence</code> para cutscenes de abertura e fechamento reaproveitando câmeras legadas.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Regras e Pontuação</h3>
          <ul>
            <li>Portar scripts de <code>GameServer/PvPManager.cpp</code> para microserviço <code>PvPService</code>.</li>
            <li>Emitir eventos de dano/morte através de <code>BP_PvPCombatComponent</code> para atualizar placares.</li>
            <li>Atualizar rankings e recompensas com <code>RankingService</code>, garantindo transmissão em tempo real.</li>
          </ul>
        </div>
      </div>
      <div class="grid-2">
        <div>
          <h3>Blueprint — Entrada em Arena</h3>
          <pre class="code-card"><code>// BP_PvPQueueWidget
Event OnJoinQueue()
  Request.MatchType = SelectedMode
  HTTP_Post("/pvp/queue/join", Request, OnQueueJoined)

Event OnQueueJoined(Response)
  If Response.Status == "Waiting"
    PlayAnimation(QueuePulse)
    BindDelegates(PvPQueueManager.OnMatchReady, HandleMatchReady)
  Else
    ShowError(Response.Message)</code></pre>
        </div>
        <div>
          <h3>Blueprint — Preparação de Siege</h3>
          <pre class="code-card"><code>// BP_SiegeController
Event HandleMatchReady(MatchInfo)
  LoadStreamedLevel(MatchInfo.LevelPath)
  AssignTeams(MatchInfo.TeamAssignments)
  SpawnActors(BP_SiegeGate, MatchInfo.GateLocations)
  CountdownWidget.Start(MatchInfo.StartTime)
  Backend.Notify("/siege/ready", MatchInfo.MatchId)</code></pre>
        </div>
      </div>
      <details class="accordion open">
        <summary>Checklist PvP</summary>
        <ul>
          <li>Tempos de respawn equivalentes ao legado (validar com scripts automatizados).</li>
          <li>Rankings refletem resultados imediatamente após cada partida.</li>
          <li>HUD mostra status de objetivos (gates, relíquias) usando ícones originais.</li>
          <li>Logs de combate sincronizados com sistema anti-cheat.</li>
        </ul>
      </details>
    </section>

    <section id="qa-operacoes">
      <h2>Operações, Telemetria e Preparação de Lançamento</h2>
      <p>
        Consolide o processo de QA com foco em build contínuo, monitoramento e suporte pós-lançamento. Esta seção amplia o
        guia anterior com passos práticos para times de operações e suporte.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>Pipelines Automatizados</h3>
          <ul>
            <li>Configure build de cliente UE5 via <code>UnrealBuildTool</code> e empacotamento automático em agentes dedicados.</li>
            <li>Execute testes automatizados (Functional Tests) após cada commit crítico.</li>
            <li>Gere relatórios HTML anexados ao repositório de documentação.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Telemetria</h3>
          <ul>
            <li>Instrumente Blueprints principais com <code>BP_TelemetryEmitter</code> enviando dados para um serviço <code>/metrics</code>.</li>
            <li>Mapeie eventos: login, seleção de personagem, entrada em mapa, loot raro, evolução de habilidade.</li>
            <li>Armazene métricas em banco time-series (InfluxDB/Timescale) e visualize em Grafana.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Suporte e GM Tools</h3>
          <ul>
            <li>Modernize ferramentas <code>Tools/</code> como painel web com autenticação.</li>
            <li>Crie endpoints seguros para banimentos, restauração de itens e gerenciamento de filas.</li>
            <li>Integre logs de chat e eventos para auditoria em tempo real.</li>
          </ul>
        </div>
      </div>
      <details class="accordion open">
        <summary>Procedimento de Release</summary>
        <ol>
          <li>Gerar build candidata do cliente UE5 e publicar em canal interno.</li>
          <li>Executar testes de carga no backend com simulação de 2x jogadores simultâneos do pico previsto.</li>
          <li>Rodar checklist de regressão (login → seleção → HUD → combate → logout) em três mapas distintos.</li>
          <li>Validar telemetria e alertas de monitoramento antes de liberar para produção.</li>
        </ol>
      </details>
    </section>

    <section id="roadmap-integrado">
      <h2>Roadmap Integrado Frontend + Backend (16 Semanas)</h2>
      <p>
        Expanda o cronograma existente com foco em sincronizar as entregas de interface e serviços. Cada marco possui metas
        tangíveis para ambos os lados.
      </p>
      <ol>
        <li>
          <strong>Semanas 1-2:</strong> Auditoria de assets &amp; dados, criação de protótipos UMG, scaffold do backend (Auth,
          Character Service).
        </li>
        <li>
          <strong>Semanas 3-4:</strong> Inventário funcional com persistência via API. Importação inicial de itens e ícones.
        </li>
        <li>
          <strong>Semanas 5-6:</strong> Progressão XP/nível completa, endpoints de missão. Integração de eventos básicos (Blood
          Castle, Devil Square).
        </li>
        <li>
          <strong>Semanas 7-8:</strong> Migração dos mapas principais com streaming e triggers. Backend fornece dados de spawn e
          horário de eventos.
        </li>
        <li>
          <strong>Semanas 9-10:</strong> Sistema de drop refinado com sincronização de loot. Integração de notificações e log de
          itens.
        </li>
        <li>
          <strong>Semanas 11-12:</strong> Loja, economia e guildas conectadas. Ferramentas de administração web minimalistas.
        </li>
        <li>
          <strong>Semanas 13-14:</strong> Polimento audiovisual, efeitos Niagara, metasounds, sistemas de ranking.</li>
        <li>
          <strong>Semanas 15-16:</strong> Testes finais (performance, regressão, cross-play), preparação da release e pipelines
          automatizados.
        </li>
      </ol>
    </section>

    <section id="missoes_eventos">
      <h2>Blueprint de Recriação: Missões, Eventos e Rankings</h2>
      <p>
        Esta etapa complementa os sistemas já mapeados adicionando instruções específicas para missões, eventos recorrentes e
        rankings competitivos. O objetivo é transformar os scripts legados (MissionServer, EventMgr, RankingService) em uma
        solução híbrida UE5 + backend com rotas HTTP/WebSocket e nós Blueprint claros.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>1. Auditoria de Dados de Missões</h3>
          <ul>
            <li>Localize tabelas legadas <strong>QuestData</strong> e <strong>QuestProgress</strong> (SQL/DataServer).</li>
            <li>Exporte para CSV com colunas <em>QuestID, Nome, Tipo, Condição, Recompensa, Exp, ItemID</em>.</li>
            <li>Converta para <strong>Data Table UE5</strong> baseada em <code>UStruct FQuestDefinition</code>.</li>
            <li>Reaproveite ícones originais (UI\QuestIcons\*.dds) convertendo para PNG/UE texture.</li>
          </ul>
        </div>
        <div class="card">
          <h3>2. Blueprint Flow de Missões</h3>
          <ul>
            <li>Crie <strong>BP_QuestManager</strong> (Actor Singleton) com <em>GameInstanceSubsystem</em>.</li>
            <li>Adicione função <code>StartQuest(QuestID)</code> que consulta Data Table e inicializa objetivos.</li>
            <li>Implemente <code>TrackObjective</code> para escutar eventos de kill/collect usando <strong>Gameplay Tags</strong>.</li>
            <li>Use <strong>SaveGame</strong> para persistir progresso offline e chamadas REST para sincronizar online.</li>
          </ul>
        </div>
        <div class="card">
          <h3>3. Eventos &amp; Rankings</h3>
          <ul>
            <li>Mapeie agendamentos do <strong>EventScheduler.cfg</strong> para <code>UDataAsset</code> com horários.</li>
            <li>Crie <strong>BP_EventPortal</strong> que valida pré-requisitos antes de transportar jogadores.</li>
            <li>Consuma endpoint <code>/events/current</code> para preencher painel dinâmico.</li>
            <li>Construa <strong>BP_RankingBoard</strong> lendo cache Redis/SQL via microserviço Ranking.</li>
          </ul>
        </div>
      </div>

      <details class="guia">
        <summary>Passo a passo: replicar painel de missões usando os widgets originais</summary>
        <ol>
          <li>Importe layout legado (<code>UI/Quests/quest_window.psd</code>) como <strong>Widget Blueprint</strong> e recrie posições
            com base nas coordenadas originais (anote X/Y/W/H do XML antigo em <em>UIConfig</em>).</li>
          <li>Crie <strong>WBP_QuestJournal</strong> com <code>Overlay</code> + <code>ScrollBox</code> e instancie <strong>WBP_QuestEntry</strong>
            para cada linha.</li>
          <li>Ligação Blueprint: <code>Event Construct → Get Game Instance → GetQuestManager → Bind OnQuestUpdated → RefreshList</code>.</li>
          <li>Nos botões de aceitar/entregar, chame <code>QuestManager::SendQuestRequest</code> que por sua vez faz <code>HTTP POST /quests/accept</code>
            com <strong>playerSessionId</strong> + <strong>questId</strong>.</li>
          <li>Atualize animações utilizando os assets de barras e highlight originais (UI\Animations\quest_highlight.uasset) convertidos.</li>
        </ol>
      </details>

      <div class="swimlane">
        <div>
          <strong>Frontend UE5</strong>
          <ul>
            <li>BP_QuestManager como subsystem e replicação opcional via <code>Multicast</code>.</li>
            <li>Widgets UMG para diário, notificações e tracker rápido.</li>
            <li>Eventos de <em>Gameplay Ability System</em> para habilidades que interagem com missões.</li>
          </ul>
        </div>
        <div>
          <strong>Backend Modernizado</strong>
          <ul>
            <li>Microserviço <code>QuestService</code> com rotas <code>GET /quests</code>, <code>POST /progress</code>, <code>POST /complete</code>.</li>
            <li>Sincronização com <strong>MissionServer</strong> original via jobs de migração até corte definitivo.</li>
            <li>Publica eventos em <strong>Kafka/RabbitMQ</strong> para atualizar rankings e log global.</li>
          </ul>
        </div>
      </div>

      <div class="blueprint-flow">
        <div class="blueprint-step">
          <h4>Spawner de Evento (World Partition)</h4>
          <p>
            No mapa convertido, coloque <strong>BP_EventAnchor</strong> contendo <code>Box Trigger</code>. No <em>Begin Play</em>, carregue dados do evento
            corrente e habilite o portal apenas se <code>ServerTime</code> estiver na janela configurada.
          </p>
        </div>
        <div class="blueprint-step">
          <h4>Atualização de Ranking em Tempo Real</h4>
          <p>
            Utilize <code>WebSocket Connect</code> → <code>OnMessage</code> para receber payload <em>{eventId, playerId, score}</em> e atualizar lista
            ordenada com <code>Sort Array</code>. Mostre feedback visual usando os mesmos badges da interface clássica.
          </p>
        </div>
        <div class="blueprint-step">
          <h4>Recompensa Sincronizada</h4>
          <p>
            Após <code>Quest Complete</code>, dispare <code>Async Task - Open Level Sequence</code> para cutscene opcional e chame endpoint
            <code>/rewards/grant</code>. Persistência local usa SaveGame <strong>SG_QuestProgress</strong> espelhando colunas originais.
          </p>
        </div>
      </div>

      <div class="callout">
        <strong>Dica:</strong> Reaproveite <em>sounds/ui/quest_accept.wav</em> e <em>sounds/ui/quest_complete.wav</em> convertendo para WAV 16-bit.
        Aplique via <code>Audio Component</code> para manter fidelidade com a build original.
      </div>
    </section>

    <section id="operacoes_avancadas">
      <h2>Centro de Otimização, Segurança e Operações Contínuas</h2>
      <p>
        Para sustentar o projeto após a migração, consolide as práticas de performance, segurança, deployment e observabilidade.
        Esta seção apresenta um roteiro incremental reutilizando ferramentas legadas (LogServer, Monitor.exe) e adotando novas
        rotinas no ecossistema UE5.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>Performance &amp; Memória</h3>
          <ul>
            <li>Habilite <strong>Stat GPU/CPU</strong> e <strong>Insights Trace</strong> durante testes de mapas.</li>
            <li>Crie perfis de <em>Niagara</em> reaproveitando curvas originais para limitar partículas.</li>
            <li>Utilize <strong>LOD Sync</strong> para armaduras convertidas (SkeletalMesh) com base em distâncias da versão clássica.</li>
            <li>Automatize <em>Cooked Builds</em> via <code>RunUAT BuildCookRun</code> integrado ao pipeline de CI.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Segurança &amp; Anti-Cheat</h3>
          <ul>
            <li>Migre validações de <strong>GameGuard.dll</strong> para microserviço <code>SecurityGateway</code> (token + checksums).</li>
            <li>Implemente <code>Server RPC</code> autoritativas para XP, drops e trades.</li>
            <li>Assine pacotes críticos com <strong>HTTPS + JWT</strong>; renove chaves a cada 30 dias.</li>
            <li>Monitoramento de integridade: compare <em>hash</em> de assets principais com tabela original.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Deploy &amp; Observabilidade</h3>
          <ul>
            <li>Containerize backend (Docker) e orquestre com scripts herdados (deploy.sh) convertidos para pipelines CI/CD.</li>
            <li>Capture métricas de UE5 via <strong>UnrealInsights Server</strong> + exporter Prometheus.</li>
            <li>Encaminhe logs de Blueprint para o <strong>LogServer</strong> modernizado (ELK ou Loki).</li>
            <li>Acione alertas automáticos quando <code>tickTime &gt; 33ms</code> ou fila de matchmaking exceder limite legado.</li>
          </ul>
        </div>
      </div>

      <details class="guia">
        <summary>Checklist de Release (Frontend + Backend)</summary>
        <ul class="checklist">
          <li>Build UE5 cozido para Windows + testes de smoke em Steam/Epic.</li>
          <li>Microserviços Quest, Item, Skill e Ranking em cluster com health-check.</li>
          <li>Logs estruturados (JSON) armazenados por 30 dias com correlação de <em>sessionId</em>.</li>
          <li>Plano de rollback documentado reutilizando backups do DataServer original.</li>
          <li>Testes automatizados de API (Postman/Newman) cobrindo login, personagem, quest, drop.</li>
          <li>Validação de assets críticos com <strong>Unreal Asset Audit</strong> + tabela comparativa.</li>
        </ul>
      </details>

      <h3>Fluxo de Trabalho Sugerido</h3>
      <ol>
        <li><strong>Semana -2:</strong> Preparar infraestrutura CI (GitHub Actions/GitLab) espelhando scripts da build antiga.</li>
        <li><strong>Semana -1:</strong> Configurar pipelines de teste automatizado (unitário backend + funcional frontend com GAuntlet).</li>
        <li><strong>Lançamento:</strong> Executar checklist de release, publicar pacotes, monitorar dashboards.</li>
        <li><strong>Pós-Lançamento:</strong> Rodar retroalimentação diária com telemetria e aplicar hotfix usando branch <em>release/x.y</em>.</li>
      </ol>

      <div class="callout">
        <strong>Ferramentas sugeridas:</strong> Unreal Insights, GAuntlet, Playtest Automation, Sentry/Elastic, Prometheus + Grafana,
        OWASP Dependency Check para serviços backend.
      </div>
    </section>

    <section id="cronograma">
      <h2>Cronograma Sugerido (12 Semanas)</h2>
      <div class="timeline">
        <div class="timeline-step">
          <span class="label">Semanas 1–2</span>
          <strong>Auditoria &amp; Setup</strong>
          <ul>
            <li>Converter lote piloto de assets e validar materiais.</li>
            <li>Configurar controle de versão e documentação.</li>
            <li>Definir curvas de XP, lista de itens e mapas prioritários.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 3–5</span>
          <strong>HUD, Inventário e Dados</strong>
          <ul>
            <li>Recriar HUD completo e fluxo de inventário.</li>
            <li>Integrar dados de itens e efeitos básicos.</li>
            <li>Testar persistência e replicação (se multiplayer).</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 6–8</span>
          <strong>Progressão &amp; Loot</strong>
          <ul>
            <li>Implementar XP, níveis, habilidades destraváveis.</li>
            <li>Configurar drops por região e chefes.</li>
            <li>Balancear economia e recompensas.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 9–10</span>
          <strong>Mapas e Conteúdo</strong>
          <ul>
            <li>Migrar mapas restantes com colisão e navegação.</li>
            <li>Adicionar eventos, missões e spawners.</li>
            <li>Testes de performance e correções estruturais.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 11–12</span>
          <strong>Polimento Final</strong>
          <ul>
            <li>Atualizar VFX, trilhas e voice overs.</li>
            <li>QA completo, bug bash e checklist de build.</li>
            <li>Preparar material de entrega e documentação final.</li>
          </ul>
        </div>
      </div>
    </section>
      </div>
    </div>
  </main>
  <footer>
    Atualize este guia conforme novas descobertas na migração. Marque o progresso no checklist e use os exemplos de Blueprint como base para acelerar as próximas etapas.
  </footer>
  <script>
    const stageContent = {
      default: {
        titulo: "Ordem ideal sugerida",
        passos: [
          "Finalize auditoria e importação de um lote piloto de assets.",
          "Protótipo completo de HUD + inventário utilizando dados originais.",
          "Implemente itens, XP e drops com Data Tables reaproveitadas.",
          "Migre mapas, spawners e triggers para UE5 com World Partition.",
          "Ajuste efeitos, áudio e iluminação, encerrando com testes finais."
        ]
      },
      asset: {
        titulo: "Quando há muitos assets convertidos",
        passos: [
          "Priorize planilha de estado dos assets e importe somente os aprovados.",
          "Crie um mapa de revisão (Asset Playground) para testar materiais/LODs.",
          "Depois conecte HUD + inventário usando os ícones e meshes já convertidos.",
          "Mantenha assets incompletos marcados como placeholders até a Etapa 4."
        ]
      },
      ui: {
        titulo: "Foco em interface",
        passos: [
          "Migre fontes, ícones e animações UI para UMG.",
          "Implemente HUD modular usando Common UI e reutilizando widgets originais.",
          "Conecte inventário e barras de status aos dados herdados.",
          "Só avance para XP/drops quando HUD responder a todos eventos principais."
        ]
      },
      core: {
        titulo: "Foco em sistemas centrais",
        passos: [
          "Garanta que Data Tables de itens, XP e drops estejam convertidas.",
          "Crie componentes Blueprints (Inventory, Progression, LootSpawner).",
          "Monte mapa de combate de teste para balancear valores reutilizados.",
          "Integre com HUD existente antes de distribuir para mapas completos."
        ]
      },
      maps: {
        titulo: "Entrega rápida de mapas",
        passos: [
          "Importe blocos estruturais (terreno, malhas principais) primeiro.",
          "Configure World Partition e volumes de navegação.",
          "Reaplique iluminação/pós-processo original e valide colisões.",
          "Após mapas estáveis, posicione inimigos e conecte drops e eventos."
        ]
      },
      vfx: {
        titulo: "Foco em efeitos e audiovisual",
        passos: [
          "Organize texturas de partículas e sons legados em pastas Niagara/Audio.",
          "Atualize efeitos críticos (habilidades, feedback de dano) usando Niagara.",
          "Integre MetaSounds para música adaptativa com dados reutilizados.",
          "Finalize com pós-processo e passes de iluminação após mapas prontos."
        ]
      }
    };

    const select = document.getElementById("perfil");
    const output = document.getElementById("saidaPlano");
    document.getElementById("verPlano").addEventListener("click", () => {
      const escolha = stageContent[select.value] || stageContent.default;
      output.innerHTML = `<strong>${escolha.titulo}</strong><ol style="margin-top:0.85rem;">${escolha.passos
        .map((passo) => `<li>${passo}</li>`)
        .join("")}</ol>`;
    });

    const atlasTabs = document.querySelectorAll(".atlas-tab");
    const atlasContents = document.querySelectorAll(".atlas-content");
    atlasTabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        const alvo = tab.dataset.tab;
        atlasTabs.forEach((t) => t.classList.toggle("active", t === tab));
        atlasContents.forEach((content) => {
          content.classList.toggle("active", content.dataset.tab === alvo);
        });
      });
    });

    const conversionButtons = document.querySelectorAll(".conversion-button");
    const conversionPanes = document.querySelectorAll(".conversion-pane");
    conversionButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const target = button.dataset.pane;
        conversionButtons.forEach((b) => b.classList.toggle("active", b === button));
        conversionPanes.forEach((pane) => {
          pane.classList.toggle("active", pane.dataset.pane === target);
        });
      });
    });
  </script>
</body>
</html>
