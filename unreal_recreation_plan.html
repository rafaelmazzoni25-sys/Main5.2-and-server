<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Plano Direcionado para Recriação do Projeto na Unreal Engine 5</title>
  <style>
    :root {
      color-scheme: light;
      --azul-escuro: #123a63;
      --azul: #0c8dd9;
      --azul-claro: #ecf4ff;
      --cinza: #455a74;
      --verde: #35a07e;
      --amarelo: #f6b73c;
      --vermelho: #d9534f;
      --fundo: #f3f6fb;
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.65;
      margin: 0;
      background: var(--fundo);
      color: #1f2a3a;
    }
    header {
      background: linear-gradient(135deg, var(--azul-escuro), var(--azul));
      color: #fff;
      padding: 3rem 1.5rem 2.5rem;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    header::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at top right, rgba(255, 255, 255, 0.28), transparent 55%);
    }
    header h1 {
      margin: 0 auto 0.75rem;
      max-width: 720px;
      font-size: clamp(2.25rem, 2.7vw + 1.1rem, 3.25rem);
    }
    header p {
      margin: 0 auto;
      max-width: 720px;
      font-size: 1.05rem;
      opacity: 0.95;
    }
    main {
      max-width: 1160px;
      margin: -2.75rem auto 4rem;
      padding: 0 1.5rem 4rem;
    }
    section {
      background: #fff;
      margin: 2rem 0;
      padding: 2.5rem 2.25rem;
      border-radius: 20px;
      box-shadow: 0 26px 60px rgba(18, 58, 99, 0.12);
      position: relative;
      overflow: hidden;
    }
    section::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(145deg, rgba(12, 141, 217, 0.05), transparent 60%);
      pointer-events: none;
    }
    h2 {
      margin: 0 0 1.75rem;
      padding-left: 0.85rem;
      border-left: 5px solid var(--azul);
      color: var(--azul-escuro);
      font-size: 1.75rem;
    }
    h3 {
      margin-top: 1.75rem;
      color: var(--cinza);
      font-size: 1.25rem;
    }
    p {
      margin: 0 0 1rem;
    }
    ol, ul {
      margin: 0 0 1.35rem 1.25rem;
    }
    li {
      margin-bottom: 0.45rem;
    }
    strong.badge {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      font-size: 0.85rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      background: rgba(12, 141, 217, 0.14);
      color: var(--azul-escuro);
      border-radius: 999px;
      padding: 0.35rem 0.9rem;
    }
    .grid-3 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.25rem;
      margin-top: 1.5rem;
    }
    .card {
      border-radius: 16px;
      border: 1px solid #d7e5f7;
      background: #fafdff;
      padding: 1.4rem 1.3rem 1.15rem;
      position: relative;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 18px 40px rgba(12, 141, 217, 0.18);
    }
    .card h3 {
      margin-top: 0;
      font-size: 1.2rem;
    }
    .checklist {
      display: grid;
      gap: 0.85rem;
      margin-top: 1.5rem;
    }
    .checklist label {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.75rem;
      align-items: start;
      padding: 1rem 1rem 1rem 1.25rem;
      border-radius: 12px;
      background: #f7fbff;
      border: 1px solid #dce9f9;
    }
    .checklist input[type="checkbox"] {
      width: 1.15rem;
      height: 1.15rem;
      margin-top: 0.35rem;
    }
    .interactive-panel {
      background: var(--azul-escuro);
      color: #fff;
      border-radius: 18px;
      padding: 1.75rem;
      display: grid;
      gap: 1rem;
      position: relative;
      overflow: hidden;
    }
    .interactive-panel::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.22), transparent 58%);
      pointer-events: none;
    }
    .interactive-panel label {
      font-weight: 600;
    }
    .interactive-panel select,
    .interactive-panel button {
      border-radius: 10px;
      border: none;
      padding: 0.7rem 0.85rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .interactive-panel select {
      background: #fff;
      color: var(--azul-escuro);
    }
    .interactive-panel button {
      background: linear-gradient(135deg, var(--azul), #0b6ac1);
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s ease, filter 0.2s ease;
    }
    .interactive-panel button:hover {
      transform: translateY(-1px);
      filter: brightness(1.06);
    }
    .interactive-output {
      background: rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      padding: 1.35rem;
      line-height: 1.55;
      font-size: 0.98rem;
    }
    details {
      background: #f7fbff;
      border-radius: 14px;
      border: 1px solid #d9e7f8;
      margin-top: 1.25rem;
      padding: 1rem 1.25rem 1.15rem;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--azul-escuro);
    }
    details pre {
      background: #0b2038;
      color: #d9e9ff;
      padding: 1.1rem 1.25rem;
      border-radius: 12px;
      overflow-x: auto;
      margin-top: 1rem;
      font-size: 0.92rem;
      line-height: 1.45;
    }
    .timeline {
      display: grid;
      gap: 1.25rem;
    }
    .timeline-step {
      background: #fafdff;
      border: 1px solid #d6e6f9;
      border-radius: 14px;
      padding: 1.35rem 1.2rem 1.25rem;
      display: grid;
      gap: 0.75rem;
      position: relative;
    }
    .timeline-step strong {
      color: var(--azul-escuro);
    }
    .timeline-step .label {
      position: absolute;
      top: -12px;
      right: 16px;
      background: var(--amarelo);
      color: #fff;
      font-weight: 700;
      border-radius: 999px;
      padding: 0.25rem 0.75rem;
      letter-spacing: 0.02em;
    }
    .callout {
      border-left: 5px solid var(--verde);
      background: #f0f9f4;
      padding: 1.1rem 1.35rem;
      border-radius: 12px;
      margin-top: 1.5rem;
    }
    .warning {
      border-left-color: var(--vermelho);
      background: #fff1f1;
    }
    footer {
      text-align: center;
      padding: 2rem 1rem 4rem;
      color: #60718b;
      font-size: 0.95rem;
    }
    @media (max-width: 720px) {
      section {
        padding: 2.1rem 1.6rem;
      }
      .interactive-panel {
        padding: 1.3rem 1.2rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Guia de Recriação Total do Projeto na Unreal Engine 5</h1>
    <p>
      Este documento interativo indica a ordem ideal para reconstruir o projeto na UE5 reaproveitando assets originais.
      Cada etapa traz instruções práticas, checklist de prontidão, exemplos em Blueprint e pontos de verificação antes de avançar.
    </p>
  </header>
  <main>
    <section id="resumo">
      <h2>Sequência Recomendada de Implementação</h2>
      <p>
        Foque em <strong>importação controlada dos assets</strong>, seguido de uma <strong>base funcional de interface e inventário</strong>,
        antes de expandir para sistemas de progressão, drops, mapas e efeitos. Esta ordem reduz retrabalho e mantém o jogo jogável rapidamente.
      </p>
      <div class="interactive-panel">
        <div>
          <label for="perfil">Selecione seu foco atual:</label>
          <select id="perfil">
            <option value="default">Quero seguir a ordem ideal sugerida</option>
            <option value="asset">Tenho muitos assets convertidos e quero validar se posso usá-los</option>
            <option value="ui">Preciso reconstruir a interface o quanto antes</option>
            <option value="core">Quero priorizar sistemas centrais (itens, XP, drops)</option>
            <option value="maps">Preciso entregar mapas jogáveis rápido</option>
            <option value="vfx">Necessito atualizar efeitos e feedback audiovisual</option>
          </select>
        </div>
        <button type="button" id="verPlano">Ver ordem sugerida</button>
        <div class="interactive-output" id="saidaPlano">
          Selecione um foco e clique em <strong>Ver ordem sugerida</strong> para receber um roteiro imediato.
        </div>
      </div>
      <div class="grid-3" style="margin-top: 2rem;">
        <div class="card">
          <h3><span class="badge">1º</span> Fase de Validação</h3>
          <ul>
            <li>Auditoria de assets originais e conversão para UE5.</li>
            <li>Configuração de projeto, plugins e convenções.</li>
            <li>Protótipo básico de HUD + inventário navegável.</li>
          </ul>
        </div>
        <div class="card">
          <h3><span class="badge">2º</span> Fase Sistêmica</h3>
          <ul>
            <li>Recriação de itens, XP e drops com dados reaproveitados.</li>
            <li>Estruturação de mapas com spawners, colisões e navegação.</li>
            <li>Validação de rede/multiplayer (se aplicável).</li>
          </ul>
        </div>
        <div class="card">
          <h3><span class="badge">3º</span> Fase Sensorial</h3>
          <ul>
            <li>Atualização de efeitos visuais, sonoros e UI final.</li>
            <li>Polimento de performance, LODs, iluminação e pós-processo.</li>
            <li>Testes completos, correções finais e empacotamento.</li>
          </ul>
        </div>
      </div>
      <div class="checklist">
        <label>
          <input type="checkbox" />
          <span><strong>Inventariou todos os assets reutilizáveis</strong> (modelos, animações, sons, UI, dados) e marcou os que precisam de retrabalho.</span>
        </label>
        <label>
          <input type="checkbox" />
          <span><strong>Definiu a meta de FPS/plataformas alvo</strong> para orientar decisões de LOD, textura e iluminação.</span>
        </label>
        <label>
          <input type="checkbox" />
          <span><strong>Configurou controle de versão</strong> (Perforce, Git LFS ou similar) e separou branch para migração.</span>
        </label>
      </div>
    </section>

    <section id="etapas">
      <h2>Etapas Detalhadas e Critérios de Saída</h2>
      <article>
        <h3>Etapa 0 – Preparação e Auditoria</h3>
        <p><strong>Objetivo:</strong> Garantir que o ambiente esteja pronto e todos os assets tenham status definido antes da migração.</p>
        <ul>
          <li>Configurar projeto UE5 (Game Feature Plugins conforme necessidade, Subsystems, Common UI).</li>
          <li>Importar assets de teste para validar pipelines (1 personagem, 1 arma, 1 HUD, 1 mapa pequeno).</li>
          <li>Criar planilha com origem &gt; destino (texturas, materiais, animações, sons, dados CSV/JSON).</li>
          <li>Montar pasta <code>/Game/LegacyImports</code> e subpastas por categoria (Characters, UI, FX...).</li>
          <li>Estabelecer nomeação consistente (prefixos BP_, SK_, UI_, FX_...).</li>
        </ul>
        <div class="callout warning">
          <strong>Atenção:</strong> Se o asset exigir conversão (por exemplo, materiais antigos), documente o esforço estimado antes de prosseguir para evitar gargalos no meio da recriação dos sistemas.
        </div>
      </article>
      <article>
        <h3>Etapa 1 – Núcleo Jogável (HUD + Inventário)</h3>
        <p><strong>Objetivo:</strong> Viabilizar uma experiência jogável mínima com interface responsiva.</p>
        <ol>
          <li><strong>HUD Modular:</strong> converter elementos UI legados em Widgets UMG separados (barra de vida, mana, XP, minimapa).</li>
          <li><strong>Inventário Base:</strong> criar <em>Data Assets</em> ou tabelas de dados com itens originais; gerar Blueprint <code>BP_InventoryManager</code>.</li>
          <li><strong>Input/UI:</strong> utilizar Enhanced Input + Common UI para navegação com teclado/mouse e controle.</li>
          <li><strong>Persistência:</strong> estruturar salvamento temporário em <code>UGameInstance</code> ou <code>USaveGame</code>.</li>
          <li><strong>Verificação:</strong> jogador consegue abrir HUD, equipar, consumir item e ver feedback visual.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Build jogável onde é possível iniciar partida, visualizar HUD completo e manipular inventário sem falhas.
        </div>
      </article>
      <article>
        <h3>Etapa 2 – Sistemas de Progressão (Itens, XP, Drops)</h3>
        <p><strong>Objetivo:</strong> Reimplementar lógica central reaproveitando dados e comportamento já existente.</p>
        <ol>
          <li><strong>Itens:</strong> Criar <code>BP_ItemBase</code> com metadados (tipo, raridade, efeitos). Importar ícones existentes.</li>
          <li><strong>XP/Nível:</strong> Montar curva de XP (<code>CurveFloat</code>) ou tabela. Implementar <code>BP_ProgressionComponent</code>.</li>
          <li><strong>Drops:</strong> Configurar <code>Data Table</code> com tabelas de loot legadas e componente <code>BP_LootSpawner</code>.</li>
          <li><strong>Balanceamento:</strong> Criar mapa de teste com inimigos representativos e ajustar probabilidades.</li>
          <li><strong>Economia:</strong> Validar integração com moeda/loja se aplicável.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Inimigos derrotados dropam itens corretos, XP sobe conforme curva e jogador atinge nível alvo sem inconsistências.
        </div>
      </article>
      <article>
        <h3>Etapa 3 – Mapas e Conteúdo Jogável</h3>
        <p><strong>Objetivo:</strong> Migrar mapas mantendo navegação, colisões e atmosferas originais.</p>
        <ol>
          <li><strong>Layout:</strong> Usar Level Partitioning/World Composition para mapas extensos. Importar malhas estáticas e colisões personalizadas.</li>
          <li><strong>Navegação:</strong> Regerar NavMesh, volumes de bloqueio, triggers e volumes de respawn.</li>
          <li><strong>Streaming:</strong> Configurar <code>World Partition</code> ou subníveis para iluminação e som.</li>
          <li><strong>Scripts:</strong> Migrar lógica de missões/eventos para <code>Level Blueprint</code> ou <code>Actor Components</code>.</li>
          <li><strong>Testes:</strong> Percorrer cada mapa verificando colisão, iluminação e performance.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Todos os mapas carregam em 30s, sem luzes quebradas, sem buracos de colisão e com triggers funcionais.
        </div>
      </article>
      <article>
        <h3>Etapa 4 – Efeitos, Áudio e Polimento</h3>
        <p><strong>Objetivo:</strong> Restaurar feedback audiovisual e preparar build final.</p>
        <ol>
          <li><strong>VFX:</strong> Atualizar partículas no Niagara reaproveitando texturas/meshes antigos.</li>
          <li><strong>SFX:</strong> Conectar trilhas e sons via <code>MetaSounds</code> ou Sound Cues.</li>
          <li><strong>Iluminação:</strong> Ajustar Lumen, pós-processo e exposição. Validar escalas de lightmaps.</li>
          <li><strong>Performance:</strong> Verificar <em>GPU Visualizer</em>, profiler e ativar LODs/streaming.</li>
          <li><strong>Entrega:</strong> Empacotar build, rodar smoke tests e criar checklist final.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Build final com áudio/visual coerentes, rodando estável dentro das metas de performance definidas na preparação.
        </div>
      </article>
    </section>

    <section id="blueprints">
      <h2>Exemplos Práticos em Blueprint</h2>
      <p>Use os snippets abaixo como base para recriar a lógica principal em Blueprints reaproveitando assets existentes.</p>
      <details open>
        <summary>HUD Dinâmico e Inventário (Widget Blueprint)</summary>
        <ol>
          <li>Criar <code>WBP_HUD</code> contendo componentes de barra de vida/mana (Progress Bar) e painel de inventário (Uniform Grid).</li>
          <li>Associar <code>BP_InventoryManager</code> ao Player Controller e expor eventos <em>OnInventoryChanged</em>.</li>
          <li>No Event Graph do widget, reagir ao evento para atualizar ícones reaproveitados.</li>
        </ol>
        <pre><code>Event Construct
  → Get Player Controller → Cast to BP_PlayerController
  → Bind Event to InventoryManager.OnInventoryChanged

Custom Event OnInventoryChanged (Itens)
  → Clear Children (GridInventario)
  → ForEach Itens:
      Create Widget (WBP_ItemSlot)
      SetData (ItemID, IconeTextura, Quantidade)
      Add Child to Grid (coluna = Index % 6, linha = Index / 6)</code></pre>
      </details>
      <details>
        <summary>Sistema de Itens com Data Table</summary>
        <ol>
          <li>Criar <code>DT_Items</code> (Data Table) baseado em struct <code>FItemStats</code> contendo Nome, Tipo, Raridade, Mesh, Icone, Efeito.</li>
          <li>No <code>BP_ItemBase</code>, adicionar variável <code>ItemRowName</code> e carregar dados na construção.</li>
          <li>Expor função <code>ApplyEffect</code> para uso por consumíveis ou equipamentos.</li>
        </ol>
        <pre><code>Event OnConstruct (BP_ItemBase)
  → Get Data Table Row (DT_Items, ItemRowName)
  → Set DisplayName, Icon, Mesh, Stats

Function ApplyEffect (Alvo)
  Switch on ItemType
    Consumivel → Alvo.ApplyHealth(Stats.HealAmount)
    Equipamento → Alvo.EquiparSlot(Stats.Slot, self)
    Gema → Alvo.AtribuirBuff(Stats.BuffID, Stats.Duration)</code></pre>
      </details>
      <details>
        <summary>XP e Level Up Automatizado</summary>
        <ol>
          <li>Criar componente <code>BP_ProgressionComponent</code> com variáveis <code>CurrentXP</code>, <code>CurrentLevel</code>, <code>XPTable</code>.</li>
          <li>Adicionar função <code>AddExperience</code> chamada por inimigos ao morrer.</li>
          <li>Disparar evento <code>OnLevelUp</code> que atualiza HUD e atributos do personagem.</li>
        </ol>
        <pre><code>Function AddExperience (Amount)
  CurrentXP += Amount
  while CurrentXP ≥ XPTable[CurrentLevel]
    CurrentXP -= XPTable[CurrentLevel]
    CurrentLevel += 1
    OnLevelUp.Broadcast(CurrentLevel)

Event OnLevelUp
  → PlayerStatsComponent.IncrementarAtributos(CurrentLevel)
  → HUDWidget.PlayAnimation(LevelUpAnim)
  → Spawn Niagara (FX_LevelUp) na localização do jogador</code></pre>
      </details>
      <details>
        <summary>Drop de Loot Dinâmico</summary>
        <ol>
          <li><code>BP_LootSpawner</code> recebe tabela <code>DT_LootTable</code> herdada do jogo original.</li>
          <li>Ao destruir inimigo, chamar <code>SpawnLoot</code> informando <em>LootContext</em> (região, dificuldade).</li>
          <li>Gerar item físico com mesh/partícula reutilizada.</li>
        </ol>
        <pre><code>Function SpawnLoot (LootContext)
  EntradasVálidas ← Filtrar DT_LootTable por Região &amp; Raridade
  Sorteio ← Random Weighted Selection (DropRate)
  SpawnActor BP_ItemPickup at GetActorLocation()
  ItemPickup.SetItemID(Sorteio.ItemID)
  ItemPickup.PlayNiagara(FX_Drop, Cor = Sorteio.RaridadeCor)
  ItemPickup.Bind OnCollected → Inventario.AddItem(ItemID)</code></pre>
      </details>
      <details>
        <summary>Carregamento de Mapas com Subníveis</summary>
        <ol>
          <li>Converter mapas grandes para <code>World Partition</code> e criar <em>Data Layers</em> para iluminação, efeitos e gameplay.</li>
          <li>Usar <code>BP_MapManager</code> para carregar subníveis com base na proximidade do jogador.</li>
          <li>Controlar música ambiente e sons locais via <code>Audio Volumes</code>.</li>
        </ol>
        <pre><code>Event BeginPlay (BP_MapManager)
  → Set Data Layer State (Exploração, Loaded)
  → Load Stream Level (Dungeon_Entrada)

Event OnPlayerReachedPortal
  → Load Stream Level (Dungeon_Boss)
  → Set Data Layer State (Exploração, Unloaded)
  → Set Data Layer State (BossFight, Loaded)
  → AudioManager.PlayCue(MusicaBoss)</code></pre>
      </details>
      <details>
        <summary>Efeitos Visuais Atualizados no Niagara</summary>
        <ol>
          <li>Importar texturas de partículas legadas para o Niagara e criar <code>NS_SpellImpact</code>.</li>
          <li>Expor parâmetros de cor e escala para refletir raridade do item/skill.</li>
          <li>Chamar efeito via <code>GameplayCue</code> ou diretamente nos Blueprints de habilidade.</li>
        </ol>
        <pre><code>Function PlayImpactFX (Contexto)
  NiagaraComponent.SetVariableLinearColor("Color", Contexto.RaridadeCor)
  NiagaraComponent.SetVariableFloat("Scale", Contexto.Escala)
  NiagaraComponent.Activate()
  AudioComponent.Play()
  CameraShake.Play(Contexto.ShakeClass)</code></pre>
      </details>
    </section>

    <section id="verificacoes">
      <h2>Painel de Decisão Rápida</h2>
      <div class="timeline">
        <div class="timeline-step">
          <span class="label">Início</span>
          <strong>Importo todos os assets agora?</strong>
          <p>Somente após classificar como <em>Pronto</em>, <em>Precisa Ajustes</em> ou <em>Substituir</em>. Caso contrário, importe um lote pequeno para validar materiais e colisões.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Depois do HUD</span>
          <strong>Recrio a interface antes dos sistemas?</strong>
          <p>Sim. Com HUD + Inventário prontos, você valida feedback instantâneo e detecta falta de dados herdados.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Progresso</span>
          <strong>XP ou Itens primeiro?</strong>
          <p>Inicie pelos itens. XP depende de recompensas, então garanta que o inventário suporte equipar/consumir para depois ajustar a progressão.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Conteúdo</span>
          <strong>Mapas ou Drops antes?</strong>
          <p>Mapas. Estruture navegação e colisões; em seguida distribua inimigos e configure drops conforme layout final.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Final</span>
          <strong>Efeitos visuais no fim?</strong>
          <p>Sim. Após sistemas estáveis, aplique Niagara, som e pós-processo com base no gameplay consolidado.</p>
        </div>
      </div>
      <div class="callout" style="margin-top: 1.75rem;">
        <strong>Dica:</strong> Revise o painel após cada etapa. Se houver bloqueio por falta de asset convertido, mova temporariamente para um placeholder marcado com <em>debug material</em> e siga com a lógica.
      </div>
    </section>

    <section id="cronograma">
      <h2>Cronograma Sugerido (12 Semanas)</h2>
      <div class="timeline">
        <div class="timeline-step">
          <span class="label">Semanas 1–2</span>
          <strong>Auditoria &amp; Setup</strong>
          <ul>
            <li>Converter lote piloto de assets e validar materiais.</li>
            <li>Configurar controle de versão e documentação.</li>
            <li>Definir curvas de XP, lista de itens e mapas prioritários.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 3–5</span>
          <strong>HUD, Inventário e Dados</strong>
          <ul>
            <li>Recriar HUD completo e fluxo de inventário.</li>
            <li>Integrar dados de itens e efeitos básicos.</li>
            <li>Testar persistência e replicação (se multiplayer).</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 6–8</span>
          <strong>Progressão &amp; Loot</strong>
          <ul>
            <li>Implementar XP, níveis, habilidades destraváveis.</li>
            <li>Configurar drops por região e chefes.</li>
            <li>Balancear economia e recompensas.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 9–10</span>
          <strong>Mapas e Conteúdo</strong>
          <ul>
            <li>Migrar mapas restantes com colisão e navegação.</li>
            <li>Adicionar eventos, missões e spawners.</li>
            <li>Testes de performance e correções estruturais.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 11–12</span>
          <strong>Polimento Final</strong>
          <ul>
            <li>Atualizar VFX, trilhas e voice overs.</li>
            <li>QA completo, bug bash e checklist de build.</li>
            <li>Preparar material de entrega e documentação final.</li>
          </ul>
        </div>
      </div>
    </section>
  </main>
  <footer>
    Atualize este guia conforme novas descobertas na migração. Marque o progresso no checklist e use os exemplos de Blueprint como base para acelerar as próximas etapas.
  </footer>
  <script>
    const stageContent = {
      default: {
        titulo: "Ordem ideal sugerida",
        passos: [
          "Finalize auditoria e importação de um lote piloto de assets.",
          "Protótipo completo de HUD + inventário utilizando dados originais.",
          "Implemente itens, XP e drops com Data Tables reaproveitadas.",
          "Migre mapas, spawners e triggers para UE5 com World Partition.",
          "Ajuste efeitos, áudio e iluminação, encerrando com testes finais."
        ]
      },
      asset: {
        titulo: "Quando há muitos assets convertidos",
        passos: [
          "Priorize planilha de estado dos assets e importe somente os aprovados.",
          "Crie um mapa de revisão (Asset Playground) para testar materiais/LODs.",
          "Depois conecte HUD + inventário usando os ícones e meshes já convertidos.",
          "Mantenha assets incompletos marcados como placeholders até a Etapa 4."
        ]
      },
      ui: {
        titulo: "Foco em interface",
        passos: [
          "Migre fontes, ícones e animações UI para UMG.",
          "Implemente HUD modular usando Common UI e reutilizando widgets originais.",
          "Conecte inventário e barras de status aos dados herdados.",
          "Só avance para XP/drops quando HUD responder a todos eventos principais."
        ]
      },
      core: {
        titulo: "Foco em sistemas centrais",
        passos: [
          "Garanta que Data Tables de itens, XP e drops estejam convertidas.",
          "Crie componentes Blueprints (Inventory, Progression, LootSpawner).",
          "Monte mapa de combate de teste para balancear valores reutilizados.",
          "Integre com HUD existente antes de distribuir para mapas completos."
        ]
      },
      maps: {
        titulo: "Entrega rápida de mapas",
        passos: [
          "Importe blocos estruturais (terreno, malhas principais) primeiro.",
          "Configure World Partition e volumes de navegação.",
          "Reaplique iluminação/pós-processo original e valide colisões.",
          "Após mapas estáveis, posicione inimigos e conecte drops e eventos."
        ]
      },
      vfx: {
        titulo: "Foco em efeitos e audiovisual",
        passos: [
          "Organize texturas de partículas e sons legados em pastas Niagara/Audio.",
          "Atualize efeitos críticos (habilidades, feedback de dano) usando Niagara.",
          "Integre MetaSounds para música adaptativa com dados reutilizados.",
          "Finalize com pós-processo e passes de iluminação após mapas prontos."
        ]
      }
    };

    const select = document.getElementById("perfil");
    const output = document.getElementById("saidaPlano");
    document.getElementById("verPlano").addEventListener("click", () => {
      const escolha = stageContent[select.value] || stageContent.default;
      output.innerHTML = `<strong>${escolha.titulo}</strong><ol style="margin-top:0.85rem;">${escolha.passos
        .map((passo) => `<li>${passo}</li>`)
        .join("")}</ol>`;
    });
  </script>
</body>
</html>
