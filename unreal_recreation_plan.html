<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Plano de Recriação do Projeto na Unreal Engine 5</title>
  <style>
    :root {
      color-scheme: light;
    }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 0;
      background-color: #eef3fb;
      color: #222;
    }
    header {
      background: linear-gradient(135deg, #1d3c6a, #0b9ed8);
      color: #fff;
      padding: 2.5rem 2rem;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    header::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(255, 255, 255, 0.25), transparent 55%);
      pointer-events: none;
    }
    main {
      max-width: 1024px;
      margin: 2rem auto 4rem;
      background-color: #fff;
      padding: 2.5rem;
      border-radius: 18px;
      box-shadow: 0 25px 60px rgba(17, 53, 99, 0.12);
      position: relative;
    }
    h1 {
      margin-top: 0;
      font-size: 2.65rem;
    }
    h2 {
      border-left: 4px solid #0b9ed8;
      padding-left: 0.75rem;
      margin-top: 2.7rem;
      color: #0b3c6a;
    }
    h3 {
      margin-top: 1.5rem;
      color: #145581;
    }
    p {
      margin-bottom: 1rem;
    }
    ul {
      padding-left: 1.5rem;
      margin-bottom: 1.5rem;
    }
    li {
      margin-bottom: 0.5rem;
    }
    .timeline {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
    }
    .card {
      border: 1px solid #d7e3f4;
      border-radius: 12px;
      padding: 1.5rem;
      background-color: #fafdff;
      transition: transform 0.25s ease, box-shadow 0.25s ease;
    }
    .card h3 {
      margin-top: 0;
    }
    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 30px rgba(20, 86, 129, 0.18);
    }
    .callout {
      border-left: 4px solid #f39c12;
      background-color: #fff7e6;
      padding: 1rem 1.25rem;
      border-radius: 8px;
      margin: 1.5rem 0;
    }
    .priority-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1.25rem;
      margin-top: 1.5rem;
    }
    .priority-card {
      background: linear-gradient(145deg, #ffffff, #f1f7ff);
      border: 1px solid #d7e3f4;
      border-radius: 12px;
      padding: 1.25rem;
      position: relative;
      box-shadow: 0 15px 35px rgba(11, 62, 106, 0.08);
      transition: transform 0.2s ease;
    }
    .priority-card.active {
      border-color: #0b9ed8;
      box-shadow: 0 18px 40px rgba(11, 158, 216, 0.24);
      transform: translateY(-4px);
    }
    .priority-card h3 {
      margin-top: 0;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .priority-card h3 span {
      background-color: #0b9ed8;
      color: #fff;
      border-radius: 999px;
      padding: 0.2rem 0.6rem;
      font-size: 0.85rem;
    }
    .interactive-panel {
      background-color: #0b3c6a;
      color: #fff;
      border-radius: 14px;
      padding: 1.5rem;
      margin: 1.5rem 0 0;
      display: grid;
      gap: 1rem;
    }
    .interactive-panel label {
      font-weight: 600;
    }
    .interactive-panel select,
    .interactive-panel button {
      border-radius: 8px;
      border: none;
      padding: 0.65rem 0.75rem;
      font-size: 1rem;
    }
    .interactive-panel select {
      background-color: #fff;
      color: #0b3c6a;
    }
    .interactive-panel button {
      background: linear-gradient(135deg, #12b5f1, #0b89d8);
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s ease, filter 0.2s ease;
    }
    .interactive-panel button:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
    }
    details {
      background-color: #f4f8ff;
      border-radius: 10px;
      padding: 1rem 1.25rem;
      margin: 1.25rem 0;
      border: 1px solid #d7e3f4;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: #0b3c6a;
    }
    details pre {
      background-color: #0b1f36;
      color: #f5f8ff;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.9rem;
      line-height: 1.4;
    }
    .system-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
    }
    .system-card {
      background-color: #ffffff;
      border-radius: 12px;
      border: 1px solid #d7e3f4;
      padding: 1.5rem;
      box-shadow: 0 12px 30px rgba(15, 63, 109, 0.08);
      transition: transform 0.2s ease;
    }
    .system-card:hover {
      transform: translateY(-3px);
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background-color: #0b9ed8;
      color: #fff;
      border-radius: 999px;
      padding: 0.2rem 0.75rem;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .blueprint-steps {
      margin-top: 1rem;
      border-top: 1px dashed #b6cdea;
      padding-top: 1rem;
      font-size: 0.95rem;
    }
    .flow-diagram {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 1rem;
    }
    .flow-node {
      background-color: #0b9ed8;
      color: #fff;
      padding: 0.6rem 0.85rem;
      border-radius: 999px;
      font-size: 0.85rem;
      box-shadow: 0 8px 22px rgba(11, 158, 216, 0.22);
    }
    footer {
      margin-top: 3rem;
      padding: 2rem 0;
      text-align: center;
      color: #555;
    }
    @media (max-width: 768px) {
      header,
      main {
        padding: 1.75rem;
      }
      h1 {
        font-size: 2.1rem;
      }
    }
    @media (max-width: 600px) {
      .interactive-panel {
        padding: 1.25rem;
      }
      .flow-diagram {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Plano Interativo para Recriar o Projeto na Unreal Engine 5</h1>
    <p>Descubra a ordem ideal de implementação, reutilize assets com segurança e consulte exemplos práticos em Blueprint.</p>
  </header>

  <main>
    <section id="decision">
      <h2>0. Navegador de Prioridades Iniciais</h2>
      <p>
        Para decidir se você começa importando assets, recriando a interface ou reconstruindo sistemas de jogo, use o guia
        interativo abaixo. Ele calcula a sequência com base no estado atual da sua equipe e na quantidade de assets prontos.
      </p>
      <div class="priority-grid">
        <article class="priority-card active" data-step="assets">
          <h3><span>1º</span>Pipeline de Assets Essenciais</h3>
          <p>Valide formatos, converta lotes críticos e importe apenas o necessário para prototipagem.</p>
        </article>
        <article class="priority-card" data-step="interface">
          <h3><span>2º</span>HUD e UX Nuclear</h3>
          <p>Monte a interface mínima (HUD + menus) alinhada aos dados que serão exibidos no protótipo.</p>
        </article>
        <article class="priority-card" data-step="inventory">
          <h3><span>3º</span>Sistema de Itens/Inventário</h3>
          <p>Garanta estruturas e funções para manipular ícones, meshes e atributos reaproveitados.</p>
        </article>
        <article class="priority-card" data-step="xp">
          <h3><span>4º</span>Progressão e XP</h3>
          <p>Sincronize tabelas de XP com o inventário para validar recompensas e balanceamento inicial.</p>
        </article>
        <article class="priority-card" data-step="drop">
          <h3><span>5º</span>Sistema de Drop/Loot</h3>
          <p>Conecte drops à progressão e aproveite tabelas herdadas para validar economia.</p>
        </article>
        <article class="priority-card" data-step="mapas">
          <h3><span>6º</span>Mapas e Navegação</h3>
          <p>Finalize blocagens e substitua proxies por assets aprovados, integrando colisões e iluminação.</p>
        </article>
        <article class="priority-card" data-step="efeitos">
          <h3><span>7º</span>Efeitos Visuais e Sonoros</h3>
          <p>Refine feedback com Niagara/Sound Cues após confirmar jogabilidade e economia.</p>
        </article>
      </div>
      <div class="interactive-panel">
        <label for="profileSelector">Como está o estado atual do seu projeto?</label>
        <select id="profileSelector">
          <option value="default">Tenho assets convertidos parcialmente e preciso de um plano geral.</option>
          <option value="assets-prontos">A maioria dos assets já está pronta para uso.</option>
          <option value="sem-assets">Quase nenhum asset está validado, precisamos decidir o que priorizar.</option>
          <option value="multiplayer">Tenho dependências fortes de multiplayer/servidor logo no início.</option>
        </select>
        <button id="suggestSequence">Gerar sequência recomendada</button>
        <div id="recommendationOutput"></div>
      </div>
    </section>

    <section>
      <h2>1. Preparação Inicial</h2>
      <p>Antes de abrir a Unreal Engine, organize os recursos existentes, valide o que pode ser reaproveitado e estabeleça o escopo da recriação.</p>
      <ul>
        <li><strong>Análise do projeto original:</strong> documente funcionalidades, sistemas principais, assets utilizados, dependências externas e requisitos técnicos de cada elemento.</li>
        <li><strong>Inventário e classificação de recursos:</strong> identifique modelos 3D, texturas, sons, animações, documentos de design e códigos de referência, registrando origem, formato, qualidade e estado (pronto para uso, precisa de ajustes, obsoleto).</li>
        <li><strong>Avaliação legal e de licenciamento:</strong> confirme direitos de uso dos assets originais e registre eventuais limitações para ports ou remasterizações.</li>
        <li><strong>Definição de metas:</strong> estabeleça objetivos claros para a primeira versão jogável (MVP) e funcionalidades avançadas, apontando quais assets herdados farão parte de cada marco.</li>
        <li><strong>Configuração de ferramentas:</strong> instale Unreal Engine 5, Visual Studio/VS Code, sistemas de controle de versão, DCCs (3ds Max, Maya, Blender) e pipelines de conversão (por exemplo, scripts Python para FBX/GLTF, Adobe Substance para texturas).</li>
      </ul>
    </section>

    <section>
      <h2>2. Configuração do Projeto UE5</h2>
      <p>Crie a base do projeto em Unreal alinhada às metas estabelecidas e prepare os diretórios para receber assets reutilizados.</p>
      <ul>
        <li>Inicie um novo projeto adequado ao gênero (por exemplo, Third Person ou First Person) e configure a estrutura de diretórios com pastas separadas para <em>Original</em> (assets intactos), <em>Rework</em> (assets convertidos) e <em>New</em> (conteúdo inédito).</li>
        <li>Implemente convenções de nomenclatura, organização de arquivos e padrões de blueprint/C++ que indiquem a origem dos assets (prefixos como <code>OR_</code>, <code>RW_</code>).</li>
        <li>Crie sistemas de build e automação de testes incluindo validações de assets (por exemplo, scripts que verificam colisões, LODs, tamanho de texturas).</li>
        <li>Configure plugins essenciais (por exemplo, Enhanced Input, GAS, Niagara) e verifique compatibilidades com assets antigos, ajustando configurações de Nanite, Lumen e física.</li>
      </ul>
    </section>

    <section>
      <h2>3. Estratégia de Reaproveitamento de Assets</h2>
      <p>Garanta um fluxo claro para importar, adaptar e validar assets herdados antes de integrá-los às fases seguintes.</p>
      <ul>
        <li><strong>Mapeamento técnico:</strong> relacione cada asset original às necessidades atuais (por exemplo, quais materiais precisam ser convertidos para PBR, quais animações exigem retargeting com IK Retargeter).</li>
        <li><strong>Pipeline de conversão:</strong> estabeleça passos para padronizar unidades, pivôs, colisões e canais UV; defina presets para exportação FBX/OBJ e automações para recriar materiais no UE5.</li>
        <li><strong>Revisão de qualidade:</strong> priorize assets que já atingem o padrão desejado e liste aqueles que precisam de upscale (textures em 4K), reiluminação para Lumen ou reconstrução em Nanite.</li>
        <li><strong>Integração incremental:</strong> importe assets por lotes (cenários, personagens, props) e valide em níveis de teste antes de levá-los aos mapas finais.</li>
        <li><strong>Documentação contínua:</strong> mantenha planilhas ou boards indicando status de cada asset (importado, ajustado, aprovado) e responsáveis.</li>
      </ul>
      <details>
        <summary>Blueprint: Validação rápida de assets importados</summary>
        <pre>
Event BeginPlay
→ For Each Loop (Array: AssetsPendentes)
  → Async Load Asset
    → Branch (IsValid)
      → True: Add to Array (AssetsValidados)
      → False: Add to Array (AssetsErro)
→ Sequence
  → Print String ("Assets válidos: " + Length(AssetsValidados))
  → Open Level ("Map_Test_Lote") se todos os assets críticos estiverem ok
        </pre>
        <p class="blueprint-steps">
          Use um <em>Primary Data Asset</em> ou <em>Data Table</em> para listar assets reaproveitados. Esta rotina permite testar lotes no editor antes de mover para mapas finais.
        </p>
      </details>
    </section>

    <section>
      <h2>4. Estrutura Fundamental do Jogo</h2>
      <div class="timeline">
        <article class="card">
          <h3>4.1 Arquitetura do Código</h3>
          <ul>
            <li>Implemente GameMode, GameState, PlayerController e HUD básicos.</li>
            <li>Crie um módulo central para gerenciar dependências e subsistemas.</li>
            <li>Defina interfaces e eventos para comunicação entre sistemas.</li>
          </ul>
        </article>
        <article class="card">
          <h3>4.2 Personagens e Controles</h3>
          <ul>
            <li>Configure o personagem jogável com movimentação, câmera e input mapeados, reaproveitando malhas, esqueletos e animações convertidas.</li>
            <li>Implemente sistemas de animação (State Machines, Blend Spaces) e realize retargeting das animações legadas para o esqueleto padrão do UE5/MetaHuman conforme necessário.</li>
            <li>Adapte habilidades principais do projeto original, reutilizando efeitos visuais/sonoros que foram validados na etapa de conversão.</li>
          </ul>
        </article>
        <article class="card">
          <h3>4.3 Ambientes e Níveis</h3>
          <ul>
            <li>Recrie o layout dos mapas usando blocagem (whiteboxing) para validar escala e fluxo, apontando quais módulos/modulares originais serão reaproveitados em cada área.</li>
            <li>Adicione iluminação, efeitos atmosféricos e post-processing considerando o impacto de materiais antigos em Lumen e Reflexões em Tempo Real.</li>
            <li>Integre assets definitivos, substituindo gradualmente proxies por versões reaproveitadas, e otimize colisões/LODs herdados.</li>
          </ul>
          <details>
            <summary>Blueprint: Carregamento dinâmico de módulos herdados</summary>
            <pre>
Event BeginPlay (Level Blueprint)
→ For Each Loop (Array: MódulosAprovados)
  → Load Stream Level (Level Name, Make Transform baseado em Data Table)
→ Event On Level Loaded
  → Reapply Nanite Settings → Atualizar Instâncias Hierárquicas
            </pre>
            <p class="blueprint-steps">Organize módulos legados em subníveis e use <strong>World Partition</strong> para ativá-los conforme proximidade do jogador.</p>
          </details>
        </article>
      </div>
      <div class="flow-diagram">
        <div class="flow-node">GameMode + GameState</div>
        <div class="flow-node">PlayerController + Input</div>
        <div class="flow-node">HUD Básico</div>
        <div class="flow-node">Inventário &amp; Dados</div>
        <div class="flow-node">Progressão/XP</div>
        <div class="flow-node">Drops &amp; Loot</div>
        <div class="flow-node">Efeitos &amp; Polimento</div>
      </div>
    </section>

    <section>
      <h2>5. Sistemas de Jogo</h2>
      <p>Reconstrua sistemas principais conforme documentado na análise inicial.</p>
      <div class="system-grid">
        <article class="system-card" id="sistema-interface">
          <div class="tag">Interface Primeiro?</div>
          <h3>5.1 HUD e Interface Base</h3>
          <ul>
            <li>Comece importando fontes, ícones e sprites críticos. Ajuste materiais de UI para <em>Retainer Boxes</em> e <em>UMG</em>.</li>
            <li>Implemente um HUD mínimo: barras de vida, mana e slots rápidos vinculados a <code>Data Assets</code> já convertidos.</li>
            <li>Crie widgets de depuração (painel de log, inventário temporário) para validar dados antes do design final.</li>
          </ul>
          <details>
            <summary>Blueprint: Widget principal reutilizando assets</summary>
            <pre>
Event Construct (Widget HUD)
→ Get Player State → Get Component (Inventory Component)
→ Bind OnInventoryUpdated → Atualiza Grid
→ Set Brush From Texture (Ícones reaproveitados)

Função Atualiza Grid
→ Clear Children (Uniform Grid Panel)
→ For Each Item Data (Array de DataTable)
  → Create Widget (SlotItem_BP)
  → SetData (ItemID, Ícone, Raridade)
  → Add Child To Uniform Grid (Row, Column calculados)
            </pre>
          </details>
        </article>
        <article class="system-card" id="sistema-inventario">
          <div class="tag">Inventário Central</div>
          <h3>5.2 Inventário e Itens</h3>
          <ul>
            <li>Modele <code>Structs</code> com atributos herdados (ID, Classe, Mesh, Efeitos). Use <em>Primary Data Assets</em> para cada categoria.</li>
            <li>Implemente drag-and-drop com <em>UMG</em>, reaproveitando cursores e sons antigos.</li>
            <li>Sincronize com componentes de personagem (equipar, aplicar bônus) garantindo que IDs antigos sejam preservados.</li>
          </ul>
          <details>
            <summary>Blueprint: Função de adicionar item</summary>
            <pre>
Função AddItem(ItemID)
→ Data Table Row → Struct ItemData
→ Branch (Inventário possui espaço?)
    True:
      → Add (Inventário Array, ItemData)
      → Play Sound 2D (SFX_Inventory_Add)
      → Dispatch Event (OnInventoryUpdated)
    False:
      → Add To Pending Queue (Para drops atrasados)
            </pre>
          </details>
        </article>
        <article class="system-card" id="sistema-xp">
          <div class="tag">Progressão</div>
          <h3>5.3 Sistema de XP e Níveis</h3>
          <ul>
            <li>Converta tabelas antigas de XP para <code>Curve Tables</code> ou <code>Data Tables</code>.</li>
            <li>Conecte recompensas de XP a eventos do inventário (equipar item raro concede bônus).</li>
            <li>Sincronize com o HUD para feedback imediato reutilizando partículas simples.</li>
          </ul>
          <details>
            <summary>Blueprint: Cálculo de nível</summary>
            <pre>
Event GainExperience (DeltaXP)
→ CurrentXP += DeltaXP
→ While (CurrentXP ≥ XPParaPróximoNível)
    → CurrentXP -= XPParaPróximoNível
    → Level++
    → XPParaPróximoNível = CurveFloat_XP.GetFloatValue(Level)
    → Multicast Event (OnLevelUp)
            </pre>
          </details>
        </article>
        <article class="system-card" id="sistema-drop">
          <div class="tag">Economia</div>
          <h3>5.4 Sistema de Drop</h3>
          <ul>
            <li>Importe tabelas de loot antigas, convertendo probabilidades para <code>Data Tables</code> com <em>RowHandles</em>.</li>
            <li>Integre com o sistema de XP para alterar probabilidades conforme nível.</li>
            <li>Valide efeitos de drop com ícones reaproveitados antes do polimento final.</li>
          </ul>
          <details>
            <summary>Blueprint: Geração de drop</summary>
            <pre>
Função SpawnLoot(InimigoID)
→ DataTableRowHandle (LootTable)
→ Weighted Random Row
→ Spawn Actor (Pickup_BP) com Mesh e Partícula herdadas
→ Set ItemID (para Inventário)
→ Play Sound at Location (SFX_Drop_Legado)
            </pre>
          </details>
        </article>
        <article class="system-card" id="sistema-map">
          <div class="tag">Exploração</div>
          <h3>5.5 Mapas e Eventos de Mundo</h3>
          <ul>
            <li>Reaproveite blocos modulares validando colisões e níveis de detalhe.</li>
            <li>Use <em>Level Sequences</em> antigos como base para cenas e cutscenes.</li>
            <li>Automatize checagens de luz/som em cada lote importado.</li>
          </ul>
          <details>
            <summary>Blueprint: Checkpoint reutilizando assets</summary>
            <pre>
Event BeginOverlap (Player)
→ Save Game to Slot (CheckpointData)
→ Set Static Mesh (Totem reaproveitado)
→ Play Niagara System (FX_Checkpoint_Legado)
            </pre>
          </details>
        </article>
        <article class="system-card" id="sistema-efeitos">
          <div class="tag">Feedback</div>
          <h3>5.6 Efeitos Visuais e Sonoros</h3>
          <ul>
            <li>Converta partículas Cascade antigas para Niagara usando a ferramenta de migração integrada.</li>
            <li>Adapte materiais de pós-processamento, preservando identidade visual.</li>
            <li>Crie <em>Sound Cues</em> combinando camadas legadas com novas variações para 3D/espacialização.</li>
          </ul>
          <details>
            <summary>Blueprint: Ativação de efeito contextual</summary>
            <pre>
Event OnAbilityActivated
→ Spawn Niagara System Attached (FX_Ability_Legado)
→ Set Niagara Variable (Cor = Raridade do item)
→ Play Sound Cue (SFX_Ability_Legado)
→ Delay (Duração)
→ Deactivate System
            </pre>
          </details>
        </article>
      </div>
    </section>

    <section>
      <h2>6. Suporte a Multijogador (se aplicável)</h2>
      <ul>
        <li>Configure replicação básica para personagens, inventários e habilidades, garantindo que assets reaproveitados (efeitos, animações) tenham versões otimizadas para rede.</li>
        <li>Implemente sincronização de estado (GameState, PlayerState) e testes de latência reaproveitando mensagens e protocolos do servidor original quando viável.</li>
        <li>Crie fluxos de matchmaking, lobby, login e persistência de contas se o projeto original possuir, planejando migração de dados de contas/itens existentes.</li>
        <li>Otimize chamadas de RPC e bandwidth com prioridades e relevância, revendo pacotes de dados legados.</li>
      </ul>
    </section>

    <section>
      <h2>7. Conteúdo Artístico e Áudio</h2>
      <ul>
        <li>Integre modelos 3D reaproveitados ajustando escalas, colisões e materiais para PBR, criando instâncias que preservem a identidade visual original.</li>
        <li>Converta texturas legadas (DXT, TGA, JPG) para formatos otimizados (TIF, PNG, EXR) com mapas adicionais (normal/roughness) quando necessário.</li>
        <li>Configure sistemas de partículas e efeitos visuais (Niagara) importando efeitos antigos como base e migrando emissões Cascade para Niagara.</li>
        <li>Implemente trilha sonora, efeitos de ambiente e mixagem com Sound Cues, remasterizando arquivos originais para 48 kHz e adicionando camadas de espacialização.</li>
        <li>Realize ajustes de performance (LOD, Nanite, Virtual Shadow Maps), revendo assets herdados que possam impactar memória ou draw calls.</li>
      </ul>
    </section>

    <section>
      <h2>8. Testes e Otimização</h2>
      <p>Garanta estabilidade, desempenho e consistência do jogo.</p>
      <ul>
        <li>Defina uma bateria de testes funcionais, de regressão e de performance, incluindo checklists específicos para assets reaproveitados (texturas corrompidas, materiais quebrados, colisões ausentes).</li>
        <li>Use perfis (Unreal Insights, GPU/CPU profiler) para encontrar gargalos causados por assets antigos e atualize-os conforme necessário.</li>
        <li>Otimize blueprints críticos convertendo-os em C++ quando necessário e substituindo scripts legados por implementações modernas.</li>
        <li>Prepare builds automatizadas (CI/CD) para QA e distribuição com validações para garantir que apenas assets aprovados sejam incluídos.</li>
      </ul>
    </section>

    <section>
      <h2>9. Polimento e Publicação</h2>
      <ul>
        <li>Refine UX, efeitos visuais e feedback com base em testes de usuários, mantendo consistência com a estética original quando os assets forem reutilizados.</li>
        <li>Elabore documentação final (manual técnico, guia de jogador, changelog) destacando assets reaproveitados e modificações significativas.</li>
        <li>Prepare marketing assets (trailers, screenshots, descrições) comparando versões antigas e atualizadas para valorizar o reaproveitamento.</li>
        <li>Empacote e distribua a build final para as plataformas-alvo, garantindo que dependências de assets herdados estejam completas.</li>
      </ul>
    </section>

    <section>
      <h2>10. Cronograma Sugerido</h2>
      <div class="timeline">
        <article class="card">
          <h3>Fase 1: 2-3 Semanas</h3>
          <p>Preparação, configuração do projeto, pipeline de conversão de assets e protótipos básicos de personagem, HUD e inventário.</p>
        </article>
        <article class="card">
          <h3>Fase 2: 4-6 Semanas</h3>
          <p>Implementação dos sistemas de jogo (inventário, XP, drops, interface completa), integração incremental de assets reaproveitados e testes de jogabilidade.</p>
        </article>
        <article class="card">
          <h3>Fase 3: 3-4 Semanas</h3>
          <p>Conteúdo artístico, áudio, integração multiplayer (se necessário), finalização dos assets reaproveitados e otimizações.</p>
        </article>
        <article class="card">
          <h3>Fase 4: 2 Semanas</h3>
          <p>Polimento final, QA completo, auditoria dos assets reaproveitados, documentação e empacotamento.</p>
        </article>
      </div>
    </section>

    <section class="callout">
      <h2>Pontos-Chave para o Sucesso</h2>
      <ul>
        <li>Mantenha comunicação clara entre designers, programadores e artistas.</li>
        <li>Registre decisões técnicas e de design para facilitar manutenção.</li>
        <li>Valide funcionalidades iterativamente para evitar retrabalho nas fases finais.</li>
        <li>Monitore constantemente a qualidade dos assets reaproveitados e atualize o plano de conversão conforme feedback da equipe.</li>
      </ul>
    </section>
  </main>

  <script>
    const sequences = {
      default: {
        order: ["assets", "interface", "inventory", "xp", "drop", "mapas", "efeitos"],
        rationale:
          "Comece validando assets essenciais, em seguida monte HUD mínimo para testar inventário, depois conecte XP, drops e mapas antes do polimento audiovisual."
      },
      "assets-prontos": {
        order: ["interface", "inventory", "xp", "drop", "mapas", "assets", "efeitos"],
        rationale:
          "Com assets convertidos, foque em interface e sistemas que consomem esses dados. Deixe apenas revisões de assets e efeitos para o final."
      },
      "sem-assets": {
        order: ["assets", "mapas", "interface", "inventory", "xp", "drop", "efeitos"],
        rationale:
          "Quando poucos assets estão prontos, priorize pipeline e blocagem de mapas com placeholders para descobrir lacunas antes dos sistemas avançados."
      },
      multiplayer: {
        order: ["assets", "inventory", "xp", "drop", "interface", "mapas", "efeitos"],
        rationale:
          "Para jogos online, estabilize assets replicados e sistemas de dados compartilhados (inventário, XP, drops) antes da camada visual."
      }
    };

    const button = document.getElementById("suggestSequence");
    const selector = document.getElementById("profileSelector");
    const cards = document.querySelectorAll(".priority-card");
    const output = document.getElementById("recommendationOutput");

    const highlightCards = (order) => {
      cards.forEach((card) => {
        card.classList.remove("active");
        const stepLabel = card.querySelector("span");
        const index = order.indexOf(card.dataset.step);
        if (index !== -1) {
          stepLabel.textContent = `${index + 1}º`;
        }
      });

      order.forEach((step) => {
        const card = document.querySelector(`.priority-card[data-step="${step}"]`);
        if (card) {
          card.classList.add("active");
        }
      });
    };

    const renderOutput = ({ order, rationale }) => {
      const listItems = order
        .map((step) => {
          const card = document.querySelector(`.priority-card[data-step="${step}"] h3`);
          return `<li>${card ? card.textContent : step}</li>`;
        })
        .join("");
      output.innerHTML = `
        <div style="background: rgba(255,255,255,0.15); padding: 1rem 1.25rem; border-radius: 12px;">
          <h4 style="margin-top: 0;">Sequência sugerida</h4>
          <ol>${listItems}</ol>
          <p style="margin-bottom: 0; font-size: 0.95rem;">${rationale}</p>
        </div>
      `;
    };

    button?.addEventListener("click", () => {
      const profile = sequences[selector.value] ?? sequences.default;
      highlightCards(profile.order);
      renderOutput(profile);
    });

    // Inicializa com sequência padrão
    highlightCards(sequences.default.order);
    renderOutput(sequences.default);
  </script>

  <footer>
    <p>&copy; 2024 Plano Estratégico de Recriação UE5</p>
  </footer>
</body>
</html>
