<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Plano Direcionado para Recriação do Projeto na Unreal Engine 5</title>
  <style>
    :root {
      color-scheme: light;
      --azul-escuro: #123a63;
      --azul: #0c8dd9;
      --azul-claro: #ecf4ff;
      --cinza: #455a74;
      --verde: #35a07e;
      --amarelo: #f6b73c;
      --vermelho: #d9534f;
      --fundo: #f3f6fb;
    }
    * {
      box-sizing: border-box;
    }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.65;
      margin: 0;
      background: var(--fundo);
      color: #1f2a3a;
    }
    header {
      background: linear-gradient(135deg, var(--azul-escuro), var(--azul));
      color: #fff;
      padding: 3rem 1.5rem 2.5rem;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    header::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at top right, rgba(255, 255, 255, 0.28), transparent 55%);
    }
    header h1 {
      margin: 0 auto 0.75rem;
      max-width: 720px;
      font-size: clamp(2.25rem, 2.7vw + 1.1rem, 3.25rem);
    }
    header p {
      margin: 0 auto;
      max-width: 720px;
      font-size: 1.05rem;
      opacity: 0.95;
    }
    main {
      max-width: 1160px;
      margin: -2.75rem auto 4rem;
      padding: 0 1.5rem 4rem;
    }
    section {
      background: #fff;
      margin: 2rem 0;
      padding: 2.5rem 2.25rem;
      border-radius: 20px;
      box-shadow: 0 26px 60px rgba(18, 58, 99, 0.12);
      position: relative;
      overflow: hidden;
    }
    section::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(145deg, rgba(12, 141, 217, 0.05), transparent 60%);
      pointer-events: none;
    }
    h2 {
      margin: 0 0 1.75rem;
      padding-left: 0.85rem;
      border-left: 5px solid var(--azul);
      color: var(--azul-escuro);
      font-size: 1.75rem;
    }
    h3 {
      margin-top: 1.75rem;
      color: var(--cinza);
      font-size: 1.25rem;
    }
    p {
      margin: 0 0 1rem;
    }
    ol, ul {
      margin: 0 0 1.35rem 1.25rem;
    }
    li {
      margin-bottom: 0.45rem;
    }
    strong.badge {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      font-size: 0.85rem;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      background: rgba(12, 141, 217, 0.14);
      color: var(--azul-escuro);
      border-radius: 999px;
      padding: 0.35rem 0.9rem;
    }
    .grid-3 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.25rem;
      margin-top: 1.5rem;
    }
    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-top: 1.5rem;
    }
    .matrix {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      background: rgba(12, 141, 217, 0.04);
      border-radius: 16px;
      overflow: hidden;
    }
    .matrix thead {
      background: rgba(12, 141, 217, 0.18);
    }
    .matrix th,
    .matrix td {
      padding: 0.95rem 1rem;
      text-align: left;
      border-bottom: 1px solid rgba(18, 58, 99, 0.12);
      vertical-align: top;
    }
    .matrix tbody tr:last-child td {
      border-bottom: none;
    }
    .matrix strong {
      color: var(--azul-escuro);
    }
    .badge-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      padding: 0.28rem 0.65rem;
      font-size: 0.75rem;
      background: rgba(53, 160, 126, 0.16);
      border-radius: 999px;
      color: var(--verde);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .callout {
      background: rgba(246, 183, 60, 0.16);
      border-left: 4px solid var(--amarelo);
      padding: 1rem 1.25rem;
      border-radius: 12px;
      margin: 1.35rem 0;
    }
    .callout strong {
      color: var(--azul-escuro);
    }
    details.guia {
      background: rgba(12, 141, 217, 0.06);
      border-radius: 14px;
      padding: 1.1rem 1.25rem;
      margin: 1rem 0;
      border: 1px solid rgba(12, 141, 217, 0.12);
      transition: box-shadow 0.3s ease;
    }
    details.guia[open] {
      box-shadow: 0 18px 40px rgba(18, 58, 99, 0.14);
    }
    details.guia summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--azul-escuro);
      list-style: none;
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }
    details.guia summary::before {
      content: "⮟";
      font-size: 1rem;
      transition: transform 0.3s ease;
    }
    details.guia[open] summary::before {
      transform: rotate(-180deg);
    }
    .blueprint-flow {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1rem;
      margin-top: 1.1rem;
    }
    .blueprint-step {
      background: #fff;
      border-radius: 14px;
      border: 1px solid rgba(18, 58, 99, 0.12);
      padding: 1rem 1.15rem;
      box-shadow: 0 12px 32px rgba(18, 58, 99, 0.08);
    }
    .blueprint-step h4 {
      margin: 0 0 0.6rem;
      color: var(--azul-escuro);
      font-size: 1.05rem;
    }
    .code-card {
      background: #0b1f33;
      color: #e8f1ff;
      border-radius: 12px;
      padding: 1rem 1.1rem;
      margin: 1rem 0;
      font-family: "Fira Code", "Consolas", "Courier New", monospace;
      font-size: 0.87rem;
      line-height: 1.5;
      overflow-x: auto;
    }
    .swimlane {
      display: grid;
      grid-template-columns: 160px 1fr;
      gap: 1rem;
      margin: 1.5rem 0;
    }
    .swimlane strong {
      display: block;
      color: var(--azul-escuro);
      margin-bottom: 0.5rem;
    }
    .swimlane ul {
      margin: 0;
      padding-left: 1.1rem;
    }
    .checklist {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 0.85rem;
      margin-top: 1.35rem;
    }
    .checklist li {
      list-style: none;
      padding: 0.75rem 0.85rem;
      border-radius: 10px;
      background: rgba(18, 58, 99, 0.06);
      border: 1px solid rgba(18, 58, 99, 0.12);
      display: flex;
      align-items: flex-start;
      gap: 0.55rem;
    }
    .checklist li::before {
      content: "✔";
      color: var(--verde);
      font-weight: 700;
    }
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      font-size: 0.85rem;
      margin: 1rem 0 0.3rem;
    }
    .legend span {
      background: rgba(12, 141, 217, 0.12);
      color: var(--azul-escuro);
      padding: 0.35rem 0.7rem;
      border-radius: 999px;
    }
    .atlas-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin: 1.75rem 0 1.5rem;
    }
    .atlas-tab {
      background: rgba(12, 141, 217, 0.14);
      border: 1px solid rgba(12, 141, 217, 0.35);
      color: var(--azul-escuro);
      border-radius: 999px;
      padding: 0.55rem 1.25rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .atlas-tab.active {
      background: linear-gradient(135deg, var(--azul), #0b6ac1);
      color: #fff;
      box-shadow: 0 12px 24px rgba(12, 141, 217, 0.25);
    }
    .atlas-tab:hover {
      transform: translateY(-2px);
    }
    .atlas-content {
      display: none;
      border-radius: 16px;
      border: 1px solid #d7e5f7;
      background: #fafdff;
      padding: 1.75rem 1.5rem;
      gap: 1.35rem;
    }
    .atlas-content.active {
      display: grid;
    }
    .atlas-content h3 {
      margin-top: 0;
      color: var(--azul-escuro);
    }
    .atlas-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1.15rem;
      font-size: 0.95rem;
    }
    pre {
      background: #0f1e2f;
      color: #d7f5ff;
      padding: 1rem 1.25rem;
      border-radius: 14px;
      overflow-x: auto;
      font-size: 0.92rem;
      line-height: 1.5;
      box-shadow: inset 0 0 0 1px rgba(12, 141, 217, 0.15);
    }
    pre code {
      white-space: pre;
    }
    .conversion-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin: 2rem 0 1.25rem;
    }
    .conversion-button {
      border: 1px solid rgba(12, 141, 217, 0.3);
      background: rgba(12, 141, 217, 0.08);
      color: var(--azul-escuro);
      border-radius: 999px;
      padding: 0.55rem 1.35rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .conversion-button.active {
      background: linear-gradient(135deg, var(--azul), #0b6ac1);
      color: #fff;
      box-shadow: 0 14px 32px rgba(12, 141, 217, 0.28);
      transform: translateY(-1px);
    }
    .conversion-pane {
      display: none;
      border: 1px solid #d6e4f6;
      border-radius: 18px;
      background: #fbfeff;
      padding: 2rem 1.75rem;
      margin-bottom: 1.75rem;
      box-shadow: 0 20px 45px rgba(18, 58, 99, 0.09);
    }
    .conversion-pane.active {
      display: block;
    }
    .conversion-pane h3 {
      margin-top: 0;
      color: var(--azul-escuro);
    }
    .source-card {
      background: rgba(236, 244, 255, 0.65);
      border: 1px solid rgba(12, 141, 217, 0.18);
      border-radius: 16px;
      padding: 1.25rem 1.35rem 1.5rem;
      margin: 1.25rem 0 1.75rem;
      box-shadow: 0 14px 38px rgba(12, 141, 217, 0.12);
    }
    .source-card .source-meta {
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      color: var(--cinza);
      margin-bottom: 0.75rem;
    }
    .layout-map {
      width: 100%;
      max-width: 720px;
      margin: 1.75rem auto;
      display: block;
      border-radius: 12px;
      box-shadow: 0 10px 28px rgba(12, 141, 217, 0.15);
    }
    .layout-map text {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      font-size: 14px;
      fill: #0b2d4a;
      font-weight: 600;
    }
    .layout-map rect {
      fill: rgba(12, 141, 217, 0.18);
      stroke: rgba(12, 141, 217, 0.65);
      stroke-width: 1.5;
    }
    .layout-map rect.asset {
      fill: rgba(53, 160, 126, 0.22);
      stroke: rgba(53, 160, 126, 0.7);
    }
    .conversion-pane ol {
      margin-left: 1.35rem;
    }
    .conversion-pane li {
      margin-bottom: 0.65rem;
    }
    .atlas-table thead {
      background: rgba(12, 141, 217, 0.12);
    }
    .atlas-table th,
    .atlas-table td {
      padding: 0.75rem 0.85rem;
      text-align: left;
      border-bottom: 1px solid #dfe9f7;
      vertical-align: top;
    }
    .atlas-table th {
      color: var(--azul-escuro);
      font-weight: 700;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .atlas-table code {
      background: rgba(12, 141, 217, 0.08);
      color: var(--azul-escuro);
      padding: 0.15rem 0.35rem;
      border-radius: 6px;
      font-size: 0.85rem;
    }
    .atlas-grid {
      display: grid;
      gap: 1.1rem;
    }
    .atlas-highlight {
      border-left: 5px solid var(--azul);
      background: rgba(12, 141, 217, 0.08);
      padding: 1rem 1.15rem;
      border-radius: 12px;
    }
    .atlas-list {
      display: grid;
      gap: 0.55rem;
      margin: 0;
      padding-left: 1.15rem;
    }
    .card {
      border-radius: 16px;
      border: 1px solid #d7e5f7;
      background: #fafdff;
      padding: 1.4rem 1.3rem 1.15rem;
      position: relative;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .card:hover {
      transform: translateY(-4px);
      box-shadow: 0 18px 40px rgba(12, 141, 217, 0.18);
    }
    .card h3 {
      margin-top: 0;
      font-size: 1.2rem;
    }
    .checklist {
      display: grid;
      gap: 0.85rem;
      margin-top: 1.5rem;
    }
    .checklist label {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.75rem;
      align-items: start;
      padding: 1rem 1rem 1rem 1.25rem;
      border-radius: 12px;
      background: #f7fbff;
      border: 1px solid #dce9f9;
    }
    .checklist input[type="checkbox"] {
      width: 1.15rem;
      height: 1.15rem;
      margin-top: 0.35rem;
    }
    .interactive-panel {
      background: var(--azul-escuro);
      color: #fff;
      border-radius: 18px;
      padding: 1.75rem;
      display: grid;
      gap: 1rem;
      position: relative;
      overflow: hidden;
    }
    .interactive-panel::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.22), transparent 58%);
      pointer-events: none;
    }
    .interactive-panel label {
      font-weight: 600;
    }
    .interactive-panel select,
    .interactive-panel button {
      border-radius: 10px;
      border: none;
      padding: 0.7rem 0.85rem;
      font-size: 1rem;
      font-weight: 600;
    }
    .interactive-panel select {
      background: #fff;
      color: var(--azul-escuro);
    }
    .interactive-panel button {
      background: linear-gradient(135deg, var(--azul), #0b6ac1);
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s ease, filter 0.2s ease;
    }
    .interactive-panel button:hover {
      transform: translateY(-1px);
      filter: brightness(1.06);
    }
    .interactive-output {
      background: rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      padding: 1.35rem;
      line-height: 1.55;
      font-size: 0.98rem;
    }
    details {
      background: #f7fbff;
      border-radius: 14px;
      border: 1px solid #d9e7f8;
      margin-top: 1.25rem;
      padding: 1rem 1.25rem 1.15rem;
    }
    details summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--azul-escuro);
    }
    details pre {
      background: #0b2038;
      color: #d9e9ff;
      padding: 1.1rem 1.25rem;
      border-radius: 12px;
      overflow-x: auto;
      margin-top: 1rem;
      font-size: 0.92rem;
      line-height: 1.45;
    }
    .timeline {
      display: grid;
      gap: 1.25rem;
    }
    .timeline-step {
      background: #fafdff;
      border: 1px solid #d6e6f9;
      border-radius: 14px;
      padding: 1.35rem 1.2rem 1.25rem;
      display: grid;
      gap: 0.75rem;
      position: relative;
    }
    .timeline-step strong {
      color: var(--azul-escuro);
    }
    .timeline-step .label {
      position: absolute;
      top: -12px;
      right: 16px;
      background: var(--amarelo);
      color: #fff;
      font-weight: 700;
      border-radius: 999px;
      padding: 0.25rem 0.75rem;
      letter-spacing: 0.02em;
    }
    .callout {
      border-left: 5px solid var(--verde);
      background: #f0f9f4;
      padding: 1.1rem 1.35rem;
      border-radius: 12px;
      margin-top: 1.5rem;
    }
    .warning {
      border-left-color: var(--vermelho);
      background: #fff1f1;
    }
    footer {
      text-align: center;
      padding: 2rem 1rem 4rem;
      color: #60718b;
      font-size: 0.95rem;
    }
    @media (max-width: 720px) {
      section {
        padding: 2.1rem 1.6rem;
      }
      .interactive-panel {
        padding: 1.3rem 1.2rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Guia de Recriação Total do Projeto na Unreal Engine 5</h1>
    <p>
      Este documento interativo indica a ordem ideal para reconstruir o projeto na UE5 reaproveitando assets originais.
      Cada etapa traz instruções práticas, checklist de prontidão, exemplos em Blueprint e pontos de verificação antes de avançar.
    </p>
  </header>
  <main>
    <section id="resumo">
      <h2>Sequência Recomendada de Implementação</h2>
      <p>
        Foque em <strong>importação controlada dos assets</strong>, seguido de uma <strong>base funcional de interface e inventário</strong>,
        antes de expandir para sistemas de progressão, drops, mapas e efeitos. Esta ordem reduz retrabalho e mantém o jogo jogável rapidamente.
      </p>
      <div class="interactive-panel">
        <div>
          <label for="perfil">Selecione seu foco atual:</label>
          <select id="perfil">
            <option value="default">Quero seguir a ordem ideal sugerida</option>
            <option value="asset">Tenho muitos assets convertidos e quero validar se posso usá-los</option>
            <option value="ui">Preciso reconstruir a interface o quanto antes</option>
            <option value="core">Quero priorizar sistemas centrais (itens, XP, drops)</option>
            <option value="maps">Preciso entregar mapas jogáveis rápido</option>
            <option value="vfx">Necessito atualizar efeitos e feedback audiovisual</option>
          </select>
        </div>
        <button type="button" id="verPlano">Ver ordem sugerida</button>
        <div class="interactive-output" id="saidaPlano">
          Selecione um foco e clique em <strong>Ver ordem sugerida</strong> para receber um roteiro imediato.
        </div>
      </div>
      <div class="grid-3" style="margin-top: 2rem;">
        <div class="card">
          <h3><span class="badge">1º</span> Fase de Validação</h3>
          <ul>
            <li>Auditoria de assets originais e conversão para UE5.</li>
            <li>Configuração de projeto, plugins e convenções.</li>
            <li>Protótipo básico de HUD + inventário navegável.</li>
          </ul>
        </div>
        <div class="card">
          <h3><span class="badge">2º</span> Fase Sistêmica</h3>
          <ul>
            <li>Recriação de itens, XP e drops com dados reaproveitados.</li>
            <li>Estruturação de mapas com spawners, colisões e navegação.</li>
            <li>Validação de rede/multiplayer (se aplicável).</li>
          </ul>
        </div>
        <div class="card">
          <h3><span class="badge">3º</span> Fase Sensorial</h3>
          <ul>
            <li>Atualização de efeitos visuais, sonoros e UI final.</li>
            <li>Polimento de performance, LODs, iluminação e pós-processo.</li>
            <li>Testes completos, correções finais e empacotamento.</li>
          </ul>
        </div>
      </div>
      <div class="checklist">
        <label>
          <input type="checkbox" />
          <span><strong>Inventariou todos os assets reutilizáveis</strong> (modelos, animações, sons, UI, dados) e marcou os que precisam de retrabalho.</span>
        </label>
        <label>
          <input type="checkbox" />
          <span><strong>Definiu a meta de FPS/plataformas alvo</strong> para orientar decisões de LOD, textura e iluminação.</span>
        </label>
        <label>
          <input type="checkbox" />
          <span><strong>Configurou controle de versão</strong> (Perforce, Git LFS ou similar) e separou branch para migração.</span>
        </label>
      </div>
    </section>

    <section id="atlas">
      <h2>Atlas Completo do Projeto Original</h2>
      <p>
        Utilize este atlas para rastrear onde cada funcionalidade do cliente e do servidor reside no projeto legado.
        Ele indica arquivos, diretórios e binários essenciais para orientar a migração 1:1 para a Unreal Engine 5,
        contemplando tanto o frontend (cliente) quanto o backend (servidores e bancos de dados).
      </p>
      <div class="atlas-tabs">
        <button class="atlas-tab active" data-tab="frontend">Cliente (Front-end)</button>
        <button class="atlas-tab" data-tab="backend">Servidor (Back-end)</button>
        <button class="atlas-tab" data-tab="dados">Dados &amp; Scripts Compartilhados</button>
        <button class="atlas-tab" data-tab="pipeline">Integração UE5 (Front + Back)</button>
      </div>

      <div class="atlas-content active" data-tab="frontend">
        <h3>Arquitetura do Cliente Original <small>(pasta <code>Source Main 5.2/source</code>)</small></h3>
        <table class="atlas-table">
          <thead>
            <tr>
              <th>Área</th>
              <th>Arquivos/Diretórios Originais</th>
              <th>Responsabilidade Atual</th>
              <th>Adaptação Recomendada na UE5</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Boot &amp; Loop</td>
              <td><code>Winmain.cpp</code>, <code>Winmain.h</code>, <code>Builder.cpp</code></td>
              <td>Cria janela OpenGL, inicializa subsistemas, roda loop de mensagens.</td>
              <td>Recriar fluxo em <code>UGameInstance</code> + <code>AGameModeBase</code>, migrando inicialização para <code>Subsystems</code> e <code>Game Feature Plugins</code>.</td>
            </tr>
            <tr>
              <td>Gestão de UI</td>
              <td><code>UIManager.cpp</code>, <code>NewUIManager.cpp</code>, <code>NewUIMainFrameWindow.cpp</code></td>
              <td>Orquestra HUD legado, troca de janelas e renderização 2D.</td>
              <td>Mapear widgets para <code>UMG</code>/<code>Common UI</code>; criar <code>BP_UIRoot</code> que instancia subwidgets e responde a <code>Gameplay Tags</code>.</td>
            </tr>
            <tr>
              <td>Inventário &amp; Itens</td>
              <td><code>NewUIMyInventory.cpp</code>, <code>ZzzInventory.cpp</code>, <code>ItemManager.cpp</code></td>
              <td>Renderiza slots, valida equipáveis, consulta dados de itens.</td>
              <td>Usar <code>Data Assets</code> e <code>Data Tables</code> em UE5; criar componentes <code>BP_InventoryManager</code> e <code>BP_ItemInstance</code> com replicação opcional.</td>
            </tr>
            <tr>
              <td>Progressão &amp; Personagem</td>
              <td><code>CharacterManager.cpp</code>, <code>QuestMng.cpp</code>, <code>GM3rdChangeUp.cpp</code></td>
              <td>Controla atributos, quests, classes avançadas e desbloqueios.</td>
              <td>Implementar em <code>Actor Components</code> (ex.: <code>BP_ProgressionComponent</code>) e <code>Gameplay Ability System</code> para buffs/skills.</td>
            </tr>
            <tr>
              <td>Mapas &amp; Mundo</td>
              <td><code>MapManager.cpp</code>, <code>w_MapProcess.cpp</code>, diretório <code>Time/</code></td>
              <td>Carrega dados de mapas, portais, horários de eventos e colisões.</td>
              <td>Converter layouts em <code>Level Streaming</code> / <code>World Partition</code>; migrar triggers para <code>Blueprint Actors</code> reutilizando CSVs como <code>Data Tables</code>.</td>
            </tr>
            <tr>
              <td>Efeitos &amp; Renderização</td>
              <td><code>ZzzEffect.cpp</code>, <code>SkillEffectMgr.cpp</code>, <code>GlobalBitmap.cpp</code>, <code>TextureScript.cpp</code></td>
              <td>Gera partículas, animações de habilidades e gerencia texturas legacy.</td>
              <td>Transformar assets em sistemas Niagara/Material Functions; migrar tabelas de efeitos para <code>Curve</code> e <code>Data Assets</code>.</td>
            </tr>
            <tr>
              <td>Rede &amp; Protocolos</td>
              <td><code>ProtocolSend.cpp</code>, <code>SocketSystem.cpp</code>, <code>WSclient.cpp</code></td>
              <td>Empacota mensagens, gerencia sockets TCP, interpreta respostas do servidor.</td>
              <td>Substituir por camadas HTTP/WebSocket/GRPC via <code>FHttpModule</code> ou plugins; definir <code>BP_ServerGateway</code> para traduzir mensagens.</td>
            </tr>
            <tr>
              <td>Localização &amp; Texto</td>
              <td><code>GlobalText.h</code>, <code>MultiLanguage.cpp</code>, <code>Local.cpp</code></td>
              <td>Carrega arquivos de texto, alterna idiomas e strings dinâmicas.</td>
              <td>Importar para <code>Localization Dashboard</code> da UE5; usar <code>FText</code> com <code>String Tables</code> para manter suporte multi-idioma.</td>
            </tr>
          </tbody>
        </table>
        <div class="atlas-highlight">
          <strong>Checklist Frontend:</strong>
          <ul class="atlas-list">
            <li>Revisar dependências OpenGL/Win32 em <code>Winmain.cpp</code> para substituição por módulos UE5.</li>
            <li>Gerar inventário de widgets <code>NewUI*</code> e mapear cada um para um <em>Widget Blueprint</em> equivalente.</li>
            <li>Converter dados lidos via <code>LoadData.cpp</code> em <code>Data Tables</code> para compartilhar com o backend.</li>
          </ul>
        </div>
      </div>

      <div class="atlas-content" data-tab="backend">
        <h3>Arquitetura dos Servidores <small>(pasta <code>MuServer_Season_5_Update_15</code>)</small></h3>
        <table class="atlas-table">
          <thead>
            <tr>
              <th>Componente</th>
              <th>Localização</th>
              <th>Função</th>
              <th>Pontos para Migração</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>ConnectServer</td>
              <td><code>ConnectServer/</code></td>
              <td>Autenticação inicial, direciona clientes para <em>JoinServer</em>.</td>
              <td>Planeje endpoint REST/WebSocket para handshake; mantenha lista de shards/configuração.</td>
            </tr>
            <tr>
              <td>JoinServer</td>
              <td><code>JoinServer/</code></td>
              <td>Gerencia login de contas, seleção de servidor e fila.</td>
              <td>Converter lógica para serviço de identidade (OAuth/JWT) integrado a banco atual.</td>
            </tr>
            <tr>
              <td>DataServer</td>
              <td><code>DataServer/</code></td>
              <td>Centraliza persistência de personagens, inventário e XP.</td>
              <td>Modelar APIs de persistência (REST/GraphQL) + camada de acesso a dados moderna (ORM ou microserviço).</td>
            </tr>
            <tr>
              <td>GameServer</td>
              <td><code>GameServer/</code> + <code>GameServer/DATA</code></td>
              <td>Executa lógica em tempo real, eventos, drops, skills.</td>
              <td>Planejar reescrita em engine servidor (C++/C#/Go) consumindo mesmas tabelas que UE5; migrar scripts <code>*.dat</code> e <code>.txt</code> para base comum.</td>
            </tr>
            <tr>
              <td>GameServerCS</td>
              <td><code>GameServerCS/</code></td>
              <td>Instância dedicada a Castle Siege e eventos PvP massivos.</td>
              <td>Separar serviços escaláveis (matchmaking/eventos) e sincronizar com UE5 via filas ou serviços em nuvem.</td>
            </tr>
            <tr>
              <td>MHPServer</td>
              <td><code>MHPServer/</code></td>
              <td>Proteção/anticheat legado com monitoramento de pacotes.</td>
              <td>Substituir por solução anti-cheat compatível com UE5 (EOS, Easy Anti-Cheat, VAC) ou criar validações server-side.</td>
            </tr>
            <tr>
              <td>Banco de Dados</td>
              <td><code>DB/</code>, <code>ScriptSql/</code></td>
              <td>Scripts SQL de criação, procedures e seeds.</td>
              <td>Revisar tabelas para normalização; gerar modelos ER atualizados para migração.</td>
            </tr>
            <tr>
              <td>Ferramentas</td>
              <td><code>Tools/</code></td>
              <td>Utilitários de manutenção (ex.: reset, monitoramento de eventos).</td>
              <td>Identificar ferramentas imprescindíveis e recriar painéis Web/CLI com APIs modernas.</td>
            </tr>
          </tbody>
        </table>
        <div class="atlas-highlight">
          <strong>Checklist Backend:</strong>
          <ul class="atlas-list">
            <li>Mapear dependências entre executáveis (ordem de inicialização em <code>StartUp/</code>).</li>
            <li>Catalogar arquivos <code>GameServerInfo - *.dat</code> para definir configurações que devem virar serviços de configuração.</li>
            <li>Exportar procedures críticas do diretório <code>ScriptSql</code> para documentação e refatoração.</li>
          </ul>
        </div>
      </div>

      <div class="atlas-content" data-tab="dados">
        <h3>Dados Compartilhados Entre Cliente e Servidor</h3>
        <div class="atlas-grid">
          <div>
            <strong>Diretório <code>MuServer_Season_5_Update_15/Data</code></strong>
            <ul class="atlas-list">
              <li><code>Item/</code>: tabelas <code>Item.txt</code>, <code>ItemDrop.txt</code>, <code>ItemOption.txt</code>, <code>ItemValue.txt</code> — base para inventário, drops e economia.</li>
              <li><code>Event/</code>: arquivos <code>BloodCastle.dat</code>, <code>DevilSquare.dat</code>, <code>ImperialGuardian.dat</code> descrevendo horários, bosses, recompensas.</li>
              <li><code>Custom/</code>: ajustes proprietários (ex.: <code>CustomCombo.txt</code>, <code>CustomMix.txt</code>, <code>CustomJewel.txt</code>) a serem refletidos em sistemas UE5.</li>
              <li><code>Character/</code>: limites de atributos, taxas de XP e configurações de classes.</li>
              <li>Arquivos globais (<code>Command.txt</code>, <code>Effect.txt</code>, <code>ItemMove.txt</code>) mapeiam comandos e efeitos utilizados tanto no cliente quanto no servidor.</li>
            </ul>
          </div>
          <div>
            <strong>Cliente <code>Source Main 5.2/source</code></strong>
            <ul class="atlas-list">
              <li><code>LoadData.cpp</code> &amp; <code>ReadScript.h</code>: rotinas de parsing de arquivos <code>.txt</code>/<code>.dat</code>.</li>
              <li><code>QuestInfo.cpp</code> e <code>QuestMng.cpp</code>: interpretam scripts de quests armazenados no servidor.</li>
              <li><code>GlobalText.h</code> + <code>Local.cpp</code>: strings compartilhadas com base nos mesmos IDs dos bancos de dados.</li>
            </ul>
          </div>
        </div>
        <div class="atlas-highlight">
          <strong>Práticas Recomendadas:</strong>
          <ul class="atlas-list">
            <li>Centralizar arquivos <code>.txt/.dat</code> em um repositório de dados versionado (Git LFS) e convertê-los para <code>JSON</code> ou <code>CSV</code> padronizado.</li>
            <li>Gerar <em>schemas</em> para cada tabela reutilizada, garantindo compatibilidade entre UE5 e backend moderno.</li>
            <li>Automatizar importação com scripts Python/C# que populam <code>Data Tables</code> na UE5 e alimentam o banco novo.</li>
          </ul>
        </div>
      </div>

      <div class="atlas-content" data-tab="pipeline">
        <h3>Pipeline Integrado Front + Back para Recriação na UE5</h3>
        <ol>
          <li><strong>Inventário de Assets</strong>: classifique meshes, texturas, ícones e sons oriundos do cliente e relacione com tabelas de itens (<code>Data/Item</code>).</li>
          <li><strong>Modelagem de APIs</strong>: transforme processos do <code>GameServer</code> em endpoints (login, load player, salvar inventário, rolagem de drop).</li>
          <li><strong>Sincronização de Dados</strong>: estabeleça formato único (ex.: <code>JSON</code>) e gere conversores a partir dos scripts originais (<code>LoadData.cpp</code>, <code>GameServerInfo - *.dat</code>).</li>
          <li><strong>Blueprint Gateway</strong>: crie <code>BP_ServerGateway</code> para consumir APIs (Login, CharacterLoad, ItemUpdate) com <code>Async Action</code> + <code>HTTP Request</code>.</li>
          <li><strong>Testes Integrados</strong>: para cada sprint, valide uma cadeia completa (ex.: login → carregar inventário → spawn mapa → evento → drop → salvar).</li>
        </ol>
        <div class="atlas-highlight">
          <strong>Ferramentas de Apoio:</strong>
          <ul class="atlas-list">
            <li>Scripts SQL do diretório <code>ScriptSql</code> como referência para modelar migrations modernas.</li>
            <li>Executáveis legados para capturar pacotes (útil ao recriar protocolos em UE5 via <code>Packet Capture</code>).</li>
            <li>Planilhas de estado de assets e dados compartilhados para acompanhar o progresso da migração.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="etapas">
      <h2>Etapas Detalhadas e Critérios de Saída</h2>
      <article>
        <h3>Etapa 0 – Preparação e Auditoria</h3>
        <p><strong>Objetivo:</strong> Garantir que o ambiente esteja pronto e todos os assets tenham status definido antes da migração.</p>
        <ul>
          <li>Configurar projeto UE5 (Game Feature Plugins conforme necessidade, Subsystems, Common UI).</li>
          <li>Importar assets de teste para validar pipelines (1 personagem, 1 arma, 1 HUD, 1 mapa pequeno).</li>
          <li>Criar planilha com origem &gt; destino (texturas, materiais, animações, sons, dados CSV/JSON).</li>
          <li>Montar pasta <code>/Game/LegacyImports</code> e subpastas por categoria (Characters, UI, FX...).</li>
          <li>Estabelecer nomeação consistente (prefixos BP_, SK_, UI_, FX_...).</li>
        </ul>
        <div class="callout warning">
          <strong>Atenção:</strong> Se o asset exigir conversão (por exemplo, materiais antigos), documente o esforço estimado antes de prosseguir para evitar gargalos no meio da recriação dos sistemas.
        </div>
      </article>
      <article>
        <h3>Etapa 1 – Núcleo Jogável (HUD + Inventário)</h3>
        <p><strong>Objetivo:</strong> Viabilizar uma experiência jogável mínima com interface responsiva.</p>
        <ol>
          <li><strong>HUD Modular:</strong> converter elementos UI legados em Widgets UMG separados (barra de vida, mana, XP, minimapa).</li>
          <li><strong>Inventário Base:</strong> criar <em>Data Assets</em> ou tabelas de dados com itens originais; gerar Blueprint <code>BP_InventoryManager</code>.</li>
          <li><strong>Input/UI:</strong> utilizar Enhanced Input + Common UI para navegação com teclado/mouse e controle.</li>
          <li><strong>Persistência:</strong> estruturar salvamento temporário em <code>UGameInstance</code> ou <code>USaveGame</code>.</li>
          <li><strong>Verificação:</strong> jogador consegue abrir HUD, equipar, consumir item e ver feedback visual.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Build jogável onde é possível iniciar partida, visualizar HUD completo e manipular inventário sem falhas.
        </div>
      </article>
      <article>
        <h3>Etapa 2 – Sistemas de Progressão (Itens, XP, Drops)</h3>
        <p><strong>Objetivo:</strong> Reimplementar lógica central reaproveitando dados e comportamento já existente.</p>
        <ol>
          <li><strong>Itens:</strong> Criar <code>BP_ItemBase</code> com metadados (tipo, raridade, efeitos) alimentado por <code>Item.txt</code> e <code>ItemOption.txt</code>; gerar <code>WBP_ItemTooltip</code> reproduzindo cores e textos originais.</li>
          <li><strong>Colisão/Renderização:</strong> Implementar <code>BP_ItemInstance</code> com <code>Box Collision</code> e lógica de <em>line trace</em> para repouso seguro, replicando <code>CheckStandAttr</code> do servidor.</li>
          <li><strong>Drops:</strong> Configurar <code>Data Table</code> com tabelas de loot legadas e componente <code>BP_LootSpawner</code>, validando restrições (Lucky, Periodic, mapas especiais) antes de spawnar pickups.</li>
          <li><strong>XP/Nível:</strong> Montar curva de XP (<code>CurveFloat</code>) ou tabela. Implementar <code>BP_ProgressionComponent</code>.</li>
          <li><strong>Balanceamento:</strong> Criar mapa de teste com inimigos representativos e ajustar probabilidades.</li>
          <li><strong>Economia:</strong> Validar integração com moeda/loja se aplicável.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Inimigos derrotados dropam itens corretos, XP sobe conforme curva e jogador atinge nível alvo sem inconsistências.
        </div>
      </article>
      <article>
        <h3>Etapa 3 – Mapas e Conteúdo Jogável</h3>
        <p><strong>Objetivo:</strong> Migrar mapas mantendo navegação, colisões e atmosferas originais.</p>
        <ol>
          <li><strong>Layout:</strong> Usar Level Partitioning/World Composition para mapas extensos. Importar malhas estáticas e colisões personalizadas.</li>
          <li><strong>Navegação:</strong> Regerar NavMesh, volumes de bloqueio, triggers e volumes de respawn.</li>
          <li><strong>Streaming:</strong> Configurar <code>World Partition</code> ou subníveis para iluminação e som.</li>
          <li><strong>Scripts:</strong> Migrar lógica de missões/eventos para <code>Level Blueprint</code> ou <code>Actor Components</code>.</li>
          <li><strong>Testes:</strong> Percorrer cada mapa verificando colisão, iluminação e performance.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Todos os mapas carregam em 30s, sem luzes quebradas, sem buracos de colisão e com triggers funcionais.
        </div>
      </article>
      <article>
        <h3>Etapa 4 – Efeitos, Áudio e Polimento</h3>
        <p><strong>Objetivo:</strong> Restaurar feedback audiovisual e preparar build final.</p>
        <ol>
          <li><strong>VFX:</strong> Atualizar partículas no Niagara reaproveitando texturas/meshes antigos.</li>
          <li><strong>SFX:</strong> Conectar trilhas e sons via <code>MetaSounds</code> ou Sound Cues.</li>
          <li><strong>Iluminação:</strong> Ajustar Lumen, pós-processo e exposição. Validar escalas de lightmaps.</li>
          <li><strong>Performance:</strong> Verificar <em>GPU Visualizer</em>, profiler e ativar LODs/streaming.</li>
          <li><strong>Entrega:</strong> Empacotar build, rodar smoke tests e criar checklist final.</li>
        </ol>
        <div class="callout">
          <strong>Critério de saída:</strong> Build final com áudio/visual coerentes, rodando estável dentro das metas de performance definidas na preparação.
        </div>
      </article>
    </section>

    <section id="item-system-encyclopedia">
      <h2>Enciclopédia do Sistema de Itens</h2>
      <p>
        Esta enciclopédia consolida tudo que envolve itens: dados, colisão, drops, exibição na interface,
        sincronização com backend e efeitos associados. Use-a como checklist central para não esquecer
        nenhuma dependência ao migrar para a Unreal Engine 5.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>Fontes de Dados</h3>
          <ul>
            <li><code>Data/Item/Item.txt</code>: definição base (tamanho, tipo, requisitos, dano, durabilidade).</li>
            <li><code>Data/Item/ItemOption.txt</code>, <code>ItemValue.txt</code>, <code>ItemDrop.txt</code>: opções extras, preços e tabelas de drop.</li>
            <li><code>Source Main 5.2/source/ReadScript.h</code>: padrões de parsing para converter em <code>Data Tables</code> UE5.</li>
            <li><code>Source MuServer Update 15/GameServer/Data/</code>: espelha as mesmas informações usadas pelo backend.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Gameplay &amp; Colisão</h3>
          <ul>
            <li><code>Map.cpp</code> (<code>CheckStandAttr</code>, <code>SetAttr</code>): regras para impedir drops em áreas bloqueadas.</li>
            <li><code>ItemManager.cpp</code>: validação de <em>Lucky</em>, periódicos, pets e sockets antes do drop.</li>
            <li><code>MoveCommand.txt</code> e <code>ItemMove.txt</code>: restrições de movimentação (por exemplo, se um item pode ir para o cofre).</li>
            <li>Componentes UE5: <code>BP_LootSpawner</code>, <code>BP_ItemInstance</code>, <code>BP_ItemPickupZone</code> (gatilhos).</li>
          </ul>
        </div>
        <div class="card">
          <h3>Interface &amp; Feedback</h3>
          <ul>
            <li><code>NewUIMyInventory.cpp</code>, <code>NewUIInventoryCtrl.cpp</code>: layout de slots, tooltips, arrasto.</li>
            <li><code>NewUIShop.cpp</code>, <code>NewUIRepair.cpp</code>: reuso de tooltips em loja e reparo.</li>
            <li>Widgets UE5: <code>WBP_Inventory</code>, <code>WBP_ItemTooltip</code>, <code>WBP_ItemSlot</code>, <code>WBP_ItemGhost</code>.</li>
            <li>Áudio/VFX: <code>Item/ItemSound.bmd</code> &rarr; <code>MetaSounds</code>, <code>FX_ItemPickup.uasset</code> adaptado de partículas originais.</li>
          </ul>
        </div>
      </div>
      <h3>Fluxo Integrado</h3>
      <ol>
        <li><strong>Carregar Dados:</strong> Converter arquivos <code>.txt</code> via script Python/C# que gera <code>CSV</code> e importa em <code>DT_ItemDefinitions</code> e <code>DT_ItemDropTables</code>.</li>
        <li><strong>Sincronizar Backend:</strong> Endpoints <code>/items</code> e <code>/loot-tables</code> retornam hash + conteúdo. UE5 guarda <em>cache</em> e solicita apenas se o hash diferir.</li>
        <li><strong>Instanciar Mundo:</strong> <code>BP_LootSpawner</code> escolhe entrada de drop, verifica colisão (line trace + <code>Gameplay Tags</code>) e instancia <code>BP_ItemInstance</code>.</li>
        <li><strong>Atualizar Inventário:</strong> <code>BP_InventoryComponent</code> recebe resposta do servidor, atualiza slots, dispara eventos de UI e registra histórico para <code>WBP_Log</code>.</li>
        <li><strong>Tooltips &amp; Visual:</strong> Widgets renderizam dados formatados, aplicando máscaras originais, ícones e efeitos de raridade.</li>
        <li><strong>Persistir:</strong> Backend confirma operações (drop, pickup, uso, venda) e envia snapshots para <code>POST /inventory/sync</code> garantindo consistência.</li>
      </ol>
      <div class="callout warning">
        <strong>Pontos de Atenção:</strong>
        <ul>
          <li>Itens temporários (<code>m_PeriodicItemTime</code>) precisam de contagem regressiva em ambos os lados; crie <code>FTimerHandle</code> no cliente para feedback visual.</li>
          <li>Itens empilháveis devem respeitar <code>MaxStack</code> dos dados originais. Implemente validação tanto no <code>BP_InventoryComponent</code> quanto no endpoint.</li>
          <li>Itens com sockets/ancient exigem camadas extras de tooltip; prepare <code>Widget Switcher</code> para essas seções.</li>
          <li>Colisão com o cenário: gere <em>heightmaps</em> ou use <code>Runtime Virtual Textures</code> para alinhar pickups a terrenos complexos.</li>
        </ul>
      </div>
      <h3>Checklist de Testes do Sistema de Itens</h3>
      <ul>
        <li>Simular drop massivo em mapas diferentes (cidade, dungeon, evento) e verificar colisão + respawn após timeout.</li>
        <li>Verificar tooltips em diferentes idiomas (usar <code>GlobalText.h</code> &rarr; <code>LocRes</code> no UE5).</li>
        <li>Executar testes automatizados de inventário (Blueprint <code>Functional Tests</code>) movendo, dividindo e combinando stacks.</li>
        <li>Forçar perda de conexão durante pickup para validar recuperação de estado via <code>/inventory/sync</code>.</li>
      </ul>
    </section>

    <section id="mob-system-atlas">
      <h2>Atlas Completo do Sistema de Mobs</h2>
      <p>
        Este atlas organiza todas as informações necessárias para reconstruir o ecossistema de mobs na Unreal Engine 5,
        incluindo spawn, movimentação, IA, drops, distribuição de XP e sincronização com o backend. Os dados legados
        do cliente e do servidor permanecem a fonte de verdade e devem ser convertidos em estruturas UE5 seguindo os
        passos abaixo.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>Fontes de Dados Legadas</h3>
          <ul>
            <li><code>Data/Monster/Monster.txt</code> e <code>MonsterSetBase.txt</code>: estatísticas base e pontos de spawn.</li>
            <li><code>Source MuServer Update 15/GameServer/GameServer/MonsterSetBase.cpp</code>: parsing de respawn, delays e limites.</li>
            <li><code>Source MuServer Update 15/GameServer/GameServer/MonsterAI.cpp</code>, <code>MonsterAIState.cpp</code>: estados de IA e mudança de comportamento.</li>
            <li><code>Source Main 5.2/source/ZzzInterface.cpp</code> (<code>CreateMonster</code>): expectativas de apresentação no cliente original.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Componentes UE5 Recomendados</h3>
          <ul>
            <li><code>BP_MobSpawner</code> (Actor) alimentado por <code>DT_MobSpawn</code> com dados convertidos de <code>MonsterSetBase</code>.</li>
            <li><code>BP_MobCharacter</code> (Child de <code>Character</code>) com <code>CharacterMovement</code> configurado para valores originais de velocidade.</li>
            <li><code>BP_MobAIController</code> + <code>Behavior Tree</code> replicando tabelas de estado de <code>MonsterAI</code>.</li>
            <li><code>BP_MobDropComponent</code> e <code>BP_MobXPComponent</code> para acionar loot/XP de forma sincronizada com o servidor.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Sincronização Cliente &amp; Servidor</h3>
          <ul>
            <li><code>GameServer/GameServer/MonsterManager.cpp</code>: lógica oficial de criação e respawn; serve como blueprint do backend moderno.</li>
            <li>Endpoints REST/WebSocket sugeridos: <code>POST /world/spawn</code>, <code>POST /world/mob/{id}/state</code>, <code>POST /world/mob/{id}/death</code>.</li>
            <li>Eventos replicados via <code>Gameplay Message Subsystem</code> no cliente para atualizar HUD, log de combate e inventário.</li>
            <li>Persistência de drops alinhada com <code>ItemDrop.cpp</code> e <code>MapItem.cpp</code>, garantindo regras idênticas às do servidor.</li>
          </ul>
        </div>
      </div>
      <h3>Pipeline de Spawn e Respawn</h3>
      <ol>
        <li><strong>Converter pontos:</strong> exporte <code>MonsterSetBase.txt</code> para <code>DT_MobSpawn</code> com campos <em>MapID</em>, <em>SpawnPoint</em> (X, Y), <em>Direction</em>, <em>RespawnTime</em>, <em>MobClass</em>, <em>Quantity</em>.</li>
        <li><strong>Instanciar spawner:</strong> posicione <code>BP_MobSpawner</code> no nível e associe a linha correspondente do data table.</li>
        <li><strong>Solicitar backend:</strong> ao carregar o nível, envie <code>POST /world/spawn</code> com o identificador do spawner. O servidor responde com <em>MobInstanceIDs</em> e atributos finais (HP, tipo de drop extra, buffs).</li>
        <li><strong>Spawn local:</strong> <code>BP_MobSpawner</code> cria <code>BP_MobCharacter</code> usando meshes/animações originais convertidas. Use <code>SetActorLocation</code> com as coordenadas convertidas (multiplique por <code>TERRAIN_SCALE</code> para manter proporção).</li>
        <li><strong>Respawn:</strong> ao receber evento <code>MobRespawnScheduled</code> do servidor (calculado por <code>MonsterManager::RespawnMonster</code>), iniciar <code>FTimerHandle</code> no spawner para recriar o mob no tempo indicado.</li>
      </ol>
      <pre><code>Event InitializeSpawner (SpawnerRow)
  → Set DataTableRow = SpawnerRow
  → For Index 0 .. SpawnerRow.Quantity-1
        → Send HTTP (POST /world/spawn) com { SpawnerId, Index }
        → OnSuccess → SpawnMobLocal(Response.Payload)

Function SpawnMobLocal (Payload)
  → SpawnActor BP_MobCharacter at Payload.WorldLocation/Rotation
  → Set MobInstanceID = Payload.InstanceId
  → MobCharacter.ApplyStats(Payload.Stats)
  → MobCharacter.StartBehaviorTree(Payload.BehaviorProfile)</code></pre>
      <h3>Movimentação, Ameaça e Habilidades</h3>
      <p>
        A movimentação no legado é definida pelos estados em <code>MonsterAIState.cpp</code> e regras de perseguição de <code>MonsterAI.cpp</code>.
        No UE5, utilize Behavior Trees com <em>Blackboard</em> contendo chaves <code>TargetActor</code>, <code>PatrolRoute</code>, <code>CurrentState</code>.
      </p>
      <details open>
        <summary>Padrões de comportamento</summary>
        <ol>
          <li><strong>Idle/Patrulha:</strong> converter rotas de <code>MonsterAIMovePath.cpp</code> para <code>DT_MobPatrol</code> e alimentar <code>Simple Move To</code> no AI Controller.</li>
          <li><strong>Perseguição:</strong> replicar cálculo de distância (<code>gObjCheckAttackArea</code>) usando <code>EQSTestingPawn</code> ou <code>Environment Query</code>.</li>
          <li><strong>Ataque:</strong> chamar habilidades mapeadas em <code>MonsterSkillManager.cpp</code>; cada entrada vira uma <code>Gameplay Ability</code> ou <code>Anim Montage</code> no UE5.</li>
          <li><strong>Fuga/Reset:</strong> observar <code>MonsterAIState::AI_PATH_RETURN</code>. Configure <code>Nav Link Proxy</code> para retornos rápidos e dispare evento de reset para limpar ameaças.</li>
        </ol>
        <pre><code>Behavior Tree Resumo
Root
 └─ Selector (Combate)
     ├─ Sequence (Tem Alvo?)
     │    ├─ Blackboard Check (TargetActor)
     │    ├─ Task Attack (usa SkillProfile atual)
     └─ Sequence (Procurar Jogador)
          ├─ Task Run EQS (Ameaça)
          └─ Task Move To (Resultado EQS)

Service AtualizarAmeaça (a cada 0.5s)
  → Para cada jogador em range (Data do backend)
        Atualiza AggroMap replicando <code>MonsterAIAgro.cpp</code>
  → Define TargetActor = Maior Threat</code></pre>
      </details>
      <h3>Drops, XP e Eventos Pós-Morte</h3>
      <ul>
        <li><strong>Drop:</strong> use o mesmo fluxo do painel de itens. <code>BP_MobDropComponent</code> requisita <code>/world/mob/{id}/death</code>, que retorna lista de <em>LootEntries</em> conforme <code>MonsterSetBase</code> + <code>ItemBagManager.cpp</code>.</li>
        <li><strong>XP:</strong> backend calcula via <code>ExperienceTable.cpp</code>. O cliente apenas reproduz o evento <code>OnExperienceReceived</code> para cada participante, distribuindo por party/guild segundo a resposta.</li>
        <li><strong>Eventos:</strong> bosses e invasões utilizam scripts dedicados (<code>InvasionManager.cpp</code>, <code>RaklionBattleOfSelupan.cpp</code>). No UE5, mantenha <code>BP_EventDirector</code> responsável por spawnar mobs especiais e emitir <code>Gameplay Tags</code> como <code>Event.Raklion.Active</code>.</li>
      </ul>
      <div class="callout">
        <strong>Checklist de QA:</strong>
        <ul>
          <li>Conferir se os tempos de respawn respeitam tolerância de ±1s em relação ao servidor legado.</li>
          <li>Validar movimentação em terrenos convertidos: usar <code>NavMesh Invokers</code> para mapas extensos.</li>
          <li>Testar queda de conexão durante combate; mobs devem congelar estado até receber confirmação do backend.</li>
          <li>Monitorar performance: Behavior Trees complexos devem usar <code>Logic Update Interval</code> adaptativo.</li>
        </ul>
      </div>
    </section>

    <section id="skill-system-guide">
      <h2>Compêndio do Sistema de Skills</h2>
      <p>
        Esta seção explica como mapear o sistema de skills original para Blueprints e, quando necessário, C++ na UE5,
        mantendo efeitos visuais, custos, cooldowns e interações com o backend. Inclui a adaptação de skills de personagem,
        master skills e habilidades de mobs.
      </p>
      <div class="grid-3">
        <div class="card">
          <h3>Arquivos e Código Originais</h3>
          <ul>
            <li><code>Data/Skill/Skill.txt</code>, <code>SkillSkill_*.txt</code>, <code>MasterSkillTree.txt</code>: atributos, custos, requisitos.</li>
            <li><code>Source MuServer Update 15/GameServer/GameServer/SkillManager.cpp</code>: aplicação de dano, mana, cooldown.</li>
            <li><code>SkillDamage.cpp</code>, <code>SkillHitBox.cpp</code>: fórmulas e alcance.</li>
            <li><code>Source Main 5.2/source/SkillManager.cpp</code>, <code>SkillEffectMgr.cpp</code>, <code>ZzzEffectMagicSkill.cpp</code>: efeitos visuais e sons no cliente.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Estrutura UE5 Recomendada</h3>
          <ul>
            <li><code>BP_SkillComponent</code> (Actor Component) com arrays <code>KnownSkills</code> e <code>ActiveBuffs</code>.</li>
            <li><code>DT_SkillCatalog</code> contendo <code>FSKillDefinition</code> (ID, Nome, Classe, Custos, Efeito, Cooldown, AnimMontage, FX).</li>
            <li><code>Gameplay Ability System</code> opcional: cada skill vira uma <code>UGameplayAbility</code> com <code>GameplayEffect</code> replicando buffs.</li>
            <li><code>WBP_SkillBar</code>, <code>WBP_SkillTooltip</code> e <code>WBP_SkillTree</code> para interface.</li>
          </ul>
        </div>
        <div class="card">
          <h3>Integração com Backend</h3>
          <ul>
            <li>Endpoints: <code>POST /skills/cast</code>, <code>POST /skills/equip</code>, <code>GET /characters/{id}/skills</code>, <code>POST /skills/master-tree</code>.</li>
            <li>Converter <code>SkillManager::CGSkillAttackRecv</code> para API moderna que valida requisitos antes de confirmar casting.</li>
            <li>Persistir builds de master skill conforme estrutura de <code>MasterSkillTree.cpp</code>, retornando nós adquiridos.</li>
            <li>Enviar logs de combate (dano aplicado, status) para analítica, mantendo compatibilidade com <code>SkillDamage</code>.</li>
          </ul>
        </div>
      </div>
      <h3>Processo de Conversão</h3>
      <ol>
        <li><strong>Normalizar dados:</strong> criar script que lê <code>Skill.txt</code> e gera <code>DT_SkillCatalog</code> com campos extras (classe permitida, target type, min/max range, consumo de mana e stamina).</li>
        <li><strong>Importar efeitos:</strong> converter texturas/sons citados em <code>ZzzEffect.cpp</code> e <code>SkillEffect.bmd</code> para <code>Niagara</code>/<code>MetaSounds</code>.</li>
        <li><strong>Configurar componente:</strong> <code>BP_SkillComponent</code> lê <code>DT_SkillCatalog</code> na inicialização e popula slots ativos conforme retorno do backend (<code>GET /characters/{id}/skills</code>).</li>
        <li><strong>Implementar casting:</strong> cada habilidade chama <code>POST /skills/cast</code>, aguarda confirmação (para validação anti-cheat) e, em seguida, executa o efeito local.</li>
        <li><strong>Sincronizar cooldown:</strong> backend devolve timestamp e duração. O cliente utiliza <code>FTimerManager</code> para bloquear inputs até o término.</li>
      </ol>
      <h3>Blueprint de Casting Genérico</h3>
      <pre><code>Function TryCastSkill (SkillID)
  → Data = DT_SkillCatalog[SkillID]
  → Se ManaAtual &lt; Data.ManaCost → HUD.Log("Mana insuficiente")
  → Send HTTP (POST /skills/cast)
        Body = { SkillID, TargetId, Position, Rotation }
  → OnSuccess:
        ApplySkillLocally(Data, Response.Payload)
        StartCooldown(SkillID, Response.Payload.Cooldown)

Function ApplySkillLocally (Data, Payload)
  → PlayAnimMontage(Data.AnimMontage)
  → SpawnSystemAtLocation(Data.NiagaraFX, Payload.SpawnLocation)
  → ApplyGameplayEffectToTarget(Payload.Targets, Data.EffectHandle)
  → If Data.TriggersProjectile → SpawnActor(BP_SkillProjectile)</code></pre>
      <h3>Catalogação de Skills</h3>
      <table class="matrix">
        <thead>
          <tr>
            <th>Grupo</th>
            <th>Exemplos</th>
            <th>Conversão UE5</th>
            <th>Observações</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>Skills Básicas</strong></td>
            <td><code>Falling Slash</code>, <code>Power Slash</code></td>
            <td>Montages simples + <code>GameplayEffect</code> instantâneo de dano. Usar <code>Trace</code> em arco para alcance, conforme <code>SkillHitBox.cpp</code>.</td>
            <td>Respeitar delay <code>Delay</code> de <code>Skill.txt</code>; sincronizar com animação para evitar spam.</td>
          </tr>
          <tr>
            <td><strong>Skills com Projétil</strong></td>
            <td><code>Ice Arrow</code>, <code>Triple Shot</code></td>
            <td><code>BP_SkillProjectile</code> com movimento <code>ProjectileMovement</code> e colisão <code>Sphere</code>. Mesh/partículas importadas de <code>SkillEffect.bmd</code>.</td>
            <td>Servidor calcula trajetória e impacto final (anti-cheat). Cliente mostra trajetória prevista e ajusta ao receber confirmação.</td>
          </tr>
          <tr>
            <td><strong>Buffs &amp; Debuffs</strong></td>
            <td><code>Greater Fortitude</code>, <code>Soul Barrier</code></td>
            <td><code>GameplayEffect</code> com atributos modificadores (HP Max, Defense). Replicar durações de <code>SkillManager.cpp</code>.</td>
            <td>Exibir ícone em <code>WBP_BuffTray</code> reaproveitando sprites originais. Backend envia <code>BuffId</code> e <code>ExpireAt</code>.</td>
          </tr>
          <tr>
            <td><strong>Master Skills</strong></td>
            <td><code>Flame Strike</code>, <code>Archangel's Will</code></td>
            <td>Criar árvore em <code>WBP_SkillTree</code> com dados de <code>MasterSkillTree.txt</code>. Cada nó aplica <code>GameplayEffect</code> incremental.</td>
            <td>Necessário endpoint dedicado para salvar progresso (<code>POST /skills/master-tree</code>).</td>
          </tr>
          <tr>
            <td><strong>Skills de Mobs</strong></td>
            <td><code>Selupan Ice Storm</code>, <code>Kundun Summon</code></td>
            <td>Reaproveitar <code>MonsterSkillManager.cpp</code> para gerar <code>DT_MobSkillProfiles</code>. Comportamentos viram tarefas específicas no Behavior Tree.</td>
            <td>Sincronizar com eventos de IA do atlas de mobs para garantir efeitos corretos no momento do cast.</td>
          </tr>
        </tbody>
      </table>
      <div class="callout">
        <strong>Boas práticas:</strong>
        <ul>
          <li>Centralize cálculos críticos (dano, resistência, hit chance) no backend para evitar divergências.</li>
          <li>Utilize <code>AbilitySystemComponent</code> ou uma camada C++ para habilidades com múltiplos efeitos simultâneos.</li>
          <li>Reaproveite texturas/ícones originais em formato <code>.tga</code>/<code>.ozj</code> convertendo para <code>.png</code> e mantendo nomes para rastreabilidade.</li>
          <li>Implemente testes automatizados de skill (Blueprint Functional Tests) executando combos, buffs e projeções de dano comparados com valores originais.</li>
        </ul>
      </div>
    </section>

    <section id="blueprints">
      <h2>Exemplos Práticos em Blueprint</h2>
      <p>Use os snippets abaixo como base para recriar a lógica principal em Blueprints reaproveitando assets existentes.</p>
      <details open>
        <summary>HUD Dinâmico e Inventário (Widget Blueprint)</summary>
        <ol>
          <li>Criar <code>WBP_HUD</code> contendo componentes de barra de vida/mana (Progress Bar) e painel de inventário (Uniform Grid).</li>
          <li>Associar <code>BP_InventoryManager</code> ao Player Controller e expor eventos <em>OnInventoryChanged</em>.</li>
          <li>No Event Graph do widget, reagir ao evento para atualizar ícones reaproveitados.</li>
        </ol>
        <pre><code>Event Construct
  → Get Player Controller → Cast to BP_PlayerController
  → Bind Event to InventoryManager.OnInventoryChanged

Custom Event OnInventoryChanged (Itens)
  → Clear Children (GridInventario)
  → ForEach Itens:
      Create Widget (WBP_ItemSlot)
      SetData (ItemID, IconeTextura, Quantidade)
      Add Child to Grid (coluna = Index % 6, linha = Index / 6)</code></pre>
      </details>
      <details>
        <summary>Tela de Login (Widget + Fluxo HTTP)</summary>
        <ol>
          <li>Criar <code>WBP_Login</code> com Canvas 640×480, inputs e botões posicionados conforme <code>CLoginWin::SetPosition</code>.</li>
          <li>Adicionar <em>Widget Switcher</em> para alternar entre estados (Padrão, Carregando, Erro) enquanto a requisição HTTP é processada.</li>
          <li>Implementar <code>BP_LoginController</code> (GameInstanceSubsystem) que chama <code>BP_ServerGateway.LoginAsync</code> e gerencia cache de usuário.</li>
          <li>Mapear códigos de erro <code>GlobalText[450..461]</code> para mensagens amigáveis e reproduzir sons <code>SOUND_CLICK01</code>/<code>SOUND_FAIL</code>.</li>
          <li>Ao sucesso, salvar Token/Refresh em <code>USaveGame</code>, armazenar lista de personagens no <code>GameInstance</code> e abrir a cena de seleção.</li>
        </ol>
        <pre><code>Event Construct
  → LoginController = GetGameInstanceSubsystem(BP_LoginController)
  → Bind LoginController.OnLoginSuccess → HandleSuccess
  → Bind LoginController.OnLoginFailed → HandleError

OnClickLogin / OnPressEnter
  → PlaySound2D(SFX_Click)
  → WidgetSwitcher.SetActiveIndex(STATE_Loading)
  → LoginController.RequestLogin(UserText, PassText, RememberCheck.IsChecked)

HandleSuccess(Characters)
  → WidgetSwitcher.SetActiveIndex(STATE_Default)
  → SaveGameInstance(Token)
  → OpenLevel("L_CharacterSelect")

HandleError(Code, Message)
  → WidgetSwitcher.SetActiveIndex(STATE_Default)
  → MessageBox.Show(Message)
  → PlaySound2D(SFX_Error)</code></pre>
      </details>
      <details>
        <summary>Seleção de Personagem (UMG + Preview 3D)</summary>
        <ol>
          <li>Criar <code>WBP_CharacterSelect</code> com <code>UniformGridPanel</code> de 5 slots usando sprites <code>CharSel</code> originais.</li>
          <li>Adicionar <code>BP_CharacterPreviewManager</code> (Actor) responsável por spawnar <code>BP_CharacterPreview</code> e movimentar a câmera.</li>
          <li>Conectar botões <em>Create</em>, <em>Delete</em>, <em>Connect</em> ao <code>BP_ServerGateway</code> para executar chamadas <code>POST /characters</code>, <code>DELETE /characters/{id}</code>, <code>POST /sessions/enter</code>.</li>
          <li>Reaproveitar animações de idle/pose importadas do cliente original (índice por classe em <code>CharacterManager</code>).</li>
          <li>Sincronizar estado <code>SelectedHero</code> no <code>PlayerState</code> para que outros sistemas carreguem inventário, mapa e configurações corretas.</li>
        </ol>
        <pre><code>Event Construct
  → ServerGateway.ListCharactersAsync()
  → Bind OnCharactersReceived → BuildSlots

BuildSlots(List)
  → ForEach Index 0..4
        Slot = CreateWidget(WBP_CharacterSlot)
        Slot.Setup(List[Index])
        Slot.OnSelected.Bind → HandleSelected
        Grid.AddChild(Slot)

HandleSelected(CharData)
  → PreviewManager.FocusOn(CharData)
  → SelectedCharacter = CharData
  → UpdateTopBarButtons()

OnClickConnect
  → ServerGateway.EnterWorldAsync(SelectedCharacter.Id)
  → OnSuccess → OpenLevel(SelectedCharacter.StartMap)

OnClickCreate
  → ShowModal(WBP_CharacterCreation)</code></pre>
      </details>
      <details>
        <summary>Sistema de Itens com Data Table</summary>
        <ol>
          <li>Criar <code>DT_Items</code> (Data Table) baseado em struct <code>FItemStats</code> contendo Nome, Tipo, Raridade, Mesh, Icone, Efeito.</li>
          <li>No <code>BP_ItemBase</code>, adicionar variável <code>ItemRowName</code> e carregar dados na construção.</li>
          <li>Expor função <code>ApplyEffect</code> para uso por consumíveis ou equipamentos.</li>
        </ol>
        <pre><code>Event OnConstruct (BP_ItemBase)
  → Get Data Table Row (DT_Items, ItemRowName)
  → Set DisplayName, Icon, Mesh, Stats

Function ApplyEffect (Alvo)
  Switch on ItemType
    Consumivel → Alvo.ApplyHealth(Stats.HealAmount)
    Equipamento → Alvo.EquiparSlot(Stats.Slot, self)
    Gema → Alvo.AtribuirBuff(Stats.BuffID, Stats.Duration)</code></pre>
      </details>
      <details>
        <summary>XP e Level Up Automatizado</summary>
        <ol>
          <li>Criar componente <code>BP_ProgressionComponent</code> com variáveis <code>CurrentXP</code>, <code>CurrentLevel</code>, <code>XPTable</code>.</li>
          <li>Adicionar função <code>AddExperience</code> chamada por inimigos ao morrer.</li>
          <li>Disparar evento <code>OnLevelUp</code> que atualiza HUD e atributos do personagem.</li>
        </ol>
        <pre><code>Function AddExperience (Amount)
  CurrentXP += Amount
  while CurrentXP ≥ XPTable[CurrentLevel]
    CurrentXP -= XPTable[CurrentLevel]
    CurrentLevel += 1
    OnLevelUp.Broadcast(CurrentLevel)

Event OnLevelUp
  → PlayerStatsComponent.IncrementarAtributos(CurrentLevel)
  → HUDWidget.PlayAnimation(LevelUpAnim)
  → Spawn Niagara (FX_LevelUp) na localização do jogador</code></pre>
      </details>
      <details>
        <summary>Drop de Loot Dinâmico</summary>
        <ol>
          <li><code>BP_LootSpawner</code> recebe tabela <code>DT_LootTable</code> herdada do jogo original.</li>
          <li>Ao destruir inimigo, chamar <code>SpawnLoot</code> informando <em>LootContext</em> (região, dificuldade).</li>
          <li>Gerar item físico com mesh/partícula reutilizada.</li>
        </ol>
        <pre><code>Function SpawnLoot (LootContext)
  EntradasVálidas ← Filtrar DT_LootTable por Região &amp; Raridade
  Sorteio ← Random Weighted Selection (DropRate)
  SpawnActor BP_ItemPickup at GetActorLocation()
  ItemPickup.SetItemID(Sorteio.ItemID)
  ItemPickup.PlayNiagara(FX_Drop, Cor = Sorteio.RaridadeCor)
  ItemPickup.Bind OnCollected → Inventario.AddItem(ItemID)</code></pre>
      </details>
      <details>
        <summary>Spawn e Respawn de Mobs com Tabelas Originais</summary>
        <ol>
          <li>Converter <code>MonsterSetBase.txt</code> para <code>DT_MobSpawn</code> contendo mapa, coordenadas, direção e tempo de respawn.</li>
          <li>No <code>BP_MobSpawner</code>, carregar a linha do Data Table no <code>BeginPlay</code> e solicitar autorização ao backend (<code>POST /world/spawn</code>).</li>
          <li>Ao receber a resposta, spawnar <code>BP_MobCharacter</code> com malhas originais e registrar o <em>MobInstanceId</em>.</li>
          <li>Escutar o evento <code>OnMobDied</code> do personagem para iniciar temporizador de respawn baseado em <code>RespawnTime</code>.</li>
        </ol>
        <pre><code>Event BeginPlay (BP_MobSpawner)
  → Row = Get Data Table Row (DT_MobSpawn, SpawnId)
  → HTTP POST /world/spawn (SpawnId)
  → OnSuccess → SpawnMob(Row, Response.Payload)

Function SpawnMob (Row, Payload)
  → SpawnActor(BP_MobCharacter, Location = Row.WorldPosition)
  → Mob.SetInstanceId(Payload.InstanceId)
  → Mob.ApplyStats(Payload.Stats)
  → Mob.OnMobDied.AddDynamic(self, &BP_MobSpawner::HandleMobDeath)

Function HandleMobDeath (Context)
  → SpawnLoot(Context)
  → SetTimer(Row.RespawnTime, Respawn)</code></pre>
      </details>
      <details>
        <summary>Execução de Skills com Gameplay Ability System</summary>
        <ol>
          <li>Registrar skills em <code>DT_SkillCatalog</code> com cooldown, mana e referência para <code>GameplayAbility</code>.</li>
          <li>No <code>AbilitySystemComponent</code>, conceder habilidades conforme retorno do backend (<code>GET /characters/{id}/skills</code>).</li>
          <li>Ao pressionar um slot, chamar <code>TryActivateAbilityByClass</code> e enviar requisição <code>POST /skills/cast</code> simultaneamente.</li>
          <li>Receber confirmação e aplicar <code>GameplayEffect</code> nas entidades afetadas usando IDs originais.</li>
        </ol>
        <pre><code>Event InputSkill (SkillSlot)
  → AbilityClass = SkillCatalog[SkillSlot].Ability
  → if ASC.TryActivateAbilityByClass(AbilityClass)
        → HTTP POST /skills/cast (SkillID)

Ability::ActivateAbility
  → CommitAbilityCost()
  → PlayMontageAndWait(SkillMontage)
  → SpawnSystemAttached(NiagaraFX)
  → ApplyGameplayEffectSpecToTarget(TargetEffect, TargetData)</code></pre>
      </details>
      <details>
        <summary>Carregamento de Mapas com Subníveis</summary>
        <ol>
          <li>Converter mapas grandes para <code>World Partition</code> e criar <em>Data Layers</em> para iluminação, efeitos e gameplay.</li>
          <li>Usar <code>BP_MapManager</code> para carregar subníveis com base na proximidade do jogador.</li>
          <li>Controlar música ambiente e sons locais via <code>Audio Volumes</code>.</li>
        </ol>
        <pre><code>Event BeginPlay (BP_MapManager)
  → Set Data Layer State (Exploração, Loaded)
  → Load Stream Level (Dungeon_Entrada)

Event OnPlayerReachedPortal
  → Load Stream Level (Dungeon_Boss)
  → Set Data Layer State (Exploração, Unloaded)
  → Set Data Layer State (BossFight, Loaded)
  → AudioManager.PlayCue(MusicaBoss)</code></pre>
      </details>
      <details>
        <summary>Efeitos Visuais Atualizados no Niagara</summary>
        <ol>
          <li>Importar texturas de partículas legadas para o Niagara e criar <code>NS_SpellImpact</code>.</li>
          <li>Expor parâmetros de cor e escala para refletir raridade do item/skill.</li>
          <li>Chamar efeito via <code>GameplayCue</code> ou diretamente nos Blueprints de habilidade.</li>
        </ol>
        <pre><code>Function PlayImpactFX (Contexto)
  NiagaraComponent.SetVariableLinearColor("Color", Contexto.RaridadeCor)
  NiagaraComponent.SetVariableFloat("Scale", Contexto.Escala)
  NiagaraComponent.Activate()
  AudioComponent.Play()
  CameraShake.Play(Contexto.ShakeClass)</code></pre>
      </details>
      <details>
        <summary>Gateway UE5 &lt;&gt; Servidor Moderno (HTTP/JSON)</summary>
        <ol>
          <li>Criar <code>BP_ServerGateway</code> (Object Blueprint) com funções assíncronas para Login, LoadCharacter, SaveInventory.</li>
          <li>Utilizar <code>FHttpModule</code> via <em>Blueprint Function Library</em> (nós <code>Execute HTTP Request</code> ou plugin VaRest) para chamar APIs REST.</li>
          <li>Serializar/deserializar <code>JSON</code> refletindo os mesmos campos dos arquivos <code>Data/Item</code> e tabelas SQL.</li>
          <li>Propagar resultados via <em>Delegates</em> (ex.: <code>OnInventoryReceived</code>) para atualizar HUD/inventário.</li>
        </ol>
        <pre><code>Function LoginAsync (Email, Senha)
  Create Request (POST, /auth/login)
  Set Header "Content-Type" = "application/json"
  Set Content (Make JSON → { "email": Email, "password": Senha })
  Send
  On Success:
    Parse JSON → Token, Characters[]
    Store Token
    Broadcast OnLoginSuccess(Token, Characters)
  On Error:
    Broadcast OnLoginFailed(StatusCode, Message)

Function LoadInventoryAsync (CharacterID)
  Create Request (GET, /characters/{CharacterID}/inventory)
  Set Header "Authorization" = Token
  Send
  On Success:
    Parse JSON → Itens[]
    Broadcast OnInventoryReceived(Itens)

Delegate OnInventoryReceived(Itens)
  → BP_InventoryManager.UpdateFromServer(Itens)</code></pre>
      </details>

    </section>

    <section id="codigo-detalhado">
      <h2>Mapeamento de Código &rarr; Blueprints UE5</h2>
      <p>
        Use o painel abaixo para navegar entre os módulos principais. Cada aba traz o trecho de código do projeto
        original, a leitura da lógica e o passo a passo para replicar em Blueprints na Unreal Engine 5 reaproveitando
        os mesmos assets, coordenadas e fluxos de dados.
      </p>
      <div class="conversion-tabs" role="tablist">
        <button class="conversion-button active" data-pane="hud">HUD &amp; Barra de Experiência</button>
        <button class="conversion-button" data-pane="login">Tela de Login</button>
        <button class="conversion-button" data-pane="items">Sistema Completo de Itens</button>
        <button class="conversion-button" data-pane="inventory">Inventário e Equipamentos</button>
        <button class="conversion-button" data-pane="progression">Progressão / XP</button>
        <button class="conversion-button" data-pane="drops">Sistema de Drops</button>
        <button class="conversion-button" data-pane="character-select">Seleção de Personagens</button>
        <button class="conversion-button" data-pane="mobs">Sistema de Mobs</button>
        <button class="conversion-button" data-pane="skills">Sistema de Skills</button>
        <button class="conversion-button" data-pane="maps">Mapas e Navegação</button>
        <button class="conversion-button" data-pane="effects">Efeitos Visuais</button>
        <button class="conversion-button" data-pane="backend">Backend &amp; Serviços</button>
        <button class="conversion-button" data-pane="qa">QA, Debug &amp; Telemetria</button>
      </div>

      <article class="conversion-pane active" data-pane="hud">
        <h3>HUD Principal com Layout Original</h3>
        <p>
          O cliente define a HUD no <code>CNewUIMainFrameWindow</code>, renderizando faixas, gauges e botões com offsets
          absolutos para 640&times;480 e ajustes proporcionais. Esses valores são a referência direta para posicionar os
          widgets UMG reaproveitando as texturas convertidas de <code>Interface\*.ozj/.ozt</code>.
        </p>
        <div class="source-card">
          <div class="source-meta">Cliente original – <code>Source Main 5.2/source/NewUIMainFrameWindow.cpp</code></div>
          <pre><code>bool SEASON3B::CNewUIMainFrameWindow::Render()
{
        EnableAlphaTest();
        RenderFrame();
        RenderLifeMana();
        RenderGuageSD();
        RenderGuageAG();
        RenderButtons();
        RenderExperience();
        DisableAlphaBlend();
        return true;
}

void SEASON3B::CNewUIMainFrameWindow::RenderFrame()
{
        float width, height;
        float x, y;

        width = 256.f; height = 51.f;
        x = 0.f; y = 480.f - height;
        SEASON3B::RenderImage(IMAGE_MENU_1, x, y, width, height);
        width = 128.f;
        x = 256.f;
        SEASON3B::RenderImage(IMAGE_MENU_2, x, y, width, height);
        width = 256.f;
        x = 256.f + 128.f;
        SEASON3B::RenderImage(IMAGE_MENU_3, x, y, width, height);
}

void SEASON3B::CNewUIMainFrameWindow::RenderGuageSD()
{
        width = 16.f; height = 39.f;
        x = 204; y = 480.f - 49.f;
        RenderBitmap(IMAGE_GAUGE_SD, x, y + (fShield * height), width, height - (fShield * height), 0.f, fShield*height/64.f, width/16.f, (1.0f - fShield)*height/64.f);
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Experiência – <code>RenderExperience()</code> no mesmo arquivo</div>
          <pre><code>x = 2.f; y = 473.f; width = fProgress * 629.f; height = 4.f;
RenderBitmap(IMAGE_GAUGE_EXBAR, x, y, width, height, 0.f, 0.f, 6.f/8.f, 4.f/4.f);
SEASON3B::RenderNumber(635.f, 469.f, (int)fExpBarNum);
if(SEASON3B::CheckMouseIn(x, y, 629.f, 4.f) == true)
{
        sprintf(strTipText, GlobalText[1748], dwExperience, dwNexExperience);
        RenderTipText(280, 418, strTipText);
}</code></pre>
        </div>
        <svg class="layout-map" viewBox="0 0 640 480" aria-labelledby="hud-layout-title">
          <title id="hud-layout-title">Mapa visual da HUD original (640×480)</title>
          <rect x="0" y="429" width="256" height="51" />
          <text x="12" y="446">Menu 1</text>
          <rect x="256" y="429" width="128" height="51" />
          <text x="268" y="446">Menu 2</text>
          <rect x="384" y="429" width="256" height="51" />
          <text x="396" y="446">Menu 3</text>
          <rect class="asset" x="158" y="432" width="45" height="39" />
          <text x="163" y="452">HP</text>
          <rect class="asset" x="437" y="432" width="45" height="39" />
          <text x="442" y="452">MP</text>
          <rect class="asset" x="204" y="431" width="16" height="39" />
          <text x="205" y="425">SD</text>
          <rect class="asset" x="420" y="431" width="16" height="39" />
          <text x="421" y="425">AG</text>
          <rect class="asset" x="2" y="473" width="629" height="4" />
          <text x="6" y="468">XP</text>
        </svg>
        <h4>Passo a passo no UMG</h4>
        <ol>
          <li>Converter as texturas <code>Interface\newui_menu0*.ozj</code>, <code>Interface\newui_menu_red.ozj</code>, <code>Interface\newui_menu_blue.ozj</code>, <code>Interface\newui_menu_sd.ozj</code> e <code>Interface\newui_menu_ag.ozj</code> para <code>.png</code> preservando as dimensões (use a rotina descrita em <code>GlobalBitmap.cpp</code> para remover o cabeçalho de 24 bytes).</li>
          <li>Criar <code>WBP_HUD</code> com um <em>Canvas Panel</em> raiz travado em 640×480 e habilitar <em>Screen Alignment = Fill</em>. Ajustar as âncoras das imagens seguindo o mapa acima (faixas ancoradas em Bottom Stretch, gauges em pontos absolutos).</li>
          <li>Adicionar <em>Progress Bars</em> para HP/MP/SD/AG usando <em>Fill from Bottom</em> e máscaras do mesmo tamanho dos sprites. Os valores de preenchimento replicam <code>height - (valor/max * height)</code>.</li>
          <li>Adicionar um <em>Border</em> invisível sobre a barra de XP e ligar ao evento <code>OnMouseMove</code> para mostrar um tooltip idêntico a <code>RenderTipText</code> (usar <code>Format Text</code> para exibir <em>XP atual</em> / <em>próximo nível</em>).</li>
          <li>Para múltiplas resoluções, encapsular o Canvas em um <em>Scale Box</em> com <em>Stretch = ScaleToFit</em> e expor um multiplicador de DPI para manter legibilidade em monitores maiores.</li>
        </ol>
        <h4>Blueprint (Widget Graph)</h4>
        <pre><code>Event Construct
  → Bind OnStatChanged (BP_PlayerState)
  → AtualizarHUD(Stats)

Event AtualizarHUD (Stats)
  → SetPercent(HPBar, Stats.HP / Stats.MaxHP)
  → SetPercent(MPBar, Stats.MP / Stats.MaxMP)
  → SetPercent(SDBar, Stats.SD / Stats.MaxSD)
  → SetPercent(AGBar, Stats.AG / Stats.MaxAG)
  → AtualizarXP(Stats.CurrentXP, Stats.NextXP)

Function AtualizarXP (XPAtual, XPNecessaria)
  → Progress = Clamp(XPAtual / XPNecessaria, 0, 1)
  → XPBar.SetFillAmount(Progress)
  → XPLabel.SetText(FText::Format("{0}/10", Floor(Progress * 10)))</code></pre>
        <div class="callout">
          <strong>Dica de conversão:</strong> Os botões inferiores usam sprites <code>Interface\partCharge1\newui_menu_Bt*.ozj</code> espaçados de 30&nbsp;px. Monte um <code>UniformGridPanel</code> com colunas fixas e ícones reutilizados para preservar o comportamento original.</div>
      </article>

      <article class="conversion-pane" data-pane="login">
        <h3>Tela de Login (Layout, Fluxo e Backend)</h3>
        <p>
          O cliente original constrói a janela de login em <code>CLoginWin</code> e o cabeçalho em
          <code>CLoginMainWin</code>, reaproveitando sprites <code>BITMAP_LOG_IN</code> e alinhando os
          controles em coordenadas absolutas (base 640×480). Esses valores guiam o posicionamento dos
          widgets UMG e a conversão do fluxo de autenticação para Blueprints na UE5.
        </p>
        <div class="source-card">
          <div class="source-meta">Cliente original – <code>Source Main 5.2/source/LoginWin.cpp</code></div>
          <pre><code>void CLoginWin::Create()
{
        CWin::Create(329, 245, BITMAP_LOG_IN + 7);
        m_asprInputBox[0].Create(156, 23, BITMAP_LOG_IN + 8);
        m_aBtn[0].Create(54, 30, BITMAP_BUTTON);
        m_pIDInputBox = new CUITextInputBox; m_pIDInputBox->Init(g_hWnd, 140, 14, MAX_ID_SIZE);
        m_pPassInputBox = new CUITextInputBox; m_pPassInputBox->Init(g_hWnd, 140, 14, MAX_PASSWORD_SIZE, TRUE);
}

void CLoginWin::SetPosition(int nX, int nY)
{
        m_asprInputBox[0].SetPosition(nX + 109, nY + 106);
        m_asprInputBox[1].SetPosition(nX + 109, nY + 131);
        m_aBtn[0].SetPosition(nX + 150, nY + 178);
        m_aBtn[1].SetPosition(nX + 211, nY + 178);
}

void CLoginWin::UpdateWhileActive(double)
{
        if (m_aBtn[0].IsClick()) RequestLogin();
        else if (CInput::Instance().IsKeyDown(VK_RETURN)) RequestLogin();
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Botões superiores – <code>Source Main 5.2/source/LoginMainWin.cpp</code></div>
          <pre><code>void CLoginMainWin::Create()
{
        for (int i = 0; i &lt;= LMW_BTN_CREDIT; ++i)
                m_aBtn[i].Create(54, 30, BITMAP_LOG_IN + 4 + i, 3, 2, 1);
        CWin::Create(CInput::Instance().GetScreenWidth() - 60, m_aBtn[0].GetHeight(), -2);
        m_sprDeco.Create(189, 103, BITMAP_LOG_IN + 6, 0, NULL, 105, 59);
}</code></pre>
        </div>
        <h4>Mapa de posicionamento (base 640×480)</h4>
        <table>
          <thead>
            <tr>
              <th>Elemento</th>
              <th>Sprite original</th>
              <th>Coordenadas (X, Y)</th>
              <th>Tamanho</th>
              <th>Observações de conversão</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Janela</td>
              <td><code>BITMAP_LOG_IN + 7</code></td>
              <td>(~155, ~120)</td>
              <td>329×245</td>
              <td>Canvas raiz ancorado ao centro; aplicar <em>Scale Box</em> para múltiplas resoluções.</td>
            </tr>
            <tr>
              <td>Input Usuário</td>
              <td><code>BITMAP_LOG_IN + 8</code></td>
              <td>(+109, +106)</td>
              <td>156×23</td>
              <td>Use <em>Editable Text Box</em> com fonte importada de <code>g_hFixFont</code> (Arial 12px).</td>
            </tr>
            <tr>
              <td>Input Senha</td>
              <td><code>BITMAP_LOG_IN + 8</code></td>
              <td>(+109, +131)</td>
              <td>156×23</td>
              <td>Ativar <em>Is Password</em>; manter máscara translúcida (alpha 25).</td>
            </tr>
            <tr>
              <td>Botão OK</td>
              <td><code>BITMAP_BUTTON</code></td>
              <td>(+150, +178)</td>
              <td>54×30</td>
              <td>Reutilize sprites <code>Interface\newui_btn_login_ok.ozj</code>; ligar a <code>RequestLogin</code>.</td>
            </tr>
            <tr>
              <td>Botão Cancelar</td>
              <td><code>BITMAP_BUTTON + 1</code></td>
              <td>(+211, +178)</td>
              <td>54×30</td>
              <td>Executa <code>CancelLogin</code>; na UE5, navegue para <code>MainMenu</code>.</td>
            </tr>
            <tr>
              <td>Botões superiores</td>
              <td><code>BITMAP_LOG_IN + 4..6</code></td>
              <td>(Topo direito)</td>
              <td>54×30</td>
              <td>Monte <em>Horizontal Box</em> ancorada ao topo (Menu/Credits).</td>
            </tr>
          </tbody>
        </table>
        <h4>Passos para replicar no UMG</h4>
        <ol>
          <li>Converter os arquivos <code>Interface\LogIn\*.ozj</code> e <code>Interface\LogIn\*.ozt</code> para <code>.png</code>
            mantendo nomes originais e gerar um atlas 1:1 para <code>WBP_Login</code>.</li>
          <li>Criar um <em>Widget Blueprint</em> com <code>Canvas Panel</code> centralizado em 640×480; inserir imagens para frame,
            inputs e botões seguindo a tabela acima.</li>
          <li>Adicionar <code>EditableTextBox</code> (Usuário) e <code>EditableTextBox</code> (Senha) e replicar a navegação Tab
            usando <code>SetUserFocus</code> no <code>Event Construct</code>, similar ao <code>SetTabTarget</code>.</li>
          <li>Configurar animação de foco inicial: no <code>Event Pre Construct</code>, chamar uma função que decide qual campo
            recebe foco (ID preenchido &rarr; senha) conforme o comportamento de <code>FirstLoad</code>.</li>
          <li>Integrar o backend criando <code>BP_LoginController</code> (Actor) que injeta <code>BP_ServerGateway</code> e expõe
            eventos <code>OnLoginSuccess</code>/<code>OnLoginFailed</code>.</li>
        </ol>
        <h4>Blueprint – Fluxo de autenticação</h4>
        <pre><code>WBP_Login::Event Construct
  → Get GameInstance → GetSubsystem(BP_LoginController)
  → Bind OnLoginSuccess → HandleSuccess
  → Bind OnLoginFailed → HandleFailure

OnClick Botão OK ou OnPress Enter
  → PlaySound2D(SFX_Click)
  → BP_LoginController.RequestLogin(UsuarioText, SenhaText)

BP_LoginController::RequestLogin(User, Pass)
  → Branch (IsEmpty?) → Mostrar aviso
  → ServerGateway.LoginAsync(User, Pass)

ServerGateway::OnLoginSuccess(Token, Characters)
  → SaveGameInstance(Token)
  → OnLoginSuccess.Broadcast(Characters)

WBP_Login::HandleSuccess(Characters)
  → Load Stream Level "CharacterSelect"
  → Passar lista para <code>WBP_CharacterSlots</code>

HandleFailure(Status, Message)
  → Mostrar popup reaproveitando estilo <code>MESSAGE_BOX</code></code></pre>
        <div class="callout">
          <strong>Backend recomendado:</strong> expor <code>POST /auth/login</code> (retorna Token + lista de personagens),
          <code>GET /servers</code> e <code>GET /patch-notes</code> para substituir os botões superiores. Utilize <em>Gameplay
          Tags</em> para mapear códigos de erro legados (GlobalText[450..461]).
        </div>
      </article>

      <article class="conversion-pane" data-pane="items">
        <h3>Sistema Completo de Itens (Dados &rarr; Mundo &rarr; UI)</h3>
        <p>
          Este painel conecta tabelas originais de itens, lógica de colisão de drops e renderização
          no inventário/HUD. Ele serve como referência única para reconstruir metadados, pickups,
          tooltips e sincronização com o backend moderno utilizando Blueprints da UE5.
        </p>
        <div class="grid-2">
          <div class="source-card">
            <div class="source-meta">Dados &mdash; <code>MuServer_Season_5_Update_15/Data/Item/Item.txt</code></div>
            <pre><code>//Index Slot Skill X   Y   Serial Opt Drop  Nome             Lvl  DmgMin DmgMax Speed Dur
0      0    0     1   2   1      1   1     "Kris"           6    6      11     5    20
1      0    0     1   3   1      1   1     "Short Sword"   3    3      7      2    22
2      0    0     1   3   1      1   1     "Rapier"        9    9      15     4    23</code></pre>
          </div>
          <div class="source-card">
            <div class="source-meta">Cliente &mdash; <code>Source Main 5.2/source/NewUIMyInventory.cpp</code></div>
            <pre><code>void CNewUIMyInventory::RenderItemToolTip(int iSlotIndex)
{
    if(m_iPointedSlot != -1)
    {
        ITEM* pEquipmentItemSlot = &CharacterMachine->Equipment[iSlotIndex];
        if(pEquipmentItemSlot->Type != -1)
        {
            int iTargetX = m_EquipmentSlots[iSlotIndex].x + m_EquipmentSlots[iSlotIndex].width / 2;
            int iTargetY = m_EquipmentSlots[iSlotIndex].y + m_EquipmentSlots[iSlotIndex].height / 2;
            if(m_RepairMode == REPAIR_MODE_OFF)
                RenderItemInfo(iTargetX, iTargetY, pEquipmentItemSlot, false);
            else
                RenderRepairInfo(iTargetX, iTargetY, pEquipmentItemSlot, false);
        }
    }
}</code></pre>
          </div>
        </div>
        <div class="grid-2">
          <div class="source-card">
            <div class="source-meta">Cliente &mdash; <code>Source Main 5.2/source/NewUIInventoryCtrl.cpp</code></div>
            <pre><code>void CNewUIPickedItem::Render3D()
{
    if(m_pPickedItem && m_pPickedItem->Type >= 0)
    {
        m_Pos.x = MouseX - m_Size.cx/2;
        m_Pos.y = MouseY - m_Size.cy/2;
        RenderItem3D(m_Pos.x, m_Pos.y, m_Size.cx, m_Size.cy,
            m_pPickedItem->Type, m_pPickedItem->Level,
            m_pPickedItem->Option1, m_pPickedItem->ExtOption, true);
    }
}</code></pre>
          </div>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/Map.cpp</code></div>
            <pre><code>bool CMap::CheckAttr(int x,int y,BYTE attr)
{
    if((this->GetAttr(x,y) & attr) != 0)
    {
        return 1;
    }
    return 0;
}

bool CMap::CheckStandAttr(int x,int y)
{
    if(this->CheckAttr(x,y,2) != 0) return 0;
    if(this->CheckAttr(x,y,4) != 0) return 0;
    if(this->CheckAttr(x,y,8) != 0) return 0;
    return 1;
}</code></pre>
          </div>
        </div>
        <h4>1. Estrutura de Dados e Importação</h4>
        <ol>
          <li>
            Converter <code>Item.txt</code>, <code>ItemOption.txt</code>, <code>ItemDrop.txt</code> e
            <code>ItemValue.txt</code> para <code>.csv</code> ou <code>.json</code>, mantendo índices originais.
            Gere <code>DT_ItemDefinitions</code> (struct <code>FItemDefinition</code>) e
            <code>DT_ItemOptions</code> (struct <code>FItemOption</code>) na UE5.
          </li>
          <li>
            Criar <code>PrimaryDataAsset BP_ItemCatalog</code> para mapear famílias de itens, ícones
            reaproveitados e classes de Blueprint associadas (ex.: <code>BP_Item_Weapon_Kris</code>).
          </li>
          <li>
            Sincronizar dados com backend por endpoint <code>GET /items?hash=</code> reutilizando o checksum
            original dos arquivos para evitar recarregamentos desnecessários.
          </li>
        </ol>
        <h4>2. Blueprint de Instância de Item</h4>
        <ol>
          <li>Criar <code>BP_ItemInstance</code> (Actor) com componentes <code>StaticMesh</code> ou <code>Niagara</code> para pickups.</li>
          <li>Adicionar <code>UBoxComponent</code> (colisão) com tamanho proporcional a <code>Width</code> e <code>Height</code> originais × 32px.</li>
          <li>
            Implementar função <code>InitializeFromRow</code> que recebe <code>FItemDefinition</code> e seta mesh, ícone, raridade,
            atributos e efeitos sonoros/visuais.
          </li>
          <li>
            Ativar replicação e <code>Net Dormancy</code> configurável para evitar tráfego excessivo quando não houver jogadores por perto.
          </li>
        </ol>
        <pre><code>Event InitializeFromRow(RowName)
  → Get Data Table Row (DT_ItemDefinitions, RowName)
  → Set ItemID/Name/Rarity/Dimensions
  → StaticMesh.SetStaticMesh(Row.Mesh)
  → CollisionBox.SetBoxExtent(Row.CollisionExtent)
  → SetCustomDepthStencil(Row.RarityColor)</code></pre>
        <h4>3. Colisão e Validação de Drop</h4>
        <ol>
          <li>
            No backend, reutilizar <code>CheckStandAttr</code> para negar drops em blocos com atributos 2/4/8. Em UE5, gerar
            <code>Gameplay Tags</code> (ex.: <code>Map.Blocked.Drop</code>) a partir de <code>Data/World</code>.
          </li>
          <li>
            No <code>BP_LootService</code>, após confirmação do servidor, traçar <code>Line Trace</code> até o solo e ajustar o pickup
            para evitar interseções. Caso a colisão falhe, solicitar nova posição com fallback conforme lógica original.
          </li>
          <li>
            Configurar <code>OnComponentBeginOverlap</code> do <code>CollisionBox</code> para chamar <code>RequestLoot</code>,
            validando permissões (party, owner) antes de destruir o Actor.
          </li>
        </ol>
        <h4>4. Tooltips e Renderização no Inventário</h4>
        <ol>
          <li>
            Criar <code>WBP_ItemTooltip</code> que recebe <code>FItemDisplayData</code>. Usar <code>SizeBox</code> + <code>VerticalBox</code>
            para replicar as seções do tooltip (nome, atributos, opções, requisitos).
          </li>
          <li>
            Em <code>WBP_Inventory</code>, mapear <code>OnHovered</code> do slot para abrir tooltip na posição do cursor,
            convertendo <code>GridX/GridY</code> em coordenadas absolutas (multiplicar por 32 px + offset <code>(15,200)</code>).
          </li>
          <li>
            Implementar função <code>ComposeTooltip</code> que consulta <code>DT_ItemOptions</code> e adiciona linhas coloridas
            conforme raridade (seguir paleta original: Excellent = #00FF00, Ancient = #00FFFF, Socket = #FF00FF).
          </li>
          <li>
            Para renderização de arrasto, usar <code>WBP_ItemGhost</code> com <code>Image</code> ligado ao ícone original.
            Atualizar a posição na tela a cada <code>Tick</code>, replicando <code>RenderItem3D</code> com coordenadas do mouse.
          </li>
        </ol>
        <pre><code>OnHovered (InventorySlot)
  → Get Item Data (ItemRow, Options, Durability)
  → TooltipWidget = Create Widget (WBP_ItemTooltip)
  → TooltipWidget.Initialize(Item Data)
  → Add to Viewport (ZOrder alto)
  → Set Position in Viewport(MousePosition + Offset)

OnDragDetected
  → Create Widget (WBP_ItemGhost)
  → Set BrushFromTexture(Item.Icon)
  → DragOp.DefaultDragVisual = ItemGhost
  → DragOp.Payload = SlotReference</code></pre>
        <h4>5. Backend &amp; Persistência</h4>
        <ul>
          <li>
            Endpoints mínimos: <code>GET /characters/{id}/inventory</code>, <code>POST /inventory/move</code>,
            <code>POST /inventory/drop</code>, <code>POST /inventory/pickup</code>, <code>POST /inventory/update-stats</code>.
          </li>
          <li>
            Persistir estado visual (durabilidade, tempo restante de itens periódicos) replicando
            <code>m_PeriodicItemTime</code>. Retornar <code>serverTime</code> para cálculo cliente.
          </li>
          <li>
            Utilizar filas (ex.: Redis Streams) para confirmar drops massivos e evitar race conditions em mapas lotados.
          </li>
        </ul>
        <div class="callout">
          <strong>Checklist rápido:</strong>
          <ul>
            <li>Todos os itens possuem <em>RowName</em> e ícone importado? (conferir via <code>Data Validation</code>).</li>
            <li>Colisões dos pickups respeitam <code>CheckStandAttr</code> e impedem drops em áreas proibidas?</li>
            <li>Tooltips reproduzem cores, fontes e texto dinâmico (durabilidade, opções, sockets) do cliente original?</li>
            <li>Arrastar/soltar sincroniza com o backend e restaura estado quando a operação é negada?</li>
          </ul>
        </div>
      </article>

      <article class="conversion-pane" data-pane="inventory">
        <h3>Inventário, Slots e Equipamentos</h3>
        <p>O inventário é criado por <code>CNewUIMyInventory</code>, instanciando um <code>CNewUIInventoryCtrl</code> e carregando os frames de fundo, botões e slots.</p>
        <div class="source-card">
          <div class="source-meta">Cliente – <code>Source Main 5.2/source/NewUIMyInventory.cpp</code></div>
          <pre><code>bool SEASON3B::CNewUIMyInventory::Create(CNewUIManager* pNewUIMng,
        CNewUI3DRenderMng* pNewUI3DRenderMng, int x, int y)
{
        m_pNewInventoryCtrl = new CNewUIInventoryCtrl;
        if(false == m_pNewInventoryCtrl->Create(m_pNewUI3DRenderMng, g_pNewItemMng,
                this, x+15, y+200, 8, 8))
        {
                SAFE_DELETE(m_pNewInventoryCtrl);
                return false;
        }

        SetPos(x, y);
        LoadImages();
        SetEquipmentSlotInfo();
        SetButtonInfo();
        Show(false);
        return true;
}</code></pre>
        </div>
        <h4>Como migrar para Widget Blueprint</h4>
        <ol>
          <li>Converter os sprites <code>Interface\newui_item_back*.ozt</code>, <code>Interface\newui_item_table*.ozt</code>, <code>Interface\newui_exit_00.ozt</code> e ícones de slots para <code>.png</code>. Use as dimensões originais (ex.: 190×320 para o fundo) e mantenha o padding.</li>
          <li>Criar <code>WBP_Inventory</code> com Canvas 640×480. Posicionar o background em <code>(15, 200)</code> para replicar <code>x+15, y+200</code>.</li>
          <li>Adicionar <code>UniformGridPanel</code> 8×8 com células 32×32. Cada item deve armazenar <code>GridX</code>, <code>GridY</code>, <code>Width</code> e <code>Height</code> para suportar itens 2×n.</li>
          <li>Implementar <code>BP_InventoryComponent</code> no personagem com array de <code>FInventorySlot</code> (ItemID, Quantidade, Rotação, Estados). Expor eventos <code>OnItemAdded</code>, <code>OnItemRemoved</code>, <code>OnSlotUpdated</code>.</li>
          <li>No widget, ligar os eventos para replicar <code>AddItem</code>, <code>DeleteItem</code> e <code>FindItemAtPt</code>, atualizando ícones e highlights.</li>
          <li>Para equipamentos, criar painel lateral com slots nomeados. Mapeie <code>MAX_EQUIPMENT_INDEX</code> e <code>EQUIPMENT_WEAPON_LEFT</code> para <em>Enums</em> blueprint e chame o gateway REST equivalente a <code>SendRequestEquippingInventoryItem</code>.</li>
        </ol>
        <h4>Blueprint sugerido (arrastar &amp; soltar)</h4>
        <pre><code>OnMouseButtonDown (ItemSlot)
  → DetectDragIfPressed

OnDragDetected
  → Create DragDropOperation
  → Operation.Payload = SlotData
  → Operation.DefaultDragVisual = WBP_ItemGhost (usa sprite original)

OnDrop
  → TargetSlot = Grid.Coordenada
  → InventoryComponent.TryMoveItem(Payload.Index, TargetSlot)
  → Se sucesso → AtualizarSlotVisual(TargetSlot)
  → Se falha → Reverter visual</code></pre>
        <div class="callout warning">
          <strong>Sincronização com o servidor:</strong> Cada movimento deve chamar <code>POST /inventory/move</code> replicando as mesmas validações de <code>CGItemDropRecv</code> (itens bloqueados, periódicos, lucky items). O backend precisa retornar o inventário atualizado para evitar divergências.</div>
      </article>

      <article class="conversion-pane" data-pane="progression">
        <h3>Progressão de Experiência (Cliente + Servidor)</h3>
        <p>O cliente calcula a fração da barra enquanto o servidor controla o ganho de XP e a distribuição de pontos.</p>
        <div class="source-card">
          <div class="source-meta">Cliente – <code>RenderExperience()</code> em <code>NewUIMainFrameWindow.cpp</code></div>
          <pre><code>float fNeedExp = dwNexExperience - dwPriorExperience;
float fExp = dwExperience - dwPriorExperience;
float fExpBarNum = (fExp / fNeedExp) * 10.f;
float fProgress = fExpBarNum - (int)fExpBarNum;
RenderBitmap(IMAGE_GAUGE_EXBAR, 2.f, 473.f, fProgress * 629.f, 4.f, 0.f, 0.f, 6.f/8.f, 4.f/4.f);
SEASON3B::RenderNumber(635.f, 469.f, (int)fExpBarNum);</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Servidor – <code>CObjectManager::CharacterLevelUp</code></div>
          <pre><code>if((lpObj->Experience+AddExperience) < lpObj->NextExperience)
{
        lpObj->Experience += AddExperience;
        return 0;
}

while(true)
{
        lpObj->Level++;
        lpObj->LevelUpPoint += gServerInfo.m_LevelUpPoint[lpObj->Class];
        AddExperience -= (((--MaxLevelUp)==0)?AddExperience:(lpObj->NextExperience-lpObj->Experience));
        lpObj->Experience = lpObj->NextExperience;
        gObjCalcExperience(lpObj);
        if((lpObj->Experience+AddExperience) < lpObj->NextExperience)
        {
                lpObj->Experience += AddExperience;
                break;
        }
}</code></pre>
        </div>
        <h4>Blueprint + Backend</h4>
        <ol>
          <li>Criar <code>BP_ProgressionComponent</code> com tabela de XP importada do servidor. Variáveis: <code>CurrentXP</code>, <code>NextXP</code>, <code>Level</code>, <code>PendingLevelUps</code>, <code>PointsToSpend</code>.</li>
          <li>Ao receber XP do servidor (resposta ao equivalente de <code>CharacterLevelUp</code>), aplicar a lógica <code>while</code> em Blueprint para consumir múltiplos level ups.</li>
          <li>Disparar <code>OnLevelUp</code> para atualizar atributos, HUD e tocar efeitos. Reaproveitar animações <code>FX_LevelUp</code> e sons originais.</li>
          <li>Persistir pontos gastando via endpoint <code>POST /characters/{id}/stats</code>, enviando <code>PointsToSpend</code> e atributos finais.</li>
        </ol>
        <h4>Blueprint de processamento</h4>
        <pre><code>OnReceiveXPUpdate (Payload)
  → CurrentXP = Payload.CurrentXP
  → NextXP = Payload.NextXP
  → Level = Payload.Level
  → PointsToSpend = Payload.Points
  → PendingLevelUps = Payload.LevelUps
  → HUDWidget.AtualizarXP(CurrentXP, NextXP)
  → For Loop (Index = 0 .. PendingLevelUps-1)
        → HUDWidget.PlayAnimation(LevelUpAnim)
        → SpawnEmitterAtLocation(FX_LevelUp)
        → PlaySound(LevelUpSound)</code></pre>
        <div class="callout">
          <strong>Validação:</strong> mantenha o cálculo oficial no backend para evitar exploits. O Blueprint apenas replica o resultado para feedback imediato.</div>
      </article>

      <article class="conversion-pane" data-pane="drops">
        <h3>Sistema de Drop e Restrições</h3>
        <p>Os drops verificam múltiplas condições antes de delegar ao mapa. O mesmo fluxo deve existir no backend moderno.</p>
        <div class="source-card">
          <div class="source-meta">Servidor – <code>Source MuServer Update 15/GameServer/GameServer/ItemManager.cpp</code></div>
          <pre><code>void CItemManager::CGItemDropRecv(PMSG_ITEM_DROP_RECV* lpMsg,int aIndex)
{
        CItem* lpItem = &lpObj->Inventory[lpMsg->slot];
        if(lpItem->IsLuckyItem() != 0 || lpItem->m_IsPeriodicItem != 0)
        {
                DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
                return;
        }
        if(gItemMove.CheckItemMoveAllowDrop(lpItem->m_Index) == 0)
        {
                DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
                return;
        }
        ...
        if(gMap[lpObj->Map].ItemDrop(lpItem->m_Index,lpItem->m_Level,lpItem->m_Durability,
                lpMsg->x,lpMsg->y,lpItem->m_Option1,lpItem->m_Option2,lpItem->m_Option3,
                lpItem->m_NewOption,lpItem->m_SetOption,lpItem->m_Serial,aIndex,
                lpItem->m_PetItemLevel,lpItem->m_PetItemExp,lpItem->m_JewelOfHarmonyOption,
                lpItem->m_ItemOptionEx,lpItem->m_SocketOption,lpItem->m_SocketOptionBonus,
                lpItem->m_PeriodicItemTime) == 0)
        {
                DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
                return;
        }
        this->InventoryDelItem(aIndex,lpMsg->slot);
}</code></pre>
        </div>
        <h4>Plano de conversão</h4>
        <ol>
          <li>Expor endpoint <code>POST /drops</code> que recebe ItemID, opções e posição. Aplicar as mesmas validações (Lucky, Periodic, Lock, Bag Manager) antes de autorizar.</li>
          <li>No UE5, criar <code>BP_LootService</code> para enviar a requisição e spawnar <code>BP_ItemPickup</code> apenas após sucesso.</li>
          <li>Reutilizar meshes e partículas originais. Para gemas, reaplicar <code>FX_Drop</code> e as cores herdadas de <code>newui_item_table</code>.</li>
          <li>Manter sincronia: se o servidor negar, tocar som de erro e cancelar o arraste (equivalente ao <code>DataSend</code> com <code>result = 0</code>).</li>
        </ol>
        <pre><code>Function RequestDrop(ItemSlot, GridPos)
  → Build Payload (Slot, GridPos, ItemOptions)
  → HTTP POST /drops
  → OnSuccess:
        Inventory.RemoveSlot(ItemSlot)
        SpawnActor(BP_ItemPickup, GridPos)
  → OnError:
        HUD.ShowMessage("Drop negado: motivo")
        Inventory.RefreshSlot(ItemSlot)</code></pre>
        <div class="callout">
          <strong>Triggers especiais:</strong> Kalima Gate, Mercenary, Life Stone e eventos sazonais têm ramos dedicados no código. Crie tabelas <code>DT_SpecialDrop</code> e trate-as antes da lógica genérica para manter o comportamento original.</div>
      </article>

      <article class="conversion-pane" data-pane="character-select">
        <h3>Seleção de Personagens &amp; Criação</h3>
        <p>
          A tela de seleção no cliente legado combina <code>CCharSelMainWin</code> (botões e faixa superior),
          <code>CharMakeWin</code> (criação) e rotinas de câmera em <code>ZzzScene.cpp</code>. A UE5 deve
          reproduzir a mesma disposição dos cinco slots, controle por teclado/mouse e integração com o
          backend (lista de personagens, criação, deleção e entrada no jogo).
        </p>
        <div class="source-card">
          <div class="source-meta">Cliente – <code>Source Main 5.2/source/CharSelMainWin.cpp</code></div>
          <pre><code>void CCharSelMainWin::Create()
{
        m_asprBack[DECO].Create(189, 103, BITMAP_LOG_IN+2);
        m_aBtn[CREATE].Create(54, 30, BITMAP_LOG_IN+3, 4, 2, 1, 3);
        m_aBtn[CONNECT].Create(54, 30, BITMAP_LOG_IN+5, 4, 2, 1, 3);
        CWin::Create(m_aBtn[0].GetWidth() * CSMW_BTN_MAX + m_asprBack[INFO].GetWidth() + 6,
                     m_aBtn[0].GetHeight(), -2);
}

void CCharSelMainWin::SetPosition(int nX, int nY)
{
        m_aBtn[CREATE].SetPosition(nX, nY);
        m_aBtn[MENU].SetPosition(nX + nBtnWidth + 1, nY);
        m_aBtn[DELETE].SetPosition(nWinRight - nBtnWidth, nY);
        m_aBtn[CONNECT].SetPosition(nWinRight - (nBtnWidth * 2 + 1), nY);
}

void CCharSelMainWin::UpdateWhileActive(double)
{
        if (m_aBtn[CONNECT].IsClick()) ::StartGame();
        else if (m_aBtn[CREATE].IsClick()) rUIMng.ShowWin(&rUIMng.m_CharMakeWin);
        else if (m_aBtn[DELETE].IsClick()) DeleteCharacter();
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Criação de personagem – <code>Source Main 5.2/source/CharMakeWin.cpp</code></div>
          <pre><code>CWin::Create(ScreenWidth, ScreenHeight);
m_asprBack[INPUT].Create(346, 38, BITMAP_LOG_IN);
m_abtnJob[i].Create(108, 26, BITMAP_LOG_IN+1, 4, 2, 1);
m_aBtn[OK].SetPosition(nBaseX, nBaseY);
m_aBtn[CANCEL].SetPosition(nX + 400, nBaseY);
UpdateDisplay(); // ativa/desativa classes, textos e preview
</code></pre>
        </div>
        <h4>Layout e reaproveitamento de assets</h4>
        <ul>
          <li><strong>Slots 3D:</strong> a cena <code>CreateCharacterScene()</code> ( <code>ZzzScene.cpp</code> ) posiciona até cinco
            personagens em torno de um pivot central. No UE5, usar um <code>Level Sequence</code> ou <code>Camera Rail</code>
            com cinco <code>BP_CharacterPreview</code> em posições equivalentes (distância ~240 unidades, ângulos 20°).</li>
          <li><strong>Painel superior:</strong> recriar um <code>WBP_CharSelectTopBar</code> com <em>Horizontal Box</em> (Create,
            Menu, Connect, Delete) usando as mesmas texturas <code>newui_btn_charselect_*.ozj</code>.</li>
          <li><strong>Painel informativo:</strong> <code>m_asprBack[INFO]</code> tem largura dinâmica. No UMG, usar <em>Size Box</em>
            ancorada ao topo direito exibindo servidor, avisos e status de bloqueio (texto amarelo quando <code>m_bAccountBlockItem</code>).</li>
          <li><strong>Janela de criação:</strong> a malha de botões (classes) segue colunas 108×26. Em UE5, usar <code>UniformGridPanel</code>
            com <code>Slot Padding = 2</code> e fontes idênticas para manter alinhamento.</li>
        </ul>
        <h4>Fluxo UE5 recomendado</h4>
        <ol>
          <li><em>Game Instance</em> chama <code>ServerGateway.ListCharactersAsync()</code> após login e repassa o resultado para
            <code>WBP_CharacterSelect</code>.</li>
          <li>O widget cria cinco <code>WBP_CharacterSlot</code> que exibem nome, classe, nível e ícones reutilizando sprites do
            inventário (asas, armas). Slots vazios exibem botão “Create”.</li>
          <li>Ao focar um slot, a câmera interpola para o personagem correspondente e toca animação de idle específica
            (mapeada por classe em uma <code>Data Table</code> derivada de <code>CharacterManager.cpp</code>).</li>
          <li>O botão “Connect” chama <code>POST /sessions/enter</code> com <code>CharacterId</code>. Ao sucesso, carrega o mapa
            e aplica dados iniciais (inventário, posição) retornados pelo backend.</li>
          <li>O botão “Delete” abre <code>WBP_Confirmation</code>. Se confirmado, chama <code>DELETE /characters/{id}</code> e
            remove o slot da lista.</li>
        </ol>
        <h4>Blueprint – Widgets principais</h4>
        <pre><code>WBP_CharacterSelect::Event Construct
  → Bind ListCharactersAsync::OnSuccess → PopulateSlots
  → ServerGateway.ListCharactersAsync()

PopulateSlots(Characters)
  → For Index 0..4
        → SlotWidget = CreateWidget(WBP_CharacterSlot)
        → SlotWidget.Setup(Characters[Index])
        → Grid.AddChildToUniformGrid(SlotWidget, Row, Column)
        → SlotWidget.OnSelected.Bind → HandleSlotSelected

HandleSlotSelected(CharData)
  → PreviewManager.ShowCharacter(CharData)
  → SelectedCharacter = CharData
  → UpdateButtons(SelectedCharacter != null)

OnClickConnect
  → ServerGateway.EnterWorldAsync(SelectedCharacter.Id)
  → OnSuccess → OpenLevel(CharData.StartMap)

OnClickCreate
  → OpenWidget(WBP_CharacterCreation)

WBP_CharacterCreation::OnConfirm(Name, Class)
  → ServerGateway.CreateCharacterAsync(Name, Class)
  → OnSuccess → RefreshCharacterList()</code></pre>
        <div class="callout">
          <strong>Dicas adicionais:</strong> mantenha o estado <code>SelectedHero</code> no <em>Player State</em> para compartilhar
          a escolha com outros subsistemas (inventário inicial, cinematics). Registre telemetria para ações de delete/criar,
          replicando os logs do <em>GameServer</em> original.</div>
      </article>

      <article class="conversion-pane" data-pane="mobs">
        <h3>Sistema de Mobs (Spawn &rarr; IA &rarr; Drop)</h3>
        <p>
          O backend antigo controla spawn e comportamento dos mobs através de tabelas e estados pré-definidos. A
          reconstrução na UE5 deve preservar o fluxo original: carregar pontos de spawn, rodar IA temporizada, emitir
          mensagens de estado e conceder drop/XP após a morte.
        </p>
        <div class="source-card">
          <div class="source-meta">Servidor &mdash; <code>MonsterSetBase.cpp</code></div>
          <pre><code>void CMonsterSetBase::Load(char* path)
{
        ...
        info.Type = section;
        info.MonsterClass = lpMemScript->GetNumber();
        info.Map = lpMemScript->GetAsNumber();
        info.Dis = lpMemScript->GetAsNumber();
        info.X = lpMemScript->GetAsNumber();
        info.Y = lpMemScript->GetAsNumber();
        if(section == 1 || section == 3)
        {
                info.Dir = lpMemScript->GetAsNumber();
                info.RespawnTime = lpMemScript->GetAsNumber();
        }
        ...
        this->SetInfo(this->m_count,&info);
        this->m_count++;
}</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Servidor &mdash; <code>MonsterAI.cpp</code></div>
          <pre><code>if((GetTickCount()-lpObj->LastAIRunTime) < ((DWORD)lpMonsterAIUnitInfo->m_DelayTime))
{
        return 0;
}

if(lpMonsterAIUnitInfo->RunAIUnitInfo(aIndex) == 0)
{
        return 0;
}

lpObj->LastAIRunTime = GetTickCount();</code></pre>
        </div>
        <h4>Etapas de conversão</h4>
        <ol>
          <li><strong>Dados:</strong> converter <code>Monster.txt</code>, <code>MonsterSetBase.txt</code> e tabelas auxiliares em <code>DT_MobStats</code> e <code>DT_MobSpawn</code>.</li>
          <li><strong>Spawn:</strong> criar <code>BP_MobSpawner</code> que lê <code>DT_MobSpawn</code>, posiciona pontos com base em <code>X</code>/<code>Y</code> convertidos (multiplique por <code>TERRAIN_SCALE</code>) e solicita instâncias ao backend.</li>
          <li><strong>Instância:</strong> <code>BP_MobCharacter</code> aplica atributos de <code>DT_MobStats</code> (HP, Defesa, Velocidade) e inicia <code>Behavior Tree</code> equivalente ao AI Unit do legado.</li>
          <li><strong>Mensagens:</strong> use <code>Gameplay Message Subsystem</code> ou <code>Multicast RPC</code> para representar <code>ProcessStateMsg</code> (drop, knockback, reset, efeitos).</li>
          <li><strong>Respawn:</strong> armazenar <code>RespawnTime</code> e agendar timers locais apenas após confirmação do servidor, replicando <code>MonsterManager::RespawnMonster</code>.</li>
        </ol>
        <h4>Blueprint de morte, drop e XP</h4>
        <pre><code>Event OnMobDied (DamageContext)
  → Send HTTP (POST /world/mob/{MobInstanceID}/death)
        Body = { KillerId, MapId, Position }
  → OnSuccess (Payload)
        → ForEach Loot in Payload.LootEntries
              SpawnActor(BP_ItemPickup, Loot.Location)
        → Broadcast OnExperienceReceived(Payload.XPArray)
        → ScheduleRespawn(Payload.RespawnInSeconds)

Function ScheduleRespawn(Time)
  → SetTimer(Time)
  → OnTimer → Request Spawn novamente (SpawnerId)</code></pre>
        <div class="callout warning">
          <strong>Validação crítica:</strong> mantenha o cálculo de agro e ataque no servidor (arquivos <code>MonsterAIAgro.cpp</code>, <code>Attack.cpp</code>). O cliente apenas apresenta o resultado, evitando exploits.</div>
        <div class="callout">
          <strong>Checklist:</strong>
          <ul>
            <li>Coordenadas e direções importadas respeitam a malha convertida? (teste com gizmo de depuração).</li>
            <li>Timers de IA replicam <code>m_DelayTime</code> para cada AI Unit.</li>
            <li>Mensagens de estado (código 1, 2, 3, 55, 56, 57) possuem equivalente em eventos UE5.</li>
            <li>Perfis especiais (bosses) usam Behavior Trees específicos com tarefas que consultam <code>MonsterSkillManager.cpp</code>.</li>
          </ul>
        </div>
      </article>

      <article class="conversion-pane" data-pane="skills">
        <h3>Sistema de Skills (Jogador &amp; Mob)</h3>
        <p>
          Os scripts legados definem custo, alcance, cooldown e efeitos adicionais para cada skill. Ao portar para a UE5,
          replique as mesmas estruturas de dados e sincronize casting/cancelamento com o backend antes de aplicar efeitos visuais.
        </p>
        <div class="source-card">
          <div class="source-meta">Servidor &mdash; <code>SkillManager.cpp</code></div>
          <pre><code>info.Index = lpMemScript->GetNumber();
strcpy_s(info.Name,lpMemScript->GetAsString());
info.Damage = lpMemScript->GetAsNumber();
info.Mana = lpMemScript->GetAsNumber();
info.Range = lpMemScript->GetAsNumber();
info.Delay = lpMemScript->GetAsNumber();
info.Type = lpMemScript->GetAsNumber();
info.Effect = lpMemScript->GetAsNumber();
info.RequireLevel = lpMemScript->GetAsNumber();
...</code></pre>
        </div>
        <div class="source-card">
          <div class="source-meta">Cliente &mdash; <code>SkillEffectMgr.cpp</code></div>
          <pre><code>void CSkillEffectMgr::DeleteEffect(int efftype)
{
        for(int i=0;i<MAX_SKILL_EFFECTS;i++)
        {
                OBJECT *o = &m_SkillEffects[i];
                if(o->Live && o->Type==efftype)
                {
                        EffectDestructor(o);
                }
        }
}

bool CSkillEffectMgr::SearchEffect(int iType, OBJECT* pOwner, int iSubType)
{
        for(int i=0; i<MAX_SKILL_EFFECTS; ++i)
        {
                OBJECT *o = &m_SkillEffects[i];
                if(o->Live && o->Type == iType && o->Owner == pOwner)
                {
                        if(iSubType == -1 || o->SubType == iSubType)
                        {
                                return true;
                        }
                }
        }
        return false;
}</code></pre>
        </div>
        <h4>Passos para a UE5</h4>
        <ol>
          <li><strong>Dados:</strong> gerar <code>DT_SkillCatalog</code> com campos de custo, alcance, delay e requisitos por classe exatamente como <code>SkillManager.cpp</code> carrega.</li>
          <li><strong>Componente:</strong> implementar <code>BP_SkillComponent</code> que associa <code>SkillID</code> a um <code>UGameplayAbility</code> ou função Blueprint responsável por validar recurso (mana/bp) e enviar requisição ao servidor.</li>
          <li><strong>Cooldown:</strong> armazenar <code>LastCastTime</code> retornado pelo backend e popular <code>WBP_SkillBar</code> com progresso circular (usando os ícones originais).</li>
          <li><strong>Efeitos:</strong> converter efeitos persistentes em <code>Gameplay Effects</code> e <code>Niagara Systems</code> referenciando o dono (equivalente a <code>Owner</code> em <code>SkillEffectMgr</code>).</li>
          <li><strong>Sincronização:</strong> sempre aguardar confirmação do backend para habilidades que causam dano. Para buffs/visual, é possível reproduzir imediatamente, mas envie <code>POST /skills/cast</code> para validar.</li>
        </ol>
        <h4>Blueprint resumido</h4>
        <pre><code>Event InputSkill (SkillSlot)
  → SkillID = Hotbar[SkillSlot]
  → Dados = DT_SkillCatalog[SkillID]
  → If Cooldown.Ativo → HUD.FlashCooldown(SkillSlot)
  → Else → TryCastSkill(SkillID)

Function ApplySkillResponse (Payload)
  → ForEach Target in Payload.Targets
        → ApplyGameplayEffectToTarget(Target, Payload.EffectHandle)
  → HUD.UpdateCooldown(Payload.SkillID, Payload.Cooldown)
  → If Payload.SpawnFX → SpawnSystemAtLocation(Payload.SpawnFX, Payload.Location)</code></pre>
        <div class="callout">
          <strong>Pontos de validação:</strong>
          <ul>
            <li>Confirme que o consumo de mana/stamina bate com valores originais (diferença máxima aceitável ±1).</li>
            <li>Buffs exclusivos (ex.: Soul Barrier) devem impedir múltiplas instâncias simultâneas assim como <code>SearchEffect</code>.</li>
            <li>Habilidades de mobs reutilizam o mesmo pipeline com perfis automáticos gerados a partir de <code>MonsterSkillManager.cpp</code>.</li>
            <li>Registre métricas de latência de cast para ajustar tolerâncias de cancelamento.</li>
          </ul>
        </div>
      </article>

      <article class="conversion-pane" data-pane="maps">
        <h3>Mapas, Atributos e Respawns</h3>
        <p>O servidor lê os arquivos binários de mapa, armazena atributos e respawns fixos. Esses dados orientam a reconstrução no UE5.</p>
        <div class="source-card">
          <div class="source-meta">Servidor – <code>Source MuServer Update 15/GameServer/GameServer/Map.cpp</code></div>
          <pre><code>void CMap::Load(char* path,int map)
{
        BYTE width, height;
        ReadFile(file,&width,sizeof(width),&BytesRead,0);
        ReadFile(file,&height,sizeof(height),&BytesRead,0);
        this->m_width = width+1;
        this->m_height = height+1;
        int size = this->m_width * this->m_height;
        this->m_MapAttr = (BYTE*)GlobalAlloc(GPTR,size);
        ReadFile(file,this->m_MapAttr,size,&BytesRead,0);
        this->m_path->SetMapDimensions(this->m_width,this->m_height,this->m_MapAttr);
        this->m_MapNumber = map;
}

CMap::CMap()
{
        SetRect(&this->m_MapRespawn[0],130,116,151,137);
        SetRect(&this->m_MapRespawn[1],106,236,112,243);
        SetRect(&this->m_MapRespawn[2],197,35,218,50);
        SetRect(&this->m_MapRespawn[3],174,101,187,125);
}</code></pre>
        </div>
        <h4>Como portar para a UE5</h4>
        <ol>
          <li>Extrair os arquivos de atributos (<code>Map*.att</code>) e meshes (<code>Map*.bmd</code>) do cliente usando a mesma lógica de leitura. Cada byte representa um tile de 4×4 unidades.</li>
          <li>Converter a grade em <code>.csv</code> (X, Y, Attribute) e importar como <code>Data Table</code>. Use Blueprint ou C++ para gerar <code>Landscape</code> e <code>NavModifierVolume</code> conforme o atributo (walkable, noground, safezone).</li>
          <li>Criar <code>BP_MapAttributeVolume</code> que percorre as linhas no <code>BeginPlay</code>, aplicando materiais diferentes e registrando colisões.</li>
          <li>Respawns: transformar os retângulos <code>SetRect</code> em <code>BoxComponent</code> e registrar em <code>BP_GameMode</code> para spawn seguro de jogadores.</li>
          <li>Configurar World Partition subdividindo nos mesmos blocos do cliente (ex.: 256×256 tiles). Reutilizar texturas <code>Data/World</code> e ajustar colisões com base na escala 1 tile = 100 unidades da UE5.</li>
        </ol>
        <pre><code>Event BeginPlay (BP_MapAttributeVolume)
  → ForEach Row (DT_MapAtt)
        → SpawnVolume = AddInstance(Attr == TW_NOGROUND ? NoWalkMaterial : WalkableMaterial)
        → If Attr == TW_SAFEZONE → RegisterRespawnArea(Location, Extent)
        → If Attr == TW_WATER → ApplyWaterPostProcess(Location)</code></pre>
        <div class="callout">
          <strong>Coordenadas originais:</strong> mantenha a escala 1 tile = 100 unidades da UE5 para garantir alinhamento de colisão, alcance de habilidades e posições de NPC.</div>
      </article>

      <article class="conversion-pane" data-pane="effects">
        <h3>Efeitos e Partículas</h3>
        <p>O módulo de efeitos mantém arrays globais e verifica alcance contra personagens antes de aplicar o impacto.</p>
        <div class="source-card">
          <div class="source-meta">Cliente – <code>Source Main 5.2/source/ZzzEffect.cpp</code></div>
          <pre><code>PARTICLE  Particles[MAX_PARTICLES];
OBJECT Effects[MAX_EFFECTS];

bool AddRangeAttack(vec3_t Position, float Range, short PKKey, int DamageKey[], int* piCount, int iMaxKey)
{
        for(int i=0;i<MAX_CHARACTERS_CLIENT;i++)
        {
                CHARACTER *c = &CharactersClient[i];
                OBJECT *o = &c->Object;
                float dx = Position[0]-o->Position[0];
                float dy = Position[1]-o->Position[1];
                float Distance = sqrtf(dx*dx+dy*dy);
                if(o->Live && o->Visible && c!=Hero && !c->Dead && Distance<=Range)
                {
                        DamageKey[(*piCount)++] = c->Key;
                        if(*piCount >= iMaxKey) break;
                }
        }
        return true;
}</code></pre>
        </div>
        <h4>Estratégia Niagara</h4>
        <ol>
          <li>Converter texturas de partículas em <code>Data/Effect</code> para <code>.png</code> ou <code>.tga</code> padrão. Importar como Sprite ou Flipbook no Niagara.</li>
          <li>Criar <code>NS_RangeAttack</code> com inputs <code>Range</code>, <code>Color</code> e <code>DamageKeys</code>. Usar uma <em>Blueprint Function Library</em> para aplicar a mesma checagem de distância e disparar <code>GameplayCue</code>.</li>
          <li>Reaproveitar meshes <code>MODEL_*</code> exportadas para <code>.fbx</code> e usá-las em <code>Niagara Mesh Renderer</code> para raios, lasers e efeitos 3D.</li>
          <li>Centralizar o controle em <code>BP_EffectManager</code>, mantendo <code>Object Pool</code> para partículas similares ao array <code>Particles</code>.</li>
        </ol>
        <pre><code>Function SpawnRangeEffect (Origin, Range, Cue)
  → ActorsInRange = SphereOverlapActors(Range)
  → ForEach Alvo válido
        → ApplyGameplayEffectToTarget(Cue)
  → NiagaraComponent.SetVariableFloat("Range", Range)
  → NiagaraComponent.SetVariableLinearColor("Tint", Cue.Color)
  → NiagaraComponent.Activate()
  → AudioComponent.Play()</code></pre>
        <div class="callout">
          <strong>Feedback sonoro:</strong> mantenha o mapeamento das trilhas listadas em <code>Source Main 5.2/source/DSPlaySound.h</code>. No UE5, utilize <code>MetaSounds</code> com a mesma enumeração para sincronizar áudio e partículas.</div>
      </article>

      <article class="conversion-pane" data-pane="backend">
        <h3>Backend &amp; Serviços Modernizados</h3>
        <p>
          Recrie as responsabilidades do <em>GameServer</em>, <em>DataServer</em> e serviços auxiliares com APIs claras que a UE5 possa consumir
          via <code>HTTP</code>, <code>WebSocket</code> ou <code>gRPC</code>. Mantenha o vínculo com os mesmos dados herdados (SQL e arquivos
          <code>.txt</code>) enquanto aplica autenticação moderna e observabilidade.
        </p>
        <div class="grid-2">
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/GameServer/Protocol.cpp</code></div>
            <pre><code>case 0x0F: // Skill use
    CGUseSkillRecv(aRecv, aIndex);
    break;

case 0x18: // Item pick
    CGItemGetRecv(aIndex, aRecv);
    break;

case 0x17: // Item drop
    gItemManager.CGItemDropRecv((PMSG_ITEM_DROP_RECV*)aRecv, aIndex);
    break;</code></pre>
          </div>
          <div class="source-card">
            <div class="source-meta">Servidor &mdash; <code>Source MuServer Update 15/GameServer/DataServer/DBItemInfo.cpp</code></div>
            <pre><code>BOOL CDBItemInfo::LoadItemInfo(char* szName, BYTE* lpItemInfo)
{
    int nReturn = this->m_DBQuery.Fetch();
    if(nReturn == SQL_NO_DATA) return FALSE;
    memcpy(lpItemInfo, this->m_DBQuery.GetAsBinary("ItemInfo"), MAX_ITEM_INFO);
    return TRUE;
}</code></pre>
          </div>
        </div>
        <h4>Adaptação para microsserviços</h4>
        <ol>
          <li>Criar um <em>Gateway</em> HTTP (Node/Express ou .NET Minimal API) com rotas equivalentes aos <code>case</code> acima: <code>POST /skills/use</code>, <code>POST /inventory/drop</code>, <code>POST /inventory/pick</code>.</li>
          <li>Encapsular consultas SQL em repositórios. Use <code>Dapper</code> ou <code>TypeORM</code> para carregar blobs de item igual ao <code>LoadItemInfo</code>, convertendo para <code>FItemDefinition</code>.</li>
          <li>Adicionar fila de eventos (RabbitMQ/Kafka) para notificações assíncronas (ex.: <em>MobDied</em>, <em>SkillCast</em>) que disparam atualizações em tempo real para os clientes.</li>
          <li>Implementar autenticação com tokens (JWT) emitidos pelo serviço de contas. Os requests do jogo enviam <code>Bearer Token</code> no cabeçalho.</li>
        </ol>
        <h4>Blueprint → HTTP</h4>
        <pre><code>Function BP_RequestDrop(ItemGuid, WorldSlot)
  → Make Json Object { "itemGuid": ItemGuid, "map": MapId, "position": WorldSlot }
  → HttpSubsystem::POST("/inventory/drop", Json)
  → OnSuccess → InventoryComponent.ApplyServerDelta(Response.Payload)
  → OnFailure → MostrarErro("Falha ao dropar item")</code></pre>
        <div class="callout warning">
          <strong>Segurança:</strong> valide tudo no backend. As Blueprints apenas pedem autorização; as regras de PK, safe zone e logs continuam rodando no servidor reescrito.</div>
        <h4>Streaming de dados em tempo real</h4>
        <ul>
          <li><strong>Posições e mobs:</strong> exponha <code>/ws/world</code> para replicar <code>GSGObjViewportListSend</code>. UE5 consome via <code>WebSocket</code> usando <code>UGameInstanceSubsystem</code>.</li>
          <li><strong>Ranking e eventos:</strong> atualize endpoints <code>/events/active</code> e <code>/ranking/{categoria}</code>. Use <code>Async Task Blueprint Proxy</code> para popular painéis sem travar o game thread.</li>
          <li><strong>Persistência de skills:</strong> sempre sincronize cooldowns e buffs no backend para evitar divergências entre clientes.</li>
        </ul>
      </article>

      <article class="conversion-pane" data-pane="qa">
        <h3>QA, Depuração &amp; Telemetria</h3>
        <p>
          Garanta que cada sistema recriado (HUD, itens, mobs, skills, mapas) seja validado com testes automatizados e sessões de QA.
          Use ferramentas de profiling para comparar comportamento com o cliente legado e detectar regressões cedo.
        </p>
        <div class="grid-2">
          <div>
            <h4>Checklist de QA por sprint</h4>
            <ul>
              <li>🔁 <strong>Comparação visual:</strong> capturar screenshots na UE5 e no cliente original usando as mesmas coordenadas e assets.</li>
              <li>🎯 <strong>Logs críticos:</strong> monitorar <code>LogInventory</code>, <code>LogSkill</code>, <code>LogMob</code> no backend para cada ação do jogador.</li>
              <li>🧪 <strong>Testes automatizados:</strong> escrever <code>Functional Tests</code> em UE5 para spawns, drops e tooltips. No backend, criar testes de integração cobrindo <code>/inventory</code>, <code>/skills</code>, <code>/mobs</code>.</li>
              <li>📈 <strong>Telemetria:</strong> enviar métricas para Prometheus/Grafana (tempo de spawn, taxa de erro HTTP, RTT médio do WebSocket).</li>
            </ul>
          </div>
          <div>
            <h4>Ferramentas recomendadas</h4>
            <ul>
              <li><strong>Replay UE5:</strong> habilite <em>Network Replay</em> para reproduzir combates e garantir que skills/drops funcionem em partidas reais.</li>
              <li><strong>Automation System:</strong> configure <code>AutomationTool</code> com grupos <em>Frontend</em> (widgets, blueprint) e <em>Backend</em> (APIs via scripts Python).</li>
              <li><strong>Perf Insights:</strong> use <em>Unreal Insights</em> comparando FPS com efeitos ligados/desligados para descobrir gargalos.</li>
              <li><strong>DataDog / Elastic:</strong> concentre logs de backend e cliente em dashboards com filtros por <em>AccountID</em>, <em>MapID</em> e <em>SkillID</em>.</li>
            </ul>
          </div>
        </div>
        <h4>Exemplo de script de validação cruzada</h4>
        <pre><code># validate_drops.py
from httpx import Client

with Client(base_url="https://api.seu-jogo.com") as http:
    resp = http.post("/inventory/drop", json={
        "itemGuid": "c7a2...",
        "map": 33,
        "position": {"x": 120, "y": 85}
    })
    resp.raise_for_status()
    assert resp.json()["result"] == "ok"

    loot = http.get("/world/mob/last-drop").json()
    assert loot["itemGuid"] == "c7a2..."
    assert loot["map"] == 33
</code></pre>
        <div class="callout">
          <strong>Rotina de regressão:</strong> execute o script acima após cada build noturno e anexe o resultado ao relatório de QA. Combine com <code>Gauntlet</code> no UE5 para validar menus, HUD e combate.</div>
      </article>
    </section>

    <section id="verificacoes">
      <h2>Painel de Decisão Rápida</h2>
      <div class="timeline">
        <div class="timeline-step">
          <span class="label">Início</span>
          <strong>Importo todos os assets agora?</strong>
          <p>Somente após classificar como <em>Pronto</em>, <em>Precisa Ajustes</em> ou <em>Substituir</em>. Caso contrário, importe um lote pequeno para validar materiais e colisões.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Depois do HUD</span>
          <strong>Recrio a interface antes dos sistemas?</strong>
          <p>Sim. Com HUD + Inventário prontos, você valida feedback instantâneo e detecta falta de dados herdados.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Progresso</span>
          <strong>XP ou Itens primeiro?</strong>
          <p>Inicie pelos itens. XP depende de recompensas, então garanta que o inventário suporte equipar/consumir para depois ajustar a progressão.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Conteúdo</span>
          <strong>Mapas ou Drops antes?</strong>
          <p>Mapas. Estruture navegação e colisões; em seguida distribua inimigos e configure drops conforme layout final.</p>
        </div>
        <div class="timeline-step">
          <span class="label">Final</span>
          <strong>Efeitos visuais no fim?</strong>
          <p>Sim. Após sistemas estáveis, aplique Niagara, som e pós-processo com base no gameplay consolidado.</p>
        </div>
      </div>
      <div class="callout" style="margin-top: 1.75rem;">
        <strong>Dica:</strong> Revise o painel após cada etapa. Se houver bloqueio por falta de asset convertido, mova temporariamente para um placeholder marcado com <em>debug material</em> e siga com a lógica.
      </div>
    </section>


    <section id="frontend-backend">
      <h2>Mapa Profundo do Código Original &rarr; Conversão UE5</h2>
      <p>
        Utilize a matriz abaixo para navegar pelo código fonte do cliente (<code>Source Main 5.2</code>) e dos serviços do
        servidor (<code>MuServer_Season_5_Update_15</code>), relacionando cada responsabilidade com a solução equivalente em
        Unreal Engine 5.
      </p>
      <table class="matrix">
        <thead>
          <tr>
            <th>Responsabilidade</th>
            <th>Origem Legada</th>
            <th>Pontos de Atenção</th>
            <th>Conversão Unreal Engine 5</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>HUD Principal</strong></td>
            <td>
              <code>Source Main 5.2/source/NewUIMainFrameWindow.cpp</code><br />
              <code>Source Main 5.2/source/UIControls.cpp</code>
            </td>
            <td>
              Coordenadas absolutas baseadas em <code>g_fScreenRate_x/y</code>, dependências diretas de assets BMP/TGA no
              diretório <code>GlobalBitmap</code>.
            </td>
            <td>
              Criar widgets UMG separados: <code>WBP_StatusBar</code>, <code>WBP_Minimap</code>, <code>WBP_BuffTray</code>.
              Usar <code>Widget Switcher</code> + bindings de escala para preservar proporções. Importar texturas em
              <code>/Game/UI/Legacy</code> e converter para <code>Slate Brush</code>.
            </td>
          </tr>
          <tr>
            <td><strong>Inventário &amp; Misturas</strong></td>
            <td>
              <code>NewUIMyInventory.cpp</code>, <code>NewUIMixInventory.cpp</code>, <code>MixMgr.cpp</code>
            </td>
            <td>
              Slots codificados manualmente, regras de arrastar/soltar via <code>MouseLButton</code>.
            </td>
            <td>
              <code>BP_InventoryGrid</code> + <code>Drag &amp; Drop Operation</code>. Implementar <code>Data Assets</code> para
              fórmulas de mistura e <code>Actor Component</code> para lógica de craft sincronizada com o backend.
            </td>
          </tr>
          <tr>
            <td><strong>Eventos &amp; Bosses</strong></td>
            <td>
              <code>NewUIBloodCastleEnter.cpp</code>, <code>GMDoppelGanger*.cpp</code>, <code>Event.cpp</code>
            </td>
            <td>
              Agendamento hardcoded, dependência de scripts <code>Data/Event/*.dat</code>.
            </td>
            <td>
              Converter para <code>Gameplay Ability System</code> + <code>Gameplay Tags</code>. Usar
              <code>Primary Data Assets</code> para eventos e <code>Timer Manager</code> para agendamentos dinâmicos com dados
              carregados via HTTP.
            </td>
          </tr>
          <tr>
            <td><strong>Networking &amp; Sessões</strong></td>
            <td>
              <code>WSclient.cpp</code>, <code>ProtocolSend.cpp</code>, <code>ServerGroup.cpp</code>
            </td>
            <td>
              Protocolo proprietário baseado em TCP; autenticação manual com <code>SimpleModulus</code>.
            </td>
            <td>
              Migrar para <code>EOS</code> ou <code>OSS</code>. Implementar autenticação JWT/HTTPS e replicação com
              <code>Gameplay Message Subsystem</code>. Reaproveitar chaves existentes para gerar tokens iniciais.
            </td>
          </tr>
          <tr>
            <td><strong>Banco de Dados</strong></td>
            <td>
              Scripts em <code>MuServer_Season_5_Update_15/ScriptSql</code>, rotinas C++ em <code>GameServer/DataServer</code>
            </td>
            <td>
              Stored procedures com lógica de negócios (reset diário, ranking, guilds).
            </td>
            <td>
              Criar microserviços .NET/Node nestas rotinas; expor endpoints REST/GraphQL para UE5. Usar
              <code>Data Access Layer</code> com migrations automatizadas.
            </td>
          </tr>
        </tbody>
      </table>
      <div class="callout">
        <strong>Dica:</strong> mantenha uma planilha de rastreabilidade onde cada arquivo legado tem um destino UE5 documentado
        (Blueprint, C++ ou serviço). Isso acelera revisões e facilita auditorias futuras.
      </div>
    </section>

    <section id="guias-frontend">
      <h2>Guias Específicos de Interface (Frontend)</h2>
      <div class="legend">
        <span>🔁 Reaproveitar Asset</span>
        <span>🎯 Ajustar Coordenadas</span>
        <span>🧩 Lógica Blueprint</span>
        <span>🌐 Integração Backend</span>
      </div>
      <details class="guia" open>
        <summary>HUD Principal &mdash; Coordenadas e Layout</summary>
        <div class="grid-2">
          <div>
            <h4>1. Preparar Assets</h4>
            <ul>
              <li>Exportar elementos <code>GlobalBitmap\Interface\*.bmp</code> para <code>.png</code> (transparência).</li>
              <li>Organizar texturas no UE5 em <code>/Game/UI/HUD/Textures</code> seguindo nomes originais para facilitar busca.</li>
              <li>Criar <code>Material Instance</code> por grupo (barra, moldura, minimapa).</li>
            </ul>
          </div>
          <div>
            <h4>2. Reconstruir Layout</h4>
            <p><strong>Passo a passo:</strong></p>
            <ol>
              <li>Criar <code>WBP_HUD_Master</code> baseado em <code>Canvas Panel</code>.</li>
              <li>Adicionar <code>Overlay</code> com âncoras fixas conforme percentual legado (ex.: barra de HP em 3% x 94%).</li>
              <li>Usar <code>SizeBox</code> para garantir dimensões originais (consultar <code>NewUIMainFrameWindow.cpp</code>).</li>
              <li>Configurar animações em <code>Timeline</code> para efeitos de ganho de XP (<code>m_bExpEffect</code>).</li>
            </ol>
          </div>
        </div>
        <div class="code-card">
<pre>// Trecho original (NewUIMainFrameWindow.cpp)
if (m_bExpEffect && gCurTime - m_dwExpEffectTime < 1500)
{
    float fScale = (float)(gCurTime - m_dwExpEffectTime) / 1500.0f;
    RenderBitmap(IMAGE_EXP_EFFECT, 230.0f, 430.0f, 256.0f*fScale, 64.0f, 0.0f, 0.0f);
}
</pre>
        </div>
        <p><strong>Conversão Blueprint:</strong></p>
        <div class="blueprint-flow">
          <div class="blueprint-step">
            <h4>Evento XP Gained</h4>
            <p>
              No <code>BP_PlayerState</code>, disparar <code>Event XP Gained</code> passando quantidade de XP. Atualizar variável
              <code>ExpEffectStart</code>.
            </p>
          </div>
          <div class="blueprint-step">
            <h4>Widget Animation</h4>
            <p>
              No <code>WBP_HUD_Master</code>, criar animação <em>ExpPulse</em>. Bindar <code>Tick</code> para calcular escala via
              <code>GetWorldDeltaSeconds</code> replicando o fator <code>fScale</code>.
            </p>
          </div>
          <div class="blueprint-step">
            <h4>Material Parameter</h4>
            <p>
              Utilizar <code>Dynamic Material Instance</code> com parâmetro <code>Scale</code> aplicado ao brush. Controlar via
              <code>Set Scalar Parameter Value</code> durante a animação.
            </p>
          </div>
        </div>
      </details>

      <details class="guia">
        <summary>Inventário &amp; Loja Integrada</summary>
        <p>
          Combine os sistemas de inventário (<code>NewUIMyInventory</code>) e loja (<code>NewUIShop</code>) em um fluxo modular
          reutilizando ícones e slots originais.
        </p>
        <ol>
          <li>Gerar <code>Data Table</code> a partir de <code>Data/Item/Item.txt</code> usando script Python (incluir colunas de
            tamanho <em>width/height</em> e categoria).</li>
          <li>Criar <code>WBP_ItemSlot</code> com <code>Border</code> para destacar raridade. Importar <code>Item*.tga</code> como
            <code>Texture2D</code>.</li>
          <li>Implementar arrastar/soltar com <code>OnDragDetected</code> e <code>OnDrop</code>. Use <code>ItemGUID</code> para
            sincronizar com o backend.</li>
          <li>Para a loja, consumir endpoint <code>GET /shop/offers</code> (novo backend) e popular <code>WBP_ShopGrid</code>.
            Enviar compras com <code>POST /shop/purchase</code>, esperando confirmação antes de remover moeda local.</li>
        </ol>
      </details>

      <details class="guia">
        <summary>Tooltips de Itens &amp; Renderização 2D</summary>
        <div class="grid-2">
          <div>
            <h4>Referências Legadas</h4>
            <ul>
              <li><code>NewUIMyInventory::RenderItemToolTip</code> posiciona o tooltip no centro do slot apontado.</li>
              <li><code>NewUIInventoryCtrl::RenderItemToolTip</code> alterna entre <code>RenderItemInfo</code> e <code>RenderRepairInfo</code>.</li>
              <li><code>GlobalText.h</code> fornece as strings localizadas usadas em <code>RenderTipText</code>.</li>
            </ul>
          </div>
          <div class="source-card">
            <div class="source-meta">Cliente &mdash; <code>NewUIInventoryCtrl.cpp</code></div>
            <pre><code>void CNewUIInventoryCtrl::RenderItemToolTip()
{
    if(m_pToolTipItem != NULL)
    {
        ITEM_ATTRIBUTE* pItemAttr = &ItemAttribute[m_pToolTipItem->Type];
        int iTargetX = m_Pos.x + m_pToolTipItem->x*INVENTORY_SQUARE_WIDTH
            + pItemAttr->Width*INVENTORY_SQUARE_WIDTH/2;
        int iTargetY = m_Pos.y + m_pToolTipItem->y*INVENTORY_SQUARE_HEIGHT
            + pItemAttr->Height*INVENTORY_SQUARE_HEIGHT/2;
        RenderItemInfo(iTargetX, iTargetY, m_pToolTipItem, false);
    }
}</code></pre>
          </div>
        </div>
        <h4>Adaptação UE5</h4>
        <ol>
          <li>Criar <code>WBP_ItemTooltip</code> com <code>Canvas Panel</code> raiz e <code>SizeBox</code> ajustável. Utilize <code>TextBlock</code> configurados com fontes convertidas de <code>Tahoma</code> 12 px.</li>
          <li>Implementar <code>PositionTooltip</code> convertendo <code>GridX/GridY</code> em pixels (usar 32 px por célula, equivalente a <code>INVENTORY_SQUARE_WIDTH/HEIGHT</code>) e adicionando o offset <code>(15,200)</code> do inventário legado.</li>
          <li>Para reparo, utilize <code>Widget Switcher</code> alternando entre <em>Default</em> e <em>Repair</em> conforme estado do inventário.</li>
          <li>Reproduzir efeitos de brilho usando <code>Material Instance</code> com máscara original e parâmetro <code>GlowIntensity</code> animado por <code>Timeline</code>.</li>
        </ol>
        <h4>Blueprint</h4>
        <pre><code>Function ShowTooltip(SlotData, bRepairMode)
  → Tooltip = Create Widget (WBP_ItemTooltip)
  → Tooltip.SetData(SlotData, bRepairMode)
  → Tooltip.PositionTooltip(GridOrigin + SlotData.Grid * 32)
  → Tooltip.AddToViewport(ZOrder 900)

Function HideTooltip()
  → If Tooltip Is Valid → Remove From Parent</code></pre>
        <div class="callout">
          <strong>Dica:</strong> use <code>Data Table Row Handle</code> para buscar descrições adicionais (sockets, excellence) e gerar listas dinâmicas com <code>CreateWidget(WBP_TooltipLine)</code> por categoria.
        </div>
      </details>

      <details class="guia">
        <summary>Minimapa + Mapas de Mundo</summary>
        <p>
          Reutilize as texturas <code>MapManager</code> e dados <code>Data/World/World*.txt</code> para gerar minimapas dinâmicos
          e mapas de navegação.
        </p>
        <ul>
          <li>Importar sprites originais do minimapa para <code>/Game/UI/Maps</code>.</li>
          <li>Converter posições absolutas em percentuais (dividir por resolução original 640x480) para aplicar em
            <code>Canvas Panel Slot</code>.</li>
          <li>Gerar <code>Render Targets</code> com ícones 3D (Player, Party, Boss) usando <code>SceneCapture2D</code>.</li>
          <li>Sincronizar com backend via endpoint <code>GET /world/events</code> para mostrar objetivos em tempo real.</li>
        </ul>
      </details>
    </section>

    <section id="backend">
      <h2>Trilha de Modernização Backend</h2>
      <p>
        Abaixo está um roteiro para reconstruir cada serviço do servidor legado em uma arquitetura moderna escalável,
        mantendo compatibilidade com o cliente UE5.
      </p>
      <div class="swimlane">
        <div>
          <strong>Serviço</strong>
          <ul>
            <li>AuthServer</li>
            <li>JoinServer</li>
            <li>DataServer</li>
            <li>GameServer</li>
            <li>Ranking/Tools</li>
          </ul>
        </div>
        <div>
          <strong>Plano de Ação</strong>
          <ul>
            <li>
              Substituir autenticação SimpleModulus por <code>OAuth2/JWT</code>. Criar endpoint <code>POST /auth/login</code>
              que valida credenciais no banco modernizado.
            </li>
            <li>
              Implementar <code>Session Service</code> (Redis/SQL) para registrar servidores disponíveis e distribuir jogadores.
            </li>
            <li>
              Migrar procedures de <code>DataServer</code> para microserviço com <code>Entity Framework</code> ou <code>Prisma</code>
              aplicando migrations automáticas.
            </li>
            <li>
              Criar API WebSocket/HTTP para eventos de gameplay (drop, xp, quests). UE5 se conecta via <code>Subsystem</code>
              personalizado.
            </li>
            <li>
              Reescrever ferramentas (<code>Tools/</code>) como painel web React/Vue para administração em tempo real.
            </li>
          </ul>
        </div>
      </div>
      <h3>Blueprint Gateway &rarr; Backend</h3>
      <p>
        Exemplo de implementação em Blueprint para consumo de API REST hospedada pelo novo backend. Utilize o plugin HTTP
        padrão da UE5 ou o sistema <code>VaRest</code>.
      </p>
      <pre class="code-card"><code>// BP_ServerGateway (Actor Component)
Event RequestLogin(Email, Senha)
  CreateRequest ← Construct HTTP Request
  SetURL "https://api.seuprojeto.com/auth/login"
  SetVerb POST
  SetHeader "Content-Type", "application/json"
  SetContent (Json Serialize {Email, Senha})
  ProcessRequest

Event OnResponseReceived(Request, Response, bWasSuccessful)
  If !bWasSuccessful → Broadcast OnLoginFailed
  Else
    ParseJSON(Response.Content)
    Cache Token, PlayerId
    Broadcast OnLoginSuccess(Token, PlayerId)
    → BP_InventoryManager.LoadRemoteInventory(Token)
</code></pre>
      <p>
        No backend, espelhe as regras de negócio originais (por exemplo, cálculos de XP em <code>GameServer/GameMain.cpp</code>)
        em serviços especializados. Garanta testes unitários antes de integrar com o cliente UE5.
      </p>
      <h3>Checklist de Confiabilidade</h3>
      <ul class="checklist">
        <li>Automatizar testes de carga para <code>/auth/login</code>, <code>/character/load</code> e <code>/drop/register</code>.</li>
        <li>Monitorar logs com ELK/Grafana, correlacionando IDs de sessão ao <code>PlayerID</code>.</li>
        <li>Implementar fila (RabbitMQ/Kafka) para eventos assíncronos como drops e notificações de ranking.</li>
        <li>Configurar pipelines CI/CD para servidor e cliente, garantindo builds reproduzíveis.</li>
      </ul>
    </section>

    <section id="roadmap-integrado">
      <h2>Roadmap Integrado Frontend + Backend (16 Semanas)</h2>
      <p>
        Expanda o cronograma existente com foco em sincronizar as entregas de interface e serviços. Cada marco possui metas
        tangíveis para ambos os lados.
      </p>
      <ol>
        <li>
          <strong>Semanas 1-2:</strong> Auditoria de assets &amp; dados, criação de protótipos UMG, scaffold do backend (Auth,
          Character Service).
        </li>
        <li>
          <strong>Semanas 3-4:</strong> Inventário funcional com persistência via API. Importação inicial de itens e ícones.
        </li>
        <li>
          <strong>Semanas 5-6:</strong> Progressão XP/nível completa, endpoints de missão. Integração de eventos básicos (Blood
          Castle, Devil Square).
        </li>
        <li>
          <strong>Semanas 7-8:</strong> Migração dos mapas principais com streaming e triggers. Backend fornece dados de spawn e
          horário de eventos.
        </li>
        <li>
          <strong>Semanas 9-10:</strong> Sistema de drop refinado com sincronização de loot. Integração de notificações e log de
          itens.
        </li>
        <li>
          <strong>Semanas 11-12:</strong> Loja, economia e guildas conectadas. Ferramentas de administração web minimalistas.
        </li>
        <li>
          <strong>Semanas 13-14:</strong> Polimento audiovisual, efeitos Niagara, metasounds, sistemas de ranking.</li>
        <li>
          <strong>Semanas 15-16:</strong> Testes finais (performance, regressão, cross-play), preparação da release e pipelines
          automatizados.
        </li>
      </ol>
    </section>

    <section id="cronograma">
      <h2>Cronograma Sugerido (12 Semanas)</h2>
      <div class="timeline">
        <div class="timeline-step">
          <span class="label">Semanas 1–2</span>
          <strong>Auditoria &amp; Setup</strong>
          <ul>
            <li>Converter lote piloto de assets e validar materiais.</li>
            <li>Configurar controle de versão e documentação.</li>
            <li>Definir curvas de XP, lista de itens e mapas prioritários.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 3–5</span>
          <strong>HUD, Inventário e Dados</strong>
          <ul>
            <li>Recriar HUD completo e fluxo de inventário.</li>
            <li>Integrar dados de itens e efeitos básicos.</li>
            <li>Testar persistência e replicação (se multiplayer).</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 6–8</span>
          <strong>Progressão &amp; Loot</strong>
          <ul>
            <li>Implementar XP, níveis, habilidades destraváveis.</li>
            <li>Configurar drops por região e chefes.</li>
            <li>Balancear economia e recompensas.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 9–10</span>
          <strong>Mapas e Conteúdo</strong>
          <ul>
            <li>Migrar mapas restantes com colisão e navegação.</li>
            <li>Adicionar eventos, missões e spawners.</li>
            <li>Testes de performance e correções estruturais.</li>
          </ul>
        </div>
        <div class="timeline-step">
          <span class="label">Semanas 11–12</span>
          <strong>Polimento Final</strong>
          <ul>
            <li>Atualizar VFX, trilhas e voice overs.</li>
            <li>QA completo, bug bash e checklist de build.</li>
            <li>Preparar material de entrega e documentação final.</li>
          </ul>
        </div>
      </div>
    </section>
  </main>
  <footer>
    Atualize este guia conforme novas descobertas na migração. Marque o progresso no checklist e use os exemplos de Blueprint como base para acelerar as próximas etapas.
  </footer>
  <script>
    const stageContent = {
      default: {
        titulo: "Ordem ideal sugerida",
        passos: [
          "Finalize auditoria e importação de um lote piloto de assets.",
          "Protótipo completo de HUD + inventário utilizando dados originais.",
          "Implemente itens, XP e drops com Data Tables reaproveitadas.",
          "Migre mapas, spawners e triggers para UE5 com World Partition.",
          "Ajuste efeitos, áudio e iluminação, encerrando com testes finais."
        ]
      },
      asset: {
        titulo: "Quando há muitos assets convertidos",
        passos: [
          "Priorize planilha de estado dos assets e importe somente os aprovados.",
          "Crie um mapa de revisão (Asset Playground) para testar materiais/LODs.",
          "Depois conecte HUD + inventário usando os ícones e meshes já convertidos.",
          "Mantenha assets incompletos marcados como placeholders até a Etapa 4."
        ]
      },
      ui: {
        titulo: "Foco em interface",
        passos: [
          "Migre fontes, ícones e animações UI para UMG.",
          "Implemente HUD modular usando Common UI e reutilizando widgets originais.",
          "Conecte inventário e barras de status aos dados herdados.",
          "Só avance para XP/drops quando HUD responder a todos eventos principais."
        ]
      },
      core: {
        titulo: "Foco em sistemas centrais",
        passos: [
          "Garanta que Data Tables de itens, XP e drops estejam convertidas.",
          "Crie componentes Blueprints (Inventory, Progression, LootSpawner).",
          "Monte mapa de combate de teste para balancear valores reutilizados.",
          "Integre com HUD existente antes de distribuir para mapas completos."
        ]
      },
      maps: {
        titulo: "Entrega rápida de mapas",
        passos: [
          "Importe blocos estruturais (terreno, malhas principais) primeiro.",
          "Configure World Partition e volumes de navegação.",
          "Reaplique iluminação/pós-processo original e valide colisões.",
          "Após mapas estáveis, posicione inimigos e conecte drops e eventos."
        ]
      },
      vfx: {
        titulo: "Foco em efeitos e audiovisual",
        passos: [
          "Organize texturas de partículas e sons legados em pastas Niagara/Audio.",
          "Atualize efeitos críticos (habilidades, feedback de dano) usando Niagara.",
          "Integre MetaSounds para música adaptativa com dados reutilizados.",
          "Finalize com pós-processo e passes de iluminação após mapas prontos."
        ]
      }
    };

    const select = document.getElementById("perfil");
    const output = document.getElementById("saidaPlano");
    document.getElementById("verPlano").addEventListener("click", () => {
      const escolha = stageContent[select.value] || stageContent.default;
      output.innerHTML = `<strong>${escolha.titulo}</strong><ol style="margin-top:0.85rem;">${escolha.passos
        .map((passo) => `<li>${passo}</li>`)
        .join("")}</ol>`;
    });

    const atlasTabs = document.querySelectorAll(".atlas-tab");
    const atlasContents = document.querySelectorAll(".atlas-content");
    atlasTabs.forEach((tab) => {
      tab.addEventListener("click", () => {
        const alvo = tab.dataset.tab;
        atlasTabs.forEach((t) => t.classList.toggle("active", t === tab));
        atlasContents.forEach((content) => {
          content.classList.toggle("active", content.dataset.tab === alvo);
        });
      });
    });

    const conversionButtons = document.querySelectorAll(".conversion-button");
    const conversionPanes = document.querySelectorAll(".conversion-pane");
    conversionButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const target = button.dataset.pane;
        conversionButtons.forEach((b) => b.classList.toggle("active", b === button));
        conversionPanes.forEach((pane) => {
          pane.classList.toggle("active", pane.dataset.pane === target);
        });
      });
    });
  </script>
</body>
</html>
